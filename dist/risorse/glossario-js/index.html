<!doctype html><html lang="it"><head><meta charset="UTF-8"><meta content="width=device-width,initial-scale=1" name="viewport"><title>Glossario JS - Codedge</title><meta content="Glossario JavaScript dalla A alla Z: definizioni semplici con esempi rapidi per capire sintassi, metodi e concetti chiave." name="description"><link href="https://codedge.it/risorse/glossario-js/" rel="canonical"/><script crossorigin src="/assets/risorse/glossario-js-Fx8-v-Mf.js" type="module"></script><link href="/assets/breadcrumb-loader-DZKY_0fu.js" rel="modulepreload" crossorigin><link href="/assets/glossario-DE3qK-i8.js" rel="modulepreload" crossorigin><link href="/assets/breadcrumb-loader-CfEKlSNE.css" rel="stylesheet" crossorigin><link href="/assets/glossario-CWRNk4U2.css" rel="stylesheet" crossorigin></head><body><header><nav class="navbar"><div class="navbar-container"><img alt="Logo codedge" class="logo" height="35" src="/icons/codedge-logo.svg" width="80"/><h1 class="resize-text"><i class="fa-js-square fab" aria-hidden="true"></i> Glossario JS</h1><div class="menu-icon"><span class="bar"></span> <span class="bar"></span> <span class="bar"></span></div><ul class="nav-menu" id="nav-menu"></ul></div></nav><div aria-hidden="false" id="breadcrumb-container"></div><div class="search-container"><input id="search" placeholder="Cerca un tag..."><h2 class="glossari_resize">Definizioni chiare con esempi rapidi</h2></div></header><div class="sidebar-toggle"><span class="bar"></span> <span class="bar"></span> <span class="bar"></span></div><div class="main-content"><div class="sidebar-placeholder"></div><aside><div class="aside-content"><ul class="concept-list"><ul><li>1. Variabili</li><ul><li class="clickable-item">Var</li><li class="clickable-item">Let</li><li class="clickable-item">Const</li></ul><li>2. Tipi di Dati</li><ul><li class="clickable-item">Number</li><li class="clickable-item">BigInt</li><li class="clickable-item">String</li><li class="clickable-item">Boolean</li><li class="clickable-item">null</li><li class="clickable-item">undefined</li><li class="clickable-item">Symbol</li><li class="clickable-item">Object</li><li class="clickable-item">Function</li><li class="clickable-item">Array</li><li class="clickable-item">Map</li><li class="clickable-item">Set</li><li class="clickable-item">Date</li><li class="clickable-item">RegExp</li><li class="clickable-item">WeakMap</li><li class="clickable-item">WeakSet</li></ul><li>3. Operatori</li><ul><li class="clickable-item">Addizione</li><li class="clickable-item">Sottrazione</li><li class="clickable-item">Moltiplicazione</li><li class="clickable-item">Divisione</li><li class="clickable-item">Modulo</li><li class="clickable-item">Esponenziazione</li><li class="clickable-item">Incremento</li><li class="clickable-item">Decremento</li><li class="clickable-item">Assegnamento</li><li class="clickable-item">Uguaglianza non stretta</li><li class="clickable-item">Uguaglianza stretta</li><li class="clickable-item">Disuguaglianza non stretta</li><li class="clickable-item">Disuguaglianza stretta</li><li class="clickable-item">AND logico</li><li class="clickable-item">OR logico</li><li class="clickable-item">NOT logico</li><li class="clickable-item">Operatore ternario</li><li class="clickable-item">Operatore di concatenazione opzionale</li><li class="clickable-item">Operatore di coalescenza nulla</li><li class="clickable-item">Operatore di diffusione (spread)</li><li class="clickable-item">Operatore typeof</li><li class="clickable-item">Operatore instanceof</li></ul><li>4. Controllo del Flusso</li><ul><li class="clickable-item">if</li><li class="clickable-item">else</li><li class="clickable-item">else if</li><li class="clickable-item">switch</li><li class="clickable-item">break</li><li class="clickable-item">continue</li><li class="clickable-item">return</li></ul><li>5. Cicli</li><ul><li class="clickable-item">for</li><li class="clickable-item">while</li><li class="clickable-item">do...while</li><li class="clickable-item">for...in</li><li class="clickable-item">for...of</li></ul><li>6. Funzioni</li><ul><li class="clickable-item">Arrow function</li><li class="clickable-item">Callback</li><li class="clickable-item">IIFE</li><li class="clickable-item">Closure</li><li class="clickable-item">Parametri di default</li><li class="clickable-item">Rest parameters</li></ul><li>7. Oggetti</li><ul><li class="clickable-item">this</li><li class="clickable-item">Object.create()</li><li class="clickable-item">Object.assign()</li><li class="clickable-item">Object.keys()</li><li class="clickable-item">Object.values()</li><li class="clickable-item">Object.entries()</li><li class="clickable-item">Object.freeze()</li><li class="clickable-item">Object.seal()</li><li class="clickable-item">Object.hasOwn()</li><li class="clickable-item">Destructuring</li><li class="clickable-item">Shorthand property names</li><li class="clickable-item">Computed property names</li></ul><li>8. Array</li><ul><li class="clickable-item">push()</li><li class="clickable-item">pop()</li><li class="clickable-item">shift()</li><li class="clickable-item">unshift()</li><li class="clickable-item">slice()</li><li class="clickable-item">splice()</li><li class="clickable-item">map()</li><li class="clickable-item">filter()</li><li class="clickable-item">reduce()</li><li class="clickable-item">forEach()</li><li class="clickable-item">find()</li><li class="clickable-item">findIndex()</li><li class="clickable-item">some()</li><li class="clickable-item">every()</li><li class="clickable-item">includes()</li></ul><li>9. Errori</li><ul><li class="clickable-item">try...catch</li><li class="clickable-item">throw</li><li class="clickable-item">finally</li><li class="clickable-item">Error</li></ul><li>10. Asincronia</li><ul><li class="clickable-item">setTimeout()</li><li class="clickable-item">setInterval()</li><li class="clickable-item">Promise</li><li class="clickable-item">async</li><li class="clickable-item">await</li><li class="clickable-item">fetch()</li></ul><li>11. Eventi</li><ul><li class="clickable-item">addEventListener()</li><li class="clickable-item">removeEventListener()</li><li class="clickable-item">click</li><li class="clickable-item">keydown</li><li class="clickable-item">submit</li><li class="clickable-item">Event object</li><li class="clickable-item">Event bubbling</li><li class="clickable-item">Event delegation</li></ul><li>12. DOM (Document Object Model)</li><ul><li class="clickable-item">getElementById()</li><li class="clickable-item">querySelector()</li><li class="clickable-item">querySelectorAll()</li><li class="clickable-item">innerHTML</li><li class="clickable-item">textContent</li><li class="clickable-item">createElement()</li><li class="clickable-item">appendChild()</li><li class="clickable-item">removeChild()</li><li class="clickable-item">setAttribute()</li><li class="clickable-item">classList</li></ul><li>13. Moduli</li><ul><li class="clickable-item">import</li><li class="clickable-item">export</li><li class="clickable-item">default export</li><li class="clickable-item">named export</li></ul><li>14. Altri concetti</li><ul><li class="clickable-item">Strict mode</li><li class="clickable-item">Hoisting</li><li class="clickable-item">Temporal Dead Zone (TDZ)</li><li class="clickable-item">Garbage collection</li><li class="clickable-item">Prototype chain</li></ul></ul></ul></div></aside><main><section><details><summary>var<span class="tag-description" aria-label="descrizione tag">Variabile con scoping a livello di funzione.</span><div class="tag-group" aria-label="gruppo">1. Variabile</div></summary><ol><li>Cos'è: La keyword "var" in JavaScript è utilizzata per dichiarare una variabile con scoping a livello di funzione o globale.</li><li>A cosa serve: Viene utilizzata per creare e inizializzare variabili in JavaScript, permettendo di allocare spazio in memoria per memorizzare valori.</li><li>Quando usarlo: Può essere usato per dichiarare variabili, ma in JavaScript moderno è generalmente preferibile utilizzare "let" o "const" per un migliore controllo dello scope.</li><li>Rilevanza semantica: Indica al motore JavaScript che si sta dichiarando una variabile, ma non fornisce informazioni sul tipo di dato o sulla mutabilità.</li><li>Principali caratteristiche:<ul><li>Ha uno scope di funzione o globale</li><li>Permette la ridichiarazione all'interno dello stesso scope</li><li>Subisce l'hoisting (la dichiarazione viene "sollevata" all'inizio dello scope)</li><li>Le variabili dichiarate con var possono essere riassegnate</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Evitare l'uso di "var" in favore di "let" e "const" in codice moderno</li><li>Se usato, dichiarare le variabili all'inizio della funzione per chiarezza</li><li>Essere consapevoli del comportamento di hoisting per evitare errori</li><li>Utilizzare nomi di variabili descrittivi e significativi</li><li>Evitare di dichiarare variabili globali quando possibile</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di variabile globale
    var globalVar = "Sono globale";
    
    function exampleFunction() {
        // Dichiarazione di variabile locale alla funzione
        var localVar = "Sono locale";
        
        if (true) {
            var blockVar = "Sono visibile fuori dal blocco";
        }
        console.log(blockVar); // Funziona, stampa "Sono visibile fuori dal blocco"
    }
    
    console.log(globalVar); // Funziona
    console.log(localVar); // Errore: localVar is not defined
                                </code></pre></div></li><li>Alternative:<ul><li>"let": Per variabili con scoping di blocco che possono essere riassegnate</li><li>"const": Per variabili con scoping di blocco che non possono essere riassegnate</li></ul></li><li>Potenziali errori comuni:<ul><li>Utilizzare "var" pensando che abbia uno scoping di blocco</li><li>Non considerare l'hoisting, che può portare a comportamenti inaspettati</li><li>Ridichiarare accidentalmente una variabile nello stesso scope</li><li>Creare involontariamente variabili globali omettendo la parola chiave "var"</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di "var" non ha un impatto significativo sulle performance rispetto a "let" o "const"</li><li>L'hoisting può influenzare leggermente le prestazioni in scenari complessi</li><li>L'uso eccessivo di variabili globali può influire negativamente sulle prestazioni e sulla manutenibilità del codice</li></ul></li><li>Conclusioni: Mentre "var" è stato il metodo standard per dichiarare variabili in JavaScript per molto tempo, le moderne best practices suggeriscono di utilizzare "let" e "const" per un migliore controllo dello scope e per evitare errori comuni. Tuttavia, comprendere "var" è importante per la manutenzione di codice legacy e per una comprensione completa del linguaggio JavaScript. La sua flessibilità può essere sia un vantaggio che uno svantaggio, rendendo cruciale la comprensione del suo comportamento per scrivere codice JavaScript robusto e manutenibile.</li></ol></details><details><summary>let<span class="tag-description" aria-label="descrizione tag">Variabile con scoping a livello di blocco.</span><div class="tag-group" aria-label="gruppo">1. Variabile</div></summary><ol><li>Cos'è: La keyword "let" in JavaScript è utilizzata per dichiarare una variabile con scoping a livello di blocco.</li><li>A cosa serve: Viene utilizzata per dichiarare variabili in JavaScript che sono limitate allo scope del blocco in cui vengono dichiarate (ad esempio, dentro un ciclo o un'istruzione condizionale).</li><li>Quando usarlo: Utilizza "let" quando hai bisogno di dichiarare una variabile che può essere riassegnata e che deve essere visibile solo all'interno di un determinato blocco di codice.</li><li>Rilevanza semantica: La keyword "let" dichiara una variabile con visibilità limitata al blocco in cui viene definita, evitando problemi legati all'hoisting e alla ridichiarazione.</li><li>Principali caratteristiche:<ul><li>Ha uno scope di blocco (blocco, funzione, o globale)</li><li>Non permette la ridichiarazione nello stesso scope</li><li>È soggetta a hoisting, ma la variabile non può essere usata prima della sua dichiarazione (TDZ - Temporal Dead Zone)</li><li>Le variabili dichiarate con let possono essere riassegnate</li></ul></li><li>Compatibilità:<ul><li>Supportato nelle versioni moderne di JavaScript (ES6 e successive)</li><li>Funziona in tutti i browser moderni</li><li>Non compatibile con vecchie versioni di browser senza pollyfills</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa "let" quando hai bisogno di una variabile che può essere riassegnata, ma che deve essere confinata allo scope di un blocco</li><li>Evita di dichiarare variabili con "var" per evitare errori di scoping e preferisci "let" e "const"</li><li>Dichiara le variabili il più vicino possibile al loro utilizzo per migliorarne la leggibilità</li><li>Evita di usare variabili globali quando possibile</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di variabile con scope di blocco
    let x = 10;
    if (x === 10) {
        let y = 20; // y è visibile solo all'interno di questo blocco
        console.log(y); // Output: 20
    }
    console.log(y); // Errore: y is not defined
    
    // Riassegnazione di una variabile dichiarata con let
    let nome = "Mario";
    nome = "Luigi";
    console.log(nome); // Output: Luigi
                                </code></pre></div></li><li>Alternative:<ul><li>"const": Per dichiarare variabili con scoping di blocco che non possono essere riassegnate</li><li>"var": Per dichiarare variabili con scoping a livello di funzione o globale (sconsigliato in codice moderno)</li></ul></li><li>Potenziali errori comuni:<ul><li>Utilizzare "let" pensando che le variabili siano accessibili fuori dal blocco in cui vengono dichiarate</li><li>Tentare di accedere a una variabile prima che venga dichiarata, a causa del comportamento della TDZ (Temporal Dead Zone)</li><li>Ridichiarare la stessa variabile nello stesso scope, cosa che genera un errore</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di "let" rispetto a "var" può migliorare la leggibilità e manutenibilità del codice, riducendo il rischio di errori di scoping</li><li>Non ci sono differenze di performance significative rispetto all'uso di "var" o "const", salvo in scenari complessi</li></ul></li><li>Conclusioni: "let" è la keyword preferita in JavaScript moderno per dichiarare variabili che possono essere riassegnate e che devono avere uno scope limitato a un blocco. Utilizzarlo in sostituzione di "var" aiuta a scrivere codice più chiaro e meno soggetto a errori. È particolarmente utile in cicli e condizionali dove il comportamento di scoping di blocco è essenziale per evitare conflitti tra variabili.</li></ol></details><details><summary>const<span class="tag-description" aria-label="descrizione tag">Variabile con scoping a livello di blocco e valore costante.</span><div class="tag-group" aria-label="gruppo">1. Variabile</div></summary><ol><li>Cos'è: La keyword "const" in JavaScript viene utilizzata per dichiarare variabili il cui valore non può essere riassegnato dopo l'inizializzazione.</li><li>A cosa serve: Viene utilizzata per dichiarare variabili con scoping di blocco, il cui valore è costante e non può essere cambiato una volta assegnato.</li><li>Quando usarlo: Utilizza "const" quando hai bisogno di dichiarare variabili che non devono essere riassegnate, come costanti o riferimenti a oggetti e array che non cambiano di riferimento.</li><li>Rilevanza semantica: La keyword "const" indica che la variabile è una costante, ovvero il suo valore non può essere modificato dopo la dichiarazione, garantendo maggiore sicurezza nel codice.</li><li>Principali caratteristiche:<ul><li>Ha uno scope di blocco</li><li>Non permette la ridichiarazione o la riassegnazione</li><li>È soggetta a hoisting, ma non può essere utilizzata prima della dichiarazione a causa della TDZ (Temporal Dead Zone)</li><li>Il riferimento di un oggetto o array dichiarato con "const" non può essere cambiato, ma le loro proprietà o elementi possono essere modificati</li></ul></li><li>Compatibilità:<ul><li>Supportato nelle versioni moderne di JavaScript (ES6 e successive)</li><li>Funziona in tutti i browser moderni</li><li>Non compatibile con vecchie versioni di browser senza pollyfills</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizza "const" di default per dichiarare variabili, a meno che tu non abbia bisogno di riassegnarle, in tal caso usa "let"</li><li>Assicurati di inizializzare la variabile al momento della dichiarazione, poiché "const" richiede un'inizializzazione immediata</li><li>Usa "const" per migliorare la leggibilità e manutenibilità del codice, garantendo che le variabili non vengano riassegnate inavvertitamente</li><li>Per oggetti e array, utilizza "const" per mantenere fisso il riferimento, ma gestisci con attenzione le modifiche alle proprietà o agli elementi</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di variabile con valore costante
    const PI = 3.14159;
    console.log(PI); // Output: 3.14159
    
    // Errore se si tenta di riassegnare la variabile
    // PI = 3.14; // Errore: Assignment to constant variable
    
    // Dichiarazione di un array con const
    const numeri = [1, 2, 3];
    numeri.push(4); // Funziona, poiché le proprietà di un array possono essere modificate
    console.log(numeri); // Output: [1, 2, 3, 4]
    
    // Errore se si tenta di riassegnare l'intero array
    // numeri = [5, 6, 7]; // Errore: Assignment to constant variable
                                </code></pre></div></li><li>Alternative:<ul><li>"let": Per dichiarare variabili con scoping di blocco che possono essere riassegnate</li><li>"var": Per dichiarare variabili con scoping a livello di funzione o globale (sconsigliato in codice moderno)</li></ul></li><li>Potenziali errori comuni:<ul><li>Tentare di riassegnare una variabile dichiarata con "const"</li><li>Non inizializzare una variabile al momento della dichiarazione con "const", il che genera un errore</li><li>Confondere l'immutabilità del riferimento di un oggetto o array con l'immutabilità delle sue proprietà o elementi</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di "const" aiuta a prevenire errori legati alla riassegnazione di variabili, migliorando la manutenibilità del codice</li><li>Non ci sono differenze di performance significative rispetto all'uso di "let", salvo in scenari complessi</li><li>Un uso eccessivo di variabili globali può comunque influire negativamente sulle prestazioni e sulla manutenibilità del codice, anche se dichiarate con "const"</li></ul></li><li>Conclusioni: "const" è la keyword preferita per dichiarare variabili che non devono essere riassegnate, migliorando la leggibilità e la sicurezza del codice. È particolarmente utile per costanti, oggetti e array il cui riferimento deve rimanere invariato. Il suo utilizzo dovrebbe essere il default, tranne nei casi in cui è necessario riassegnare il valore di una variabile, dove si preferisce "let".</li></ol></details><details><summary>number<span class="tag-description" aria-label="descrizione tag">Tipo di dato numerico che rappresenta sia interi che numeri in virgola mobile.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: "number" in JavaScript è un tipo di dato primitivo che rappresenta valori numerici, inclusi interi e numeri in virgola mobile.</li><li>A cosa serve: Viene utilizzato per rappresentare e manipolare valori numerici in JavaScript, permettendo calcoli matematici e operazioni aritmetiche.</li><li>Quando usarlo: Si usa quando si ha bisogno di lavorare con qualsiasi tipo di valore numerico, sia esso intero o decimale.</li><li>Rilevanza semantica: Indica al motore JavaScript che il valore è numerico e può essere utilizzato in operazioni matematiche.</li><li>Principali caratteristiche:<ul><li>Rappresenta sia interi che numeri in virgola mobile</li><li>Utilizza la rappresentazione in doppia precisione a 64 bit (formato IEEE 754)</li><li>Può rappresentare numeri da -(2^53 - 1) a (2^53 - 1)</li><li>Include valori speciali come Infinity, -Infinity e NaN (Not a Number)</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare metodi come isNaN() e isFinite() per verificare la validità dei numeri</li><li>Prestare attenzione alle operazioni che possono portare a perdita di precisione</li><li>Usare BigInt per numeri interi più grandi di (2^53 - 1)</li><li>Utilizzare metodi come toFixed() per controllare la precisione decimale</li><li>Considerare l'uso di librerie specializzate per calcoli di alta precisione</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di numeri
    let intero = 42;
    let decimale = 3.14;
    let esponenziale = 2.998e8; // 2.998 * 10^8
    
    // Operazioni matematiche
    let somma = 5 + 3; // 8
    let prodotto = 4 * 2.5; // 10
    let divisione = 10 / 3; // 3.3333333333333335
    
    // Valori speciali
    let infinito = Infinity;
    let nonNumero = NaN;
    
    // Verifiche
    console.log(isNaN(nonNumero)); // true
    console.log(isFinite(infinito)); // false
    
    // Conversioni
    let stringaNumero = "123";
    let numeroConvertito = Number(stringaNumero); // 123
    
    // Arrotondamento
    let piGreco = Math.PI;
    console.log(piGreco.toFixed(2)); // "3.14"
                                </code></pre></div></li><li>Alternative:<ul><li>BigInt: Per rappresentare numeri interi di dimensioni arbitrarie</li><li>String: Per rappresentare numeri come testo, utile in alcuni casi di formattazione</li></ul></li><li>Potenziali errori comuni:<ul><li>Assumere che tutti i calcoli decimali siano precisi (es. 0.1 + 0.2 !== 0.3)</li><li>Non gestire correttamente i casi di divisione per zero</li><li>Confondere NaN con altri valori (NaN !== NaN)</li><li>Trascurare la conversione di input stringhe in numeri prima dei calcoli</li></ul></li><li>Impatto sulle performance:<ul><li>Le operazioni con numeri sono generalmente veloci in JavaScript</li><li>L'uso di numeri interi può essere leggermente più efficiente in alcuni casi</li><li>Operazioni complesse o con numeri molto grandi possono influire sulle prestazioni</li></ul></li><li>Conclusioni: Il tipo "number" in JavaScript è versatile e potente, permettendo di lavorare con una vasta gamma di valori numerici. Tuttavia, è importante comprenderne i limiti, specialmente in termini di precisione per i calcoli con numeri decimali. Una solida comprensione di come JavaScript gestisce i numeri è fondamentale per scrivere codice robusto e affidabile, specialmente in applicazioni che richiedono calcoli precisi o manipolazioni numeriche complesse. L'uso appropriato del tipo "number", insieme alla consapevolezza delle sue peculiarità, è essenziale per evitare errori sottili e garantire la correttezza dei calcoli nelle applicazioni JavaScript.</li></ol></details><details><summary>String<span class="tag-description" aria-label="descrizione tag">Rappresenta una sequenza di caratteri testuali, immutabile, utilizzata per gestire testi.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `String` in JavaScript rappresenta una sequenza di caratteri testuali. È un tipo primitivo immutabile, il che significa che una volta creata una stringa, il suo contenuto non può essere modificato, anche se è possibile creare nuove stringhe basate su modifiche a quella originale.</li><li>A cosa serve: Le stringhe vengono utilizzate per rappresentare e manipolare testo. Possono contenere lettere, numeri, simboli e persino emoji. Sono comunemente usate per visualizzare informazioni all'utente, gestire input di testo, concatenare o suddividere parole e interagire con i dati textuali provenienti da altre fonti.</li><li>Quando usarlo: Si utilizza il tipo `String` ogni volta che è necessario lavorare con dati testuali, come nomi, descrizioni, frasi o parole. È utile per la gestione di qualsiasi tipo di contenuto basato su testo in applicazioni web, come messaggi di errore, etichette o informazioni testuali visualizzate.</li><li>Rilevanza semantica: Il tipo `String` rappresenta i dati testuali in JavaScript, permettendo agli sviluppatori di manipolare il testo in modo efficiente. Le stringhe sono un tipo di dato molto comune e vengono utilizzate in molti contesti, come nelle interfacce utente e nella comunicazione tra client e server.</li><li>Principali caratteristiche:<ul><li>Le stringhe sono immutabili, il che significa che non possono essere modificate direttamente</li><li>Possono essere create usando apici singoli (<code>' '</code>), doppi (<code>" "</code>) o template literals (<code>` `</code>), che supportano interpolazione e multi-linea</li><li>Supportano molti metodi integrati per manipolare testo, come <code>charAt()</code>, <code>concat()</code>, <code>split()</code>, <code>slice()</code> e <code>replace()</code></li><li>La lunghezza di una stringa può essere ottenuta usando la proprietà <code>length</code></li><li>Le stringhe possono essere iterate e manipolate carattere per carattere</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Preferire l'uso di template literals (<code>` `</code>) per concatenare stringhe e includere espressioni JavaScript direttamente</li><li>Evitare di creare nuove stringhe con concatenazioni multiple all'interno di cicli per migliorare le performance</li><li>Utilizzare metodi di manipolazione come <code>slice()</code>, <code>substring()</code> e <code>split()</code> per suddividere e modificare stringhe</li><li>Quando si devono trattare stringhe molto lunghe o complesse, considerare l'uso di buffer o librerie esterne per migliorare le performance</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di una stringa
    let messaggio = "Ciao, come stai?";
    
    // Ottenere la lunghezza della stringa
    console.log(messaggio.length); // 16
    
    // Accesso a un singolo carattere
    console.log(messaggio.charAt(0)); // 'C'
    
    // Concatenare due stringhe
    let nome = "Mario";
    let saluto = "Ciao " + nome;
    console.log(saluto); // 'Ciao Mario'
    
    // Usare template literals per concatenazione
    let età = 30;
    console.log(`Mario ha ${età} anni`); // 'Mario ha 30 anni'
    
    // Suddividere una stringa
    let parole = messaggio.split(' ');
    console.log(parole); // ['Ciao,', 'come', 'stai?']
    
    // Sostituire parte di una stringa
    let nuovoMessaggio = messaggio.replace('Ciao', 'Salve');
    console.log(nuovoMessaggio); // 'Salve, come stai?'
    
    // Estrarre una porzione di stringa
    let parte = messaggio.slice(6, 10);
    console.log(parte); // 'come'
                                </code></pre></div></li><li>Alternative:<ul><li>Stringhe in formato array: Utilizzare array di caratteri quando è necessaria una manipolazione pesante del testo a livello di carattere singolo</li><li>Buffer di stringhe o <code>StringBuilder</code> (non disponibile nativamente in JavaScript) per manipolazioni stringa più efficienti su grandi quantità di testo</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'indice dei caratteri (basato su 0) con la lunghezza (basato su 1), ad esempio cercando di accedere a un carattere all'indice <code>length</code>, che è fuori portata</li><li>Tentare di modificare una stringa esistente direttamente, ignorando che le stringhe sono immutabili</li><li>Non considerare i problemi di encoding (come UTF-8) in contesti dove sono richiesti caratteri internazionali o speciali</li></ul></li><li>Impatto sulle performance:<ul><li>Le stringhe sono generalmente efficienti per la maggior parte delle operazioni, ma concatenare grandi stringhe in un ciclo può degradare le performance</li><li>Per manipolazioni estese su grandi quantità di testo, è preferibile utilizzare strutture come array o buffer temporanei per migliorare le performance</li></ul></li><li>Conclusioni: Le stringhe sono uno dei tipi di dati più fondamentali in JavaScript e vengono utilizzate ovunque per rappresentare dati testuali. Con una varietà di metodi integrati per manipolarle e gestirle, il tipo `String` è potente e flessibile. Tuttavia, è importante ricordare la loro immutabilità e gestire le performance quando si eseguono manipolazioni complesse su testi lunghi.</li></ol></details><details><summary>boolean<span class="tag-description" aria-label="descrizione tag">Tipo di dato booleano, con due valori possibili: vero o falso.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Un tipo di dato boolean in JavaScript rappresenta un valore logico che può essere solo "true" (vero) o "false" (falso).</li><li>A cosa serve: Viene utilizzato per rappresentare valori binari (vero o falso), tipicamente in operazioni logiche, condizionali, cicli, e altre strutture di controllo.</li><li>Quando usarlo: Il tipo di dato boolean è usato ogni volta che è necessario verificare una condizione, come nei controlli condizionali (if, else, while, ecc.), o per rappresentare lo stato binario di una variabile (ad esempio, un interruttore on/off).</li><li>Rilevanza semantica: Il tipo boolean serve a esprimere decisioni o stati binari all'interno del codice, facilitando la gestione delle condizioni logiche.</li><li>Principali caratteristiche:<ul><li>Può assumere solo due valori: true o false</li><li>Valori non booleani possono essere convertiti implicitamente in un boolean (es. 0 è false, una stringa non vuota è true)</li><li>È comunemente usato nelle condizioni logiche e nei confronti</li><li>Viene valutato in base alla "veridicità" (truthy) o "falsità" (falsy) di espressioni in JavaScript</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizza il tipo booleano per esprimere condizioni logiche chiare e leggibili</li><li>Evita conversioni implicite di valori non booleani; utilizza conversioni esplicite dove necessario (es. Boolean(val))</li><li>Verifica sempre la "veridicità" di un'espressione quando la utilizzi in un contesto booleano</li><li>Utilizza nomi di variabili che descrivano chiaramente il loro stato booleano, come isVisible, hasAccess, isValid</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di un valore booleano
    let isOnline = true;
    console.log(isOnline); // Output: true
    
    // Uso in una condizione
    if (isOnline) {
        console.log("L'utente è online");
    } else {
        console.log("L'utente è offline");
    }
    
    // Conversione di un valore in booleano
    let num = 0;
    let isValid = Boolean(num); // Conversione di 0 in false
    console.log(isValid); // Output: false
    
    // Verifica di "veridicità" di un valore
    let name = "Mario";
    if (name) {
        console.log("Il nome esiste"); // Questo blocco verrà eseguito, 
        poiché una stringa non vuota è "truthy"
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Tipi numerici o stringhe possono essere convertiti in valori booleani, ma non sono alternative dirette</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere valori "truthy" e "falsy" con veri booleani (true o false)</li><li>Non gestire correttamente la conversione implicita di valori non booleani, che può portare a comportamenti inaspettati</li><li>Dimenticare che alcuni valori apparentemente "vuoti" come 0, "", null, e undefined sono valutati come false</li></ul></li><li>Impatto sulle performance:<ul><li>Il tipo booleano è molto efficiente dal punto di vista delle performance, essendo un tipo di dato primitivo e semplice</li><li>In scenari complessi, conversioni implicite ripetute di tipi non booleani in booleani potrebbero influire lievemente sulle prestazioni</li></ul></li><li>Conclusioni: Il tipo di dato boolean è fondamentale in JavaScript per gestire condizioni logiche e operazioni binarie. Utilizzarlo correttamente garantisce un codice più chiaro e robusto, soprattutto in contesti che richiedono la valutazione di condizioni o lo stato di variabili. È importante comprendere anche i concetti di "truthy" e "falsy" per evitare errori logici.</li></ol></details><details><summary>object<span class="tag-description" aria-label="descrizione tag">Tipo di dato complesso che rappresenta collezioni di proprietà.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: In JavaScript, un "object" è un tipo di dato complesso che consente di memorizzare collezioni di proprietà e valori. Ogni proprietà è composta da una coppia chiave-valore.</li><li>A cosa serve: Gli oggetti sono usati per rappresentare strutture complesse di dati, come modelli di entità, record di database, o configurazioni. Permettono di organizzare i dati in modo strutturato.</li><li>Quando usarlo: Gli oggetti sono utilizzati quando si desidera rappresentare collezioni di proprietà correlate o modelli di dati complessi. Sono ideali per raggruppare dati e comportamenti (metodi) in un'unica struttura.</li><li>Rilevanza semantica: Un oggetto è uno dei fondamenti della programmazione a oggetti (OOP) in JavaScript, permettendo di creare entità che possono avere proprietà (dati) e metodi (funzionalità).</li><li>Principali caratteristiche:<ul><li>È una collezione di proprietà dove ogni proprietà è definita da una chiave (stringa o simbolo) e un valore (che può essere di qualsiasi tipo)</li><li>Gli oggetti possono contenere proprietà di tipo funzione, chiamate metodi</li><li>Le proprietà possono essere aggiunte, modificate o eliminate dinamicamente</li><li>È possibile accedere alle proprietà tramite la notazione dot (.) o tramite notazione a parentesi quadre ([])</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa oggetti per rappresentare entità complesse e strutturare i dati in modo chiaro e leggibile</li><li>Definisci metodi all'interno degli oggetti per aggiungere comportamento ai tuoi dati</li><li>Utilizza nomi di proprietà descrittivi e coerenti per migliorare la leggibilità del codice</li><li>Quando possibile, preferisci la notazione dot (.) per accedere alle proprietà</li><li>Evita di modificare oggetti in modo imprevisto; mantieni la loro struttura prevedibile</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di un oggetto
    let persona = {
        nome: "Mario",
        età: 30,
        saluta: function() {
            console.log("Ciao, mi chiamo " + this.nome);
        }
    };
    
    // Accesso a proprietà e metodi
    console.log(persona.nome); // Output: Mario
    persona.saluta(); // Output: Ciao, mi chiamo Mario
    
    // Aggiunta di una nuova proprietà
    persona.occupazione = "Sviluppatore";
    console.log(persona.occupazione); // Output: Sviluppatore
    
    // Modifica di una proprietà
    persona.età = 31;
    console.log(persona.età); // Output: 31
                                </code></pre></div></li><li>Alternative:<ul><li>Le mappe (Map) possono essere usate per collezioni chiave-valore più flessibili rispetto agli oggetti, specialmente quando le chiavi non devono essere stringhe</li></ul></li><li>Potenziali errori comuni:<ul><li>Accedere a proprietà non definite, che restituirà undefined</li><li>Confondere la notazione dot (.) con la notazione a parentesi quadre ([]) per l'accesso alle proprietà</li><li>Modificare accidentalmente proprietà protette o metodi nativi degli oggetti JavaScript</li><li>Non gestire correttamente il valore di "this" all'interno dei metodi di un oggetto</li></ul></li><li>Impatto sulle performance:<ul><li>Gli oggetti sono efficienti per l'archiviazione di dati e permettono un accesso rapido alle proprietà</li><li>Modifiche frequenti alla struttura di un oggetto (come aggiungere o eliminare proprietà) possono influire leggermente sulle performance, soprattutto in applicazioni complesse</li></ul></li><li>Conclusioni: Gli oggetti sono uno degli elementi chiave di JavaScript, permettendo di gestire e organizzare i dati in modo strutturato. Grazie alla loro flessibilità, gli oggetti possono rappresentare entità complesse, con proprietà e metodi che riflettono sia i dati che i comportamenti. Un uso corretto degli oggetti è essenziale per scrivere codice JavaScript modulare, leggibile e manutenibile.</li></ol></details><details><summary>array<span class="tag-description" aria-label="descrizione tag">Tipo di dato complesso per memorizzare una collezione ordinata di elementi</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Un array in JavaScript è un tipo di dato complesso che permette di memorizzare una collezione ordinata di elementi, che possono essere di qualsiasi tipo (numeri, stringhe, oggetti, funzioni, ecc.).</li><li>A cosa serve: Gli array vengono utilizzati per gestire liste di elementi o dati correlati, come elenchi di nomi, numeri o oggetti, facilitando l'accesso e la manipolazione di questi dati tramite i loro indici.</li><li>Quando usarlo: Gli array sono usati quando è necessario lavorare con un insieme di dati ordinati o una sequenza di elementi, dove ciascun elemento può essere identificato tramite un indice numerico.</li><li>Rilevanza semantica: Un array rappresenta una struttura dati fondamentale in JavaScript, utile per la gestione di insiemi di dati in sequenza e per iterare su collezioni.</li><li>Principali caratteristiche:<ul><li>Gli elementi di un array sono ordinati e accessibili tramite un indice numerico, a partire da 0</li><li>La dimensione di un array è dinamica: elementi possono essere aggiunti o rimossi in qualsiasi momento</li><li>Gli array possono contenere elementi di tipi diversi</li><li>Supporta metodi utili per manipolare i dati, come push, pop, shift, unshift, map, filter e reduce</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa array quando hai bisogno di una struttura dati ordinata e dinamica</li><li>Utilizza metodi nativi degli array per semplificare la manipolazione degli elementi</li><li>Evita di utilizzare array associativi; per questo scopo, utilizza gli oggetti</li><li>Utilizza cicli o metodi come forEach, map, e filter per iterare sugli elementi di un array</li><li>Evita di accedere a indici fuori dalla lunghezza dell'array, poiché restituiscono undefined</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di un array
    let colori = ["rosso", "verde", "blu"];
    
    // Accesso a un elemento tramite indice
    console.log(colori[0]); // Output: rosso
    
    // Aggiunta di un elemento alla fine
    colori.push("giallo");
    console.log(colori); // Output: ["rosso", "verde", "blu", "giallo"]
    
    // Rimozione dell'ultimo elemento
    colori.pop();
    console.log(colori); // Output: ["rosso", "verde", "blu"]
    
    // Iterazione su un array con forEach
    colori.forEach(function(colore) {
        console.log(colore);
    });
    // Output:
    // rosso
    // verde
    // blu
                                </code></pre></div></li><li>Alternative:<ul><li>Le mappe (Map) e gli insiemi (Set) possono essere utilizzati per collezioni chiave-valore o insiemi unici di elementi, ma non sono direttamente alternative agli array</li></ul></li><li>Potenziali errori comuni:<ul><li>Accedere a un elemento fuori dai limiti dell'array, che restituisce undefined</li><li>Confondere array associativi con oggetti; gli array devono essere utilizzati per sequenze ordinate di dati, non per associazioni chiave-valore</li><li>Modificare direttamente la lunghezza di un array tramite l'attributo length, il che può eliminare elementi senza preavviso</li><li>Usare cicli for standard per iterare sugli array senza controllare la lunghezza, il che può portare a errori</li></ul></li><li>Impatto sulle performance:<ul><li>Gli array sono generalmente efficienti per l'accesso agli elementi tramite indice e per la manipolazione dinamica delle liste</li><li>Operazioni come aggiungere o rimuovere elementi all'inizio dell'array possono essere meno efficienti rispetto alla gestione di elementi alla fine</li><li>Metodi come map, filter e reduce possono essere più performanti rispetto a cicli manuali</li></ul></li><li>Conclusioni: Gli array sono una struttura dati versatile e potente in JavaScript, ideale per la gestione di liste e sequenze di dati. Sono supportati da numerosi metodi nativi che ne semplificano l'uso e permettono di scrivere codice più conciso e leggibile. La comprensione e il corretto utilizzo degli array sono fondamentali per scrivere codice JavaScript efficiente e manutenibile.</li></ol></details><details><summary>Function<span class="tag-description" aria-label="descrizione tag">Tipo di dato che rappresenta una funzione, ovvero un blocco di codice eseguibile che può essere richiamato.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: In JavaScript, il tipo di dato `function` rappresenta una funzione, ovvero un blocco di codice che può essere definito e successivamente richiamato per eseguire un'operazione specifica. Le funzioni sono oggetti di prima classe in JavaScript, il che significa che possono essere assegnate a variabili, passate come argomenti ad altre funzioni e restituite da funzioni.</li><li>A cosa serve: Le funzioni vengono utilizzate per organizzare il codice, rendendolo riutilizzabile e modulare. Possono eseguire una serie di operazioni, accettare parametri in ingresso e restituire valori in uscita. Servono anche a isolare la logica di un programma in unità che possono essere richiamate più volte.</li><li>Quando usarlo: Le funzioni si utilizzano quando si ha bisogno di eseguire un'operazione specifica o un gruppo di operazioni in modo ripetibile, o quando è necessario astrarre e modularizzare il codice. Le funzioni sono essenziali in quasi tutti i programmi JavaScript, per definire comportamenti e strutture logiche.</li><li>Rilevanza semantica: Il tipo `function` rappresenta una parte fondamentale del paradigma della programmazione in JavaScript. Le funzioni non solo eseguono codice, ma possono anche essere trattate come variabili o passate ad altre funzioni, permettendo la creazione di codice altamente dinamico e flessibile.</li><li>Principali caratteristiche:<ul><li>Una funzione è definita utilizzando la keyword `function`, le funzioni freccia (arrow functions `=>`) o tramite funzioni anonime</li><li>Le funzioni possono accettare **argomenti** e restituire un **valore** con la keyword `return`</li><li>Possono essere assegnate a variabili, passate come argomenti o restituite da altre funzioni</li><li>Possono essere dichiarate o espresse come funzioni anonime</li><li>Possono avere uno scope locale o globale, a seconda del contesto in cui sono dichiarate</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona uniformemente in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Dichiarare le funzioni prima del loro utilizzo nel codice per migliorare la leggibilità</li><li>Utilizzare nomi di funzioni descrittivi e significativi per rendere il codice più chiaro</li><li>Passare le funzioni come callback solo quando necessario, evitando di creare dipendenze eccessive</li><li>Utilizzare le **arrow functions** quando si ha bisogno di mantenere il contesto `this` del livello esterno</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Definizione di una funzione classica
    function somma(a, b) {
        return a + b;
    }
    console.log(somma(2, 3)); // 5
    
    // Funzione anonima assegnata a una variabile
    const moltiplica = function(x, y) {
        return x * y;
    };
    console.log(moltiplica(4, 5)); // 20
    
    // Arrow function
    const sottrai = (a, b) =&gt; a - b;
    console.log(sottrai(10, 6)); // 4
    
    // Passare una funzione come callback
    function saluta(callback) {
        callback();
    }
    saluta(() =&gt; console.log("Ciao!")); // "Ciao!"
                                </code></pre></div></li><li>Alternative:<ul><li>Funzioni anonime: Possono essere utilizzate per assegnare funzioni a variabili o passare funzioni come argomenti</li><li>Arrow functions: Sintassi più compatta per definire funzioni con un comportamento diverso di `this`</li></ul></li><li>Potenziali errori comuni:<ul><li>Non restituire un valore da una funzione quando previsto, causando `undefined`</li><li>Confondere `function` con `arrow function`, che hanno un comportamento diverso rispetto al contesto `this`</li><li>Non gestire correttamente gli argomenti opzionali o le funzioni con parametri variabili</li></ul></li><li>Impatto sulle performance:<ul><li>Le funzioni anonime o le callback annidate possono causare problemi di performance se usate in modo eccessivo</li><li>L'uso eccessivo di funzioni annidate può ridurre la leggibilità e aumentare la complessità del codice</li></ul></li><li>Conclusioni: Le funzioni sono un elemento fondamentale di JavaScript, consentendo di modularizzare il codice e creare comportamenti riutilizzabili. La loro flessibilità e potenza, soprattutto nella gestione del contesto, le rendono essenziali per la scrittura di codice efficace. Comprendere come dichiarare, utilizzare e passare le funzioni è cruciale per scrivere applicazioni JavaScript robuste e manutenibili.</li></ol></details><details><summary>undefined<span class="tag-description" aria-label="descrizione tag">Valore predefinito per variabili non inizializzate o assenti.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `undefined` è un tipo di dato primitivo in JavaScript, che rappresenta il valore di una variabile che è stata dichiarata ma non inizializzata o di una proprietà inesistente.</li><li>A cosa serve: Viene utilizzato per indicare l'assenza di un valore iniziale in una variabile o per segnalare che un oggetto o una proprietà non esiste. È comunemente usato per gestire stati indefiniti in condizioni logiche o controlli.</li><li>Quando usarlo: `undefined` viene automaticamente assegnato alle variabili dichiarate ma non inizializzate, oppure può essere restituito quando si tenta di accedere a proprietà non definite o valori non presenti. Non dovrebbe essere assegnato manualmente, poiché esistono modi migliori per rappresentare l'assenza di un valore, come `null`.</li><li>Rilevanza semantica: `undefined` è un valore predefinito che aiuta a identificare variabili o proprietà che non hanno ancora ricevuto un valore valido. È importante per il controllo dell'esistenza di variabili e valori nel codice.</li><li>Principali caratteristiche:<ul><li>Viene assegnato automaticamente alle variabili non inizializzate</li><li>Viene restituito quando una funzione non ha un'istruzione `return` esplicita</li><li>Viene restituito quando si tenta di accedere a proprietà o indici inesistenti di un oggetto o array</li><li>È un tipo primitivo, distinto da `null`, che rappresenta intenzionalmente l'assenza di un valore</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Evita di assegnare manualmente `undefined` a variabili; utilizza invece `null` per indicare intenzionalmente l'assenza di valore</li><li>Verifica sempre l'eventuale presenza di `undefined` quando lavori con oggetti, proprietà e parametri di funzione</li><li>Utilizza controlli robusti come `typeof` per verificare l'esistenza di variabili non definite</li><li>Non confondere `undefined` con `null`: il primo indica l'assenza di un'inizializzazione, il secondo è utilizzato per segnalare intenzionalmente un'assenza di valore</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di variabile senza inizializzazione
    let x;
    console.log(x); // Output: undefined
    
    // Proprietà inesistente di un oggetto
    let persona = { nome: "Mario" };
    console.log(persona.età); // Output: undefined
    
    // Funzione senza return esplicito
    function saluta() {
        let messaggio = "Ciao!";
    }
    console.log(saluta()); // Output: undefined
    
    // Controllo di undefined
    if (typeof x === "undefined") {
        console.log("La variabile x è undefined");
    }
                                </code></pre></div></li><li>Alternative:<ul><li>`null`: Un valore esplicito che indica l'assenza intenzionale di valore</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `undefined` con `null`, che hanno significati e utilizzi diversi</li><li>Accedere a variabili o proprietà che restituiscono `undefined` senza verificarne l'esistenza</li><li>Non gestire correttamente valori `undefined` in condizioni logiche, il che può portare a comportamenti inattesi</li></ul></li><li>Impatto sulle performance:<ul><li>Il controllo di valori `undefined` è comune e non ha impatti significativi sulle performance</li><li>Gestire correttamente `undefined` può migliorare la robustezza del codice, riducendo la probabilità di errori logici o eccezioni</li></ul></li><li>Conclusioni: `undefined` è un valore predefinito e un concetto chiave in JavaScript per indicare l'assenza di valore o l'inizializzazione di una variabile. Comprendere e gestire correttamente `undefined` è essenziale per evitare errori logici nel codice, specialmente quando si lavora con variabili, oggetti e funzioni. Utilizzalo con cautela e distinguilo chiaramente da `null`, che rappresenta una diversa semantica.</li></ol></details><details><summary>null<span class="tag-description" aria-label="descrizione tag">Valore intenzionale che rappresenta l'assenza di un oggetto o di un valore.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `null` è un tipo di dato primitivo in JavaScript che rappresenta intenzionalmente l'assenza di un valore o di un oggetto.</li><li>A cosa serve: Viene utilizzato per indicare esplicitamente che una variabile o proprietà non ha alcun valore assegnato o che un oggetto è vuoto. A differenza di `undefined`, che è il valore predefinito di una variabile non inizializzata, `null` viene assegnato intenzionalmente.</li><li>Quando usarlo: Usa `null` quando vuoi indicare esplicitamente che un oggetto o un valore è assente, ad esempio quando cancelli un riferimento a un oggetto o quando un valore non è disponibile.</li><li>Rilevanza semantica: `null` è usato per esprimere in modo esplicito l'assenza intenzionale di un valore, il che lo rende diverso da `undefined`, che viene assegnato automaticamente quando una variabile non è stata inizializzata.</li><li>Principali caratteristiche:<ul><li>È un valore primitivo che rappresenta l'assenza intenzionale di valore</li><li>È diverso da `undefined`, che rappresenta l'assenza di inizializzazione</li><li>Può essere utilizzato per "svuotare" una variabile o un riferimento a un oggetto</li><li>Il tipo di `null` è considerato erroneamente "object" a causa di una peculiarità storica in JavaScript</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `null` per segnalare intenzionalmente che una variabile non ha valore o che un oggetto non esiste più</li><li>Preferisci `null` rispetto a `undefined` quando l'assenza di valore è esplicita e prevista</li><li>Verifica sempre l'eventuale presenza di `null` nelle tue condizioni, soprattutto quando lavori con oggetti e dati provenienti da fonti esterne</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di una variabile null
    let oggetto = null;
    console.log(oggetto); // Output: null
    
    // Usare null per "svuotare" un oggetto
    let utente = { nome: "Mario" };
    utente = null; // Il riferimento all'oggetto è rimosso
    console.log(utente); // Output: null
    
    // Controllo di null in una condizione
    if (utente === null) {
        console.log("L'utente non esiste più");
    }
    
    // Differenza tra null e undefined
    let variabile;
    console.log(variabile); // Output: undefined
    variabile = null;
    console.log(variabile); // Output: null
                                </code></pre></div></li><li>Alternative:<ul><li>`undefined`: Utilizzato quando una variabile non è stata ancora inizializzata o una proprietà non esiste</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `null` con `undefined`; il primo indica l'assenza intenzionale di valore, il secondo l'assenza di inizializzazione</li><li>Non verificare la presenza di `null` nelle condizioni logiche, causando errori quando si tenta di accedere a proprietà di un oggetto nullo</li><li>Assumere che `null` sia di tipo "null"; in realtà, il tipo di `null` è "object" a causa di una vecchia decisione di progettazione</li></ul></li><li>Impatto sulle performance:<ul><li>L'utilizzo di `null` non ha un impatto significativo sulle performance; è un tipo di dato primitivo e leggero</li><li>Usare `null` per "liberare" riferimenti agli oggetti può migliorare la gestione della memoria, specialmente in contesti complessi</li></ul></li><li>Conclusioni: `null` è un concetto fondamentale in JavaScript per rappresentare l'assenza intenzionale di un valore o di un oggetto. A differenza di `undefined`, che viene assegnato automaticamente, `null` viene utilizzato quando si desidera esplicitamente indicare che un valore è mancante. Comprendere la differenza tra `null` e `undefined` è cruciale per scrivere codice robusto e gestire correttamente le variabili e gli oggetti nel proprio programma.</li></ol></details><details><summary>symbol<span class="tag-description" aria-label="descrizione tag">Tipo di dato primitivo utilizzato per identificatori unici.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `symbol` è un tipo di dato primitivo introdotto in ECMAScript 6 (ES6), che rappresenta un identificatore unico. Ogni valore di tipo `symbol` è unico e immutabile.</li><li>A cosa serve: I `symbol` vengono utilizzati principalmente come chiavi uniche per le proprietà di un oggetto, evitando conflitti con altre proprietà o chiavi, soprattutto quando si lavora con codice di terze parti o librerie.</li><li>Quando usarlo: Usa i `symbol` quando hai bisogno di identificatori unici per le proprietà di un oggetto o quando vuoi evitare collisioni tra le chiavi degli oggetti. Sono utili soprattutto nei contesti in cui lavorano più sviluppatori o librerie, poiché i `symbol` garantiscono unicità.</li><li>Rilevanza semantica: `symbol` è utilizzato per identificatori unici che non possono essere accidentalmente sovrascritti o confliggere con altre proprietà. Questo lo rende utile per scopi come l'aggiunta di proprietà nascoste o metadati a oggetti.</li><li>Principali caratteristiche:<ul><li>Ogni `symbol` è unico e immutabile</li><li>I `symbol` possono essere utilizzati come chiavi di proprietà di oggetti</li><li>Non sono convertibili automaticamente in stringhe</li><li>Supportano la condivisione globale tramite il metodo `Symbol.for()`</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ECMAScript 6 (ES6) e supportato nelle versioni moderne di JavaScript</li><li>Compatibile con tutti i browser moderni</li><li>Non compatibile con browser legacy più vecchi senza pollyfills</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa i `symbol` per proprietà che devono essere uniche e non devono interferire con altre proprietà, come in librerie o framework</li><li>Utilizza `Symbol.for()` quando hai bisogno di un symbol condiviso e globale</li><li>Evita di convertire `symbol` in stringhe direttamente; usa metodi come `symbol.toString()` per visualizzare il valore</li><li>Usa i `symbol` quando desideri che alcune proprietà di un oggetto siano "nascoste" o difficili da accedere accidentalmente</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di un symbol unico
    let simboloUnico = Symbol("descrizione");
    console.log(simboloUnico); // Output: Symbol(descrizione)
    
    // Uso di un symbol come chiave di una proprietà
    let persona = {
        nome: "Mario",
        [simboloUnico]: "Valore nascosto"
    };
    console.log(persona[simboloUnico]); // Output: Valore nascosto
    
    // Confronto tra symbol
    let simbolo1 = Symbol("id");
    let simbolo2 = Symbol("id");
    console.log(simbolo1 === simbolo2); // Output: false (i simboli sono sempre unici)
    
    // Uso di Symbol.for() per symbol globali condivisi
    let simboloGlobale1 = Symbol.for("chiave");
    let simboloGlobale2 = Symbol.for("chiave");
    console.log(simboloGlobale1 === simboloGlobale2); // Output: true
                                </code></pre></div></li><li>Alternative:<ul><li>Stringhe o numeri possono essere utilizzati come chiavi per le proprietà di un oggetto, ma non offrono unicità come i `symbol`</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `symbol` con stringhe o altri tipi di dato primitivo. I `symbol` sono unici e non possono essere confrontati direttamente con stringhe</li><li>Tentare di accedere a proprietà definite con `symbol` usando la notazione a punto (`.`) invece di quella con parentesi quadre (`[]`)</li><li>Dimenticare di usare `Symbol.for()` quando si vuole ottenere lo stesso `symbol` globale, creando invece simboli locali unici</li></ul></li><li>Impatto sulle performance:<ul><li>La creazione di `symbol` è efficiente, ma l'uso di `symbol` come chiavi può rendere meno intuitive le operazioni sugli oggetti, soprattutto durante il debugging</li><li>Utilizzare `Symbol.for()` per symbol globali può ridurre il numero di duplicati, migliorando la gestione della memoria</li></ul></li><li>Conclusioni: `symbol` è un tipo di dato avanzato in JavaScript, utile per creare identificatori unici che possono essere utilizzati come chiavi di proprietà negli oggetti. La loro unicità e immutabilità li rendono ideali in contesti dove è importante evitare collisioni tra proprietà, specialmente in librerie o framework. Sono un potente strumento per mantenere il codice modulare e sicuro, ma vanno usati con attenzione.</li></ol></details><details><summary>BigInt<span class="tag-description" aria-label="descrizione tag">Tipo di dato per rappresentare numeri interi di grandi dimensioni.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `BigInt` è un tipo di dato primitivo introdotto in ECMAScript 2020 (ES11) che permette di rappresentare numeri interi più grandi di quelli che possono essere rappresentati con il tipo `Number`. I numeri `BigInt` possono essere arbitrariamente grandi.</li><li>A cosa serve: Viene utilizzato quando sono necessari numeri interi più grandi di 2<sup>53</sup>-1, il limite massimo per il tipo `Number` in JavaScript. `BigInt` permette di lavorare con numeri di grandi dimensioni, come in calcoli scientifici o crittografia.</li><li>Quando usarlo: Usa `BigInt` quando devi lavorare con numeri interi molto grandi o molto piccoli, oltre il limite di sicurezza dei `Number` (±2<sup>53</sup>-1). È utile in contesti dove precisione e dimensioni numeriche sono fondamentali, come nei sistemi finanziari, calcoli scientifici o gestione di ID molto grandi.</li><li>Rilevanza semantica: `BigInt` rappresenta un numero intero di grandi dimensioni, garantendo la precisione per numeri che superano il range gestito dal tipo `Number`. È un tipo di dato separato per assicurare precisione e sicurezza nei calcoli.</li><li>Principali caratteristiche:<ul><li>I valori `BigInt` possono rappresentare numeri interi positivi o negativi di dimensioni arbitrariamente grandi</li><li>Si crea un `BigInt` aggiungendo una "n" alla fine di un numero intero (es. `123n`)</li><li>Le operazioni aritmetiche tra `BigInt` e `Number` non sono permesse senza conversione esplicita</li><li>Supporta le operazioni aritmetiche standard come somma, sottrazione, moltiplicazione, divisione e resto</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ECMAScript 2020 (ES11)</li><li>Supportato nei browser moderni, ma potrebbe non essere compatibile con browser legacy senza pollyfills</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `BigInt` solo quando è necessario lavorare con numeri interi molto grandi o molto piccoli, poiché ha costi di performance superiori rispetto a `Number`</li><li>Evita operazioni tra `BigInt` e `Number` senza conversione esplicita, poiché generano errori</li><li>Utilizza `BigInt` per rappresentare grandi valori che richiedono precisione assoluta, come ID o numeri in crittografia</li><li>Ricorda che non puoi usare `BigInt` con alcuni metodi che richiedono numeri a virgola mobile (es. `Math.sqrt`)</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Dichiarazione di un BigInt
    let grandeNumero = 123456789012345678901234567890n;
    console.log(grandeNumero); // Output: 123456789012345678901234567890n
    
    // Operazioni aritmetiche con BigInt
    let somma = grandeNumero + 100000000000000000000000000000n;
    console.log(somma); // Output: 223456789012345678901234567890n
    
    // Confronto tra BigInt e Number
    let piccoloNumero = 10;
    let grandeNumero2 = 10n;
    console.log(piccoloNumero === grandeNumero2); // Output: false (Number e BigInt non sono comparabili)
    
    // Conversione esplicita
    console.log(BigInt(piccoloNumero) === grandeNumero2); // Output: true
    
    // Errore nelle operazioni tra Number e BigInt
    // console.log(grandeNumero + piccoloNumero); // Errore: Cannot mix BigInt and other types
                                </code></pre></div></li><li>Alternative:<ul><li>`Number`: Utilizza il tipo `Number` quando i valori interi rientrano nel range ±2<sup>53</sup>-1</li></ul></li><li>Potenziali errori comuni:<ul><li>Tentare di combinare operazioni aritmetiche tra `BigInt` e `Number` senza conversione esplicita, che genera un errore</li><li>Usare `BigInt` con funzioni di `Math` come `Math.sqrt`, che non supportano `BigInt`</li><li>Dimenticare di aggiungere la "n" alla fine di un numero quando si dichiara un `BigInt`</li></ul></li><li>Impatto sulle performance:<ul><li>Le operazioni con `BigInt` possono essere leggermente più lente rispetto a `Number`, poiché gestiscono numeri più grandi e richiedono più memoria</li><li>Utilizzare `BigInt` quando strettamente necessario per garantire precisione in calcoli numerici di grande dimensione</li></ul></li><li>Conclusioni: `BigInt` è un tipo di dato fondamentale per rappresentare numeri interi di grandi dimensioni in JavaScript, superando i limiti del tipo `Number`. È essenziale in contesti come la crittografia, l'analisi scientifica e le applicazioni finanziarie dove la precisione numerica è critica. Tuttavia, va utilizzato con attenzione, specialmente per evitare errori nelle operazioni tra `BigInt` e `Number`.</li></ol></details><details><summary>Map<span class="tag-description" aria-label="descrizione tag">Struttura dati che memorizza coppie chiave-valore, dove le chiavi possono essere di qualsiasi tipo.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `Map` in JavaScript è una struttura dati che memorizza coppie chiave-valore. A differenza degli oggetti, le chiavi in una `Map` possono essere di **qualsiasi tipo**, incluse funzioni, oggetti e valori primitivi. Le `Map` mantengono l'ordine di inserimento delle chiavi, e permettono un'iterazione più flessibile rispetto agli oggetti.</li><li>A cosa serve: Le `Map` vengono utilizzate per memorizzare dati associati a chiavi in modo più potente rispetto agli oggetti. Sono particolarmente utili quando si ha bisogno di chiavi che non sono solo stringhe o simboli, oppure quando si ha bisogno di mantenere l'ordine di inserimento delle chiavi per un'iterazione prevedibile.</li><li>Quando usarlo: Si utilizza una `Map` quando è necessario gestire una collezione di dati con chiavi che possono essere di qualsiasi tipo, oppure quando si vuole mantenere l'ordine di inserimento delle chiavi. È particolarmente utile in contesti in cui è necessario eseguire operazioni come ricerca, aggiunta e rimozione di coppie chiave-valore in modo efficiente.</li><li>Rilevanza semantica: Il tipo `Map` rappresenta una collezione associativa flessibile in cui ogni elemento è associato a una chiave unica. Rispetto a un oggetto, offre una maggiore flessibilità nel tipo di chiavi e una gestione più efficiente per determinate operazioni.</li><li>Principali caratteristiche:<ul><li>Memorizza coppie chiave-valore, dove sia le chiavi che i valori possono essere di **qualsiasi tipo**</li><li>Mantiene l'ordine di inserimento delle chiavi, rendendo l'iterazione prevedibile</li><li>Permette di ottenere la dimensione della `Map` tramite la proprietà <code>size</code></li><li>Le chiavi possono essere oggetti, funzioni o valori primitivi (numeri, stringhe, ecc.)</li><li>Offre metodi come <code>set()</code>, <code>get()</code>, <code>delete()</code> e <code>has()</code> per gestire le coppie chiave-valore</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ECMAScript 2015+)</li><li>Funziona in tutti i browser moderni</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare `Map` quando è necessario avere chiavi di tipo diverso (es. oggetti, funzioni) o quando l'ordine di inserimento delle chiavi è importante</li><li>Preferire `Map` rispetto agli oggetti quando si gestiscono grandi quantità di dati, poiché le `Map` offrono migliori performance per operazioni di ricerca e rimozione</li><li>Usare il metodo <code>has()</code> per verificare la presenza di una chiave prima di accedere al suo valore, evitando errori</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di una nuova Map
    let mappa = new Map();
    
    // Aggiunta di coppie chiave-valore
    mappa.set('nome', 'Mario');
    mappa.set(1, 'Uno');
    mappa.set(true, 'Vero');
    
    // Ottenere il valore associato a una chiave
    console.log(mappa.get('nome')); // 'Mario'
    console.log(mappa.get(1)); // 'Uno'
    
    // Verifica se una chiave esiste nella Map
    console.log(mappa.has(true)); // true
    
    // Rimozione di una coppia chiave-valore
    mappa.delete(1);
    console.log(mappa.get(1)); // undefined
    
    // Iterazione su una Map
    for (let [chiave, valore] of mappa) {
        console.log(chiave, valore);
    }
    
    // Ottieni la dimensione della Map
    console.log(mappa.size); // 2 (due elementi restanti)
                                </code></pre></div></li><li>Alternative:<ul><li>Oggetti: Utilizzati per collezioni chiave-valore più semplici, ma con limitazioni sulle chiavi (solo stringhe o simboli)</li><li>WeakMap: Simile a `Map`, ma permette solo chiavi che siano oggetti e non previene la garbage collection di questi oggetti</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare che le chiavi in una `Map` sono confrontate con uguaglianza stretta (`===`), quindi una chiave `1` è diversa da una chiave `'1'`</li><li>Confondere una `Map` con un oggetto, non utilizzando i metodi specifici come <code>set()</code> e <code>get()</code></li><li>Utilizzare una chiave non esistente senza controllare prima con <code>has()</code>, portando a risultati inattesi</li></ul></li><li>Impatto sulle performance:<ul><li>Le `Map` offrono migliori performance rispetto agli oggetti per operazioni frequenti come l'aggiunta e la rimozione di coppie chiave-valore</li><li>Grazie all'uso della funzione di hashing, l'accesso e la ricerca sono generalmente più veloci rispetto agli oggetti</li></ul></li><li>Conclusioni: Le `Map` sono una struttura dati potente e flessibile in JavaScript, particolarmente utile quando si ha bisogno di chiavi che possono essere di tipi diversi e si desidera mantenere l'ordine di inserimento. Sono preferibili agli oggetti in contesti in cui si gestiscono grandi quantità di dati o chiavi non stringhe. Comprendere come funzionano le `Map` e i metodi che offrono è essenziale per sfruttarle al meglio.</li></ol></details><details><summary>Set<span class="tag-description" aria-label="descrizione tag">Struttura dati che memorizza valori unici, senza consentire duplicati.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `Set` in JavaScript è una struttura dati che consente di memorizzare **valori unici** di qualsiasi tipo, senza duplicati. A differenza di un array, un `Set` non permette che lo stesso valore venga inserito più volte, garantendo così l'unicità degli elementi.</li><li>A cosa serve: Un `Set` è utile quando è necessario memorizzare una collezione di valori unici, evitando duplicati. È ideale per gestire insiemi di dati, come elenchi di valori unici o per verificare l'appartenenza di un valore a un insieme in modo efficiente.</li><li>Quando usarlo: Si utilizza un `Set` quando è necessario mantenere una collezione di elementi senza duplicati, oppure quando si vogliono eliminare i duplicati da una struttura come un array. È particolarmente utile in situazioni in cui bisogna verificare rapidamente se un valore è presente in un insieme.</li><li>Rilevanza semantica: Il tipo `Set` rappresenta un insieme di valori unici, fornendo una semantica chiara per operazioni su insiemi, come l'aggiunta di elementi senza duplicati o la verifica della presenza di un valore nell'insieme.</li><li>Principali caratteristiche:<ul><li>Memorizza solo valori unici; se un valore esiste già nel `Set`, non viene aggiunto di nuovo</li><li>I valori possono essere di qualsiasi tipo: primitivi, oggetti, funzioni, ecc.</li><li>Mantiene l'ordine di inserimento degli elementi, il che lo rende prevedibile durante l'iterazione</li><li>Offre metodi come <code>add()</code>, <code>delete()</code>, <code>has()</code> e <code>clear()</code> per gestire gli elementi</li><li>Permette di ottenere la dimensione del `Set` tramite la proprietà <code>size</code></li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ECMAScript 2015+)</li><li>Funziona in tutti i browser moderni</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare un `Set` quando è necessario garantire che tutti gli elementi in una collezione siano unici</li><li>Preferire `Set` quando si eseguono operazioni frequenti di verifica di esistenza o di rimozione di duplicati</li><li>Usare il metodo <code>has()</code> per verificare la presenza di un elemento prima di eseguire operazioni su di esso</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
                    // Creazione di un nuovo Set
                    let insieme = new Set();
                    
                    // Aggiunta di valori
                    insieme.add(1);
                    insieme.add(5);
                    insieme.add('ciao');
                    
                    // Tentativo di aggiungere un duplicato
                    insieme.add(1); // Non verrà aggiunto poiché già presente
                    
                    // Verifica della presenza di un valore
                    console.log(insieme.has(5)); // true
                    console.log(insieme.has(10)); // false
                    
                    // Rimozione di un valore
                    insieme.delete(5);
                    console.log(insieme.has(5)); // false
                    
                    // Iterazione su un Set
                    for (let valore of insieme) {
                        console.log(valore); // 1, 'ciao'
                    }
                    
                    // Rimozione di tutti gli elementi
                    insieme.clear();
                    console.log(insieme.size); // 0
                                </code></pre></div></li><li>Alternative:<ul><li>Array: Può essere utilizzato per memorizzare collezioni, ma non garantisce l'unicità degli elementi</li><li>WeakSet: Simile a `Set`, ma permette solo oggetti come valori e non previene la garbage collection di questi oggetti</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare che i valori in un `Set` sono confrontati con uguaglianza stretta (`===`), quindi il valore `1` è diverso dalla stringa `'1'`</li><li>Utilizzare un `Set` quando l'ordine degli elementi non è importante, il che può portare a confusione durante l'iterazione</li><li>Confondere `Set` con altre strutture dati come `Map`, che memorizza coppie chiave-valore</li></ul></li><li>Impatto sulle performance:<ul><li>Le operazioni di aggiunta, eliminazione e verifica della presenza in un `Set` sono generalmente molto efficienti grazie all'uso di algoritmi di hashing</li><li>Il `Set` offre migliori performance rispetto a un array per operazioni di eliminazione e ricerca di duplicati</li></ul></li><li>Conclusioni: Il `Set` è una struttura dati potente e flessibile per gestire collezioni di valori unici in JavaScript. Offre ottime performance per la verifica di esistenza e per la gestione di insiemi senza duplicati. Rispetto a un array, garantisce l'unicità degli elementi, il che lo rende ideale per operazioni su insiemi di dati univoci. Comprendere i metodi e le caratteristiche del `Set` è fondamentale per sfruttare al meglio questa struttura in JavaScript.</li></ol></details><details><summary>Date<span class="tag-description" aria-label="descrizione tag">Tipo di dato utilizzato per lavorare con date e orari in JavaScript.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `Date` in JavaScript è un oggetto utilizzato per rappresentare e gestire **date e orari**. Fornisce una vasta gamma di metodi per ottenere, impostare e manipolare informazioni relative a data e ora, come l'anno, il mese, il giorno, l'ora, i minuti, i secondi e i millisecondi.</li><li>A cosa serve: L'oggetto `Date` viene utilizzato per creare, manipolare e formattare date e orari. È utile per calcolare differenze tra date, rappresentare eventi nel tempo, gestire timestamp e formattare date per la visualizzazione.</li><li>Quando usarlo: Si utilizza il tipo `Date` quando è necessario lavorare con informazioni legate a data e ora, come la gestione di calendari, pianificazioni di eventi, calcoli di intervalli temporali o per ottenere timestamp per tracciare eventi nel tempo.</li><li>Rilevanza semantica: L'oggetto `Date` rappresenta il concetto di tempo in JavaScript, e consente di operare su questo concetto attraverso una serie di metodi utili per ottenere, modificare e formattare dati temporali.</li><li>Principali caratteristiche:<ul><li>Può essere creato utilizzando la data corrente o specificando un momento temporale particolare</li><li>Supporta date a partire dal 1 gennaio 1970 (in formato timestamp Unix) e può gestire date sia nel passato che nel futuro</li><li>Offre metodi per ottenere e impostare varie parti della data, come <code>getFullYear()</code>, <code>getMonth()</code>, <code>getDate()</code>, <code>getHours()</code>, ecc.</li><li>Fornisce metodi per formattare una data, come <code>toISOString()</code>, <code>toLocaleDateString()</code>, ecc.</li><li>Permette di eseguire calcoli tra date per ottenere differenze in millisecondi</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare il formato `ISO 8601` (<code>toISOString()</code>) per garantire compatibilità internazionale e una gestione precisa delle date</li><li>Evitare di manipolare manualmente stringhe di date per evitare errori legati ai fusi orari; preferire i metodi forniti dall'oggetto `Date`</li><li>Utilizzare librerie come `Moment.js` o `date-fns` se si ha bisogno di manipolazioni complesse di date e orari</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione della data corrente
    let dataCorrente = new Date();
    console.log(dataCorrente); // Es: Wed Oct 22 2024 10:15:30 GMT+0200
    
    // Creazione di una data specifica
    let dataSpecifica = new Date('2023-10-10T10:00:00');
    console.log(dataSpecifica); // Es: Tue Oct 10 2023 10:00:00 GMT+0200
    
    // Ottenere parti della data
    let anno = dataCorrente.getFullYear(); // Anno corrente
    let mese = dataCorrente.getMonth(); // Mese (0-11)
    let giorno = dataCorrente.getDate(); // Giorno del mese (1-31)
    console.log(anno, mese, giorno); // Es: 2024 9 22
    
    // Formattazione della data
    console.log(dataCorrente.toISOString()); // 2024-10-22T08:15:30.000Z
    console.log(dataCorrente.toLocaleDateString('it-IT')); // 22/10/2024
    
    // Calcolare differenze tra date
    let dataInizio = new Date('2024-10-01');
    let diffMillisecondi = dataCorrente - dataInizio;
    let giorniDifferenza = diffMillisecondi / (1000 * 60 * 60 * 24); // Convertire in giorni
    console.log(giorniDifferenza); // Es: 21 giorni
                                </code></pre></div></li><li>Alternative:<ul><li>Librerie come `Moment.js`, `date-fns` o `Luxon` per operazioni più avanzate con le date</li><li>Utilizzo dei timestamp Unix (millisecondi dal 1 gennaio 1970) per un approccio più semplice al calcolo delle date</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere il mese (0-11) quando si utilizza il metodo <code>getMonth()</code>, poiché gennaio è rappresentato da 0 e dicembre da 11</li><li>Non considerare i fusi orari quando si manipolano le date, portando a errori nelle differenze temporali</li><li>Manipolare stringhe di date direttamente invece di utilizzare i metodi sicuri di `Date`</li></ul></li><li>Impatto sulle performance:<ul><li>La creazione e manipolazione di oggetti `Date` è generalmente efficiente, ma operazioni complesse su grandi insiemi di dati temporali possono beneficiare di ottimizzazioni o librerie esterne</li></ul></li><li>Conclusioni: Il tipo di dato `Date` è fondamentale per la gestione di date e orari in JavaScript. Sebbene possa coprire la maggior parte delle esigenze legate alle date, le sue limitazioni nei fusi orari e nella manipolazione complessa possono richiedere l'uso di librerie esterne. Tuttavia, per le operazioni di base, come ottenere la data corrente, formattare date o calcolare intervalli temporali, l'oggetto `Date` è uno strumento potente e versatile.</li></ol></details><details><summary>Set<span class="tag-description" aria-label="descrizione tag">Struttura dati che memorizza valori unici, senza consentire duplicati.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `Set` in JavaScript è una struttura dati che consente di memorizzare **valori unici** di qualsiasi tipo, senza duplicati. A differenza di un array, un `Set` non permette che lo stesso valore venga inserito più volte, garantendo così l'unicità degli elementi.</li><li>A cosa serve: Un `Set` è utile quando è necessario memorizzare una collezione di valori unici, evitando duplicati. È ideale per gestire insiemi di dati, come elenchi di valori unici o per verificare l'appartenenza di un valore a un insieme in modo efficiente.</li><li>Quando usarlo: Si utilizza un `Set` quando è necessario mantenere una collezione di elementi senza duplicati, oppure quando si vogliono eliminare i duplicati da una struttura come un array. È particolarmente utile in situazioni in cui bisogna verificare rapidamente se un valore è presente in un insieme.</li><li>Rilevanza semantica: Il tipo `Set` rappresenta un insieme di valori unici, fornendo una semantica chiara per operazioni su insiemi, come l'aggiunta di elementi senza duplicati o la verifica della presenza di un valore nell'insieme.</li><li>Principali caratteristiche:<ul><li>Memorizza solo valori unici; se un valore esiste già nel `Set`, non viene aggiunto di nuovo</li><li>I valori possono essere di qualsiasi tipo: primitivi, oggetti, funzioni, ecc.</li><li>Mantiene l'ordine di inserimento degli elementi, il che lo rende prevedibile durante l'iterazione</li><li>Offre metodi come <code>add()</code>, <code>delete()</code>, <code>has()</code> e <code>clear()</code> per gestire gli elementi</li><li>Permette di ottenere la dimensione del `Set` tramite la proprietà <code>size</code></li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ECMAScript 2015+)</li><li>Funziona in tutti i browser moderni</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare un `Set` quando è necessario garantire che tutti gli elementi in una collezione siano unici</li><li>Preferire `Set` quando si eseguono operazioni frequenti di verifica di esistenza o di rimozione di duplicati</li><li>Usare il metodo <code>has()</code> per verificare la presenza di un elemento prima di eseguire operazioni su di esso</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di un nuovo Set
    let insieme = new Set();
    
    // Aggiunta di valori
    insieme.add(1);
    insieme.add(5);
    insieme.add('ciao');
    
    // Tentativo di aggiungere un duplicato
    insieme.add(1); // Non verrà aggiunto poiché già presente
    
    // Verifica della presenza di un valore
    console.log(insieme.has(5)); // true
    console.log(insieme.has(10)); // false
    
    // Rimozione di un valore
    insieme.delete(5);
    console.log(insieme.has(5)); // false
    
    // Iterazione su un Set
    for (let valore of insieme) {
        console.log(valore); // 1, 'ciao'
    }
    
    // Rimozione di tutti gli elementi
    insieme.clear();
    console.log(insieme.size); // 0
                                    </code></pre></div></li><li>Alternative:<ul><li>Array: Può essere utilizzato per memorizzare collezioni, ma non garantisce l'unicità degli elementi</li><li>WeakSet: Simile a `Set`, ma permette solo oggetti come valori e non previene la garbage collection di questi oggetti</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare che i valori in un `Set` sono confrontati con uguaglianza stretta (`===`), quindi il valore `1` è diverso dalla stringa `'1'`</li><li>Utilizzare un `Set` quando l'ordine degli elementi non è importante, il che può portare a confusione durante l'iterazione</li><li>Confondere `Set` con altre strutture dati come `Map`, che memorizza coppie chiave-valore</li></ul></li><li>Impatto sulle performance:<ul><li>Le operazioni di aggiunta, eliminazione e verifica della presenza in un `Set` sono generalmente molto efficienti grazie all'uso di algoritmi di hashing</li><li>Il `Set` offre migliori performance rispetto a un array per operazioni di eliminazione e ricerca di duplicati</li></ul></li><li>Conclusioni: Il `Set` è una struttura dati potente e flessibile per gestire collezioni di valori unici in JavaScript. Offre ottime performance per la verifica di esistenza e per la gestione di insiemi senza duplicati. Rispetto a un array, garantisce l'unicità degli elementi, il che lo rende ideale per operazioni su insiemi di dati univoci. Comprendere i metodi e le caratteristiche del `Set` è fondamentale per sfruttare al meglio questa struttura in JavaScript.</li></ol></details><details><summary>RegExp<span class="tag-description" aria-label="descrizione tag">Rappresenta un'espressione regolare, utilizzata per la ricerca e manipolazione di pattern testuali.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: Il tipo di dato `RegExp` in JavaScript rappresenta un'espressione regolare, una sequenza di caratteri che definisce un pattern di ricerca. Le espressioni regolari vengono utilizzate per eseguire operazioni di ricerca, corrispondenza e sostituzione su stringhe, in base a criteri specifici definiti dal pattern.</li><li>A cosa serve: Le espressioni regolari servono a cercare, validare e manipolare pattern all'interno di stringhe. Sono ideali per operazioni come la ricerca di parole specifiche, la validazione di formati (es. email, numeri di telefono), la sostituzione di caratteri o segmenti di testo, e la suddivisione di stringhe in base a delimitatori specifici.</li><li>Quando usarlo: Si utilizza il tipo `RegExp` quando è necessario identificare o operare su pattern testuali complessi, come cercare ripetizioni di caratteri, validare input dell'utente o sostituire segmenti di testo seguendo regole specifiche. Le espressioni regolari offrono un modo potente e flessibile per lavorare con testo.</li><li>Rilevanza semantica: Le `RegExp` rappresentano uno strumento potente per descrivere pattern di testo, consentendo la ricerca, la corrispondenza e la manipolazione di stringhe secondo regole personalizzate. Sono essenziali per molti casi d'uso che richiedono un'analisi del contenuto testuale.</li><li>Principali caratteristiche:<ul><li>Si creano utilizzando la sintassi dei literal (<code>/pattern/</code>) o il costruttore <code>new RegExp()</code></li><li>Supportano flag opzionali come:<ul><li><code>g</code> (global): per eseguire una ricerca globale su tutto il testo</li><li><code>i</code> (case-insensitive): per ignorare la distinzione tra maiuscole e minuscole</li><li><code>m</code> (multilinea): per gestire pattern su più righe</li></ul></li><li>Le `RegExp` possono essere utilizzate con i metodi delle stringhe come <code>match()</code>, <code>replace()</code>, <code>search()</code> e <code>split()</code></li><li>Consentono l'uso di metacaratteri e quantificatori per definire pattern avanzati, come <code>\d</code> per cifre, <code>\w</code> per caratteri alfanumerici e <code>*</code>, <code>+</code> per ripetizioni</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare i flag giusti (<code>g</code>, <code>i</code>, <code>m</code>) per ottenere il comportamento desiderato</li><li>Testare le espressioni regolari con strumenti online (es. regex101.com) per assicurarsi che funzionino come previsto</li><li>Evitare l'uso eccessivo di espressioni regolari complesse per non compromettere la leggibilità del codice</li><li>Utilizzare i metacaratteri con attenzione, specialmente quando si lavora con input dell'utente, per evitare exploit come il **ReDoS** (Regular Expression Denial of Service)</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di un'espressione regolare per cercare la parola "test"
    let regex = /test/;
    let testo = "Questo è un test di RegExp.";
    console.log(regex.test(testo)); // true
    
    // Esempio con flag "g" e "i"
    let regex2 = /test/i; // Ignora maiuscole/minuscole
    let regex3 = /test/g; // Ricerca globale
    let risultato = testo.match(regex3);
    console.log(risultato); // ['test']
    
    // Sostituire tutte le occorrenze di una parola con un'altra
    let frase = "La mela è rossa. La mela è dolce.";
    let nuovaFrase = frase.replace(/mela/g, "pera");
    console.log(nuovaFrase); // "La pera è rossa. La pera è dolce."
    
    // Validare un indirizzo email semplice
    let emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,6}$/;
    let email = "test@example.com";
    console.log(emailRegex.test(email)); // true
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzo dei metodi delle stringhe standard come <code>includes()</code>, <code>indexOf()</code> o <code>startsWith()</code> per operazioni più semplici su stringhe</li><li>Librerie come `XRegExp` che estendono le funzionalità delle espressioni regolari in JavaScript</li></ul></li><li>Potenziali errori comuni:<ul><li>Non utilizzare correttamente i metacaratteri e i quantificatori, portando a pattern errati o inefficaci</li><li>Non usare i flag giusti, come dimenticare il flag <code>g</code> per una ricerca globale</li><li>Scrivere espressioni regolari troppo complesse, compromettendo la leggibilità e la manutenibilità del codice</li><li>Non considerare i problemi di performance che possono derivare da pattern di espressioni regolari mal ottimizzati</li></ul></li><li>Impatto sulle performance:<ul><li>Le espressioni regolari possono essere molto efficienti per operazioni di ricerca e manipolazione di testo, ma espressioni regolari mal progettate possono avere un impatto negativo sulle performance</li><li>Pattern complessi o non ottimizzati possono portare a problemi di performance, in particolare con input di grandi dimensioni o in caso di vulnerabilità come il **ReDoS**</li></ul></li><li>Conclusioni: Le espressioni regolari (`RegExp`) sono uno strumento potente per la ricerca e la manipolazione di pattern testuali in JavaScript. Sebbene possano risultare complesse, sono estremamente utili per operazioni come la validazione di input, la ricerca di pattern specifici o la manipolazione di stringhe su larga scala. Tuttavia, è importante scrivere espressioni regolari chiare e ottimizzate, soprattutto in contesti di produzione, per evitare problemi di leggibilità e performance.</li></ol></details><details><summary>WeakMap<span class="tag-description" aria-label="descrizione tag">Struttura dati simile a `Map`, con alcune differenze.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `WeakMap` è una struttura dati in JavaScript che memorizza coppie chiave-valore, dove le chiavi devono essere oggetti e i riferimenti a tali chiavi sono deboli. Ciò significa che se non esistono più riferimenti all'oggetto chiave, esso può essere automaticamente rimosso dalla memoria attraverso la garbage collection, evitando memory leak.</li><li>A cosa serve: `WeakMap` viene utilizzato quando si vuole associare informazioni supplementari ad oggetti senza impedire che questi vengano rimossi dalla memoria quando non sono più utilizzati altrove. È utile per implementare pattern come la memorizzazione di dati privati sugli oggetti o il caching di risultati basato su oggetti senza compromettere la gestione della memoria.</li><li>Quando usarlo: Si utilizza `WeakMap` quando si vuole memorizzare dati legati ad oggetti senza influire sulla loro gestione di memoria. Ad esempio, è utile per mantenere dati temporanei o debolmente associati a oggetti che possono essere distrutti automaticamente quando non sono più utilizzati.</li><li>Rilevanza semantica: `WeakMap` fornisce una gestione della memoria più efficiente per le associazioni chiave-valore legate ad oggetti, poiché non impedisce la rimozione degli oggetti dalla memoria tramite garbage collection. A differenza di una `Map` tradizionale, in cui le chiavi mantengono forti riferimenti agli oggetti, `WeakMap` evita questo problema garantendo una gestione ottimizzata.</li><li>Principali caratteristiche:<ul><li>Memorizza coppie chiave-valore, dove le chiavi devono essere **oggetti**</li><li>I riferimenti alle chiavi sono deboli, il che permette agli oggetti chiave di essere rimossi dalla memoria quando non più utilizzati</li><li>Non è iterabile, quindi non è possibile ottenere tutte le chiavi o i valori contenuti in un `WeakMap`</li><li>Supporta metodi come <code>set()</code>, <code>get()</code>, <code>delete()</code> e <code>has()</code> per gestire le coppie chiave-valore</li><li>Non è possibile conoscere la dimensione di un `WeakMap`, poiché non esiste un metodo <code>size</code> come in una `Map` tradizionale</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ECMAScript 2015+)</li><li>Funziona in tutti i browser moderni</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usare `WeakMap` quando è necessario mantenere una relazione chiave-valore debole, legata alla vita degli oggetti</li><li>Evita di usare `WeakMap` per dati che devono essere recuperabili o iterabili, poiché non è possibile iterare sulle chiavi o valori in un `WeakMap`</li><li>Perfetto per dati privati o temporanei associati ad oggetti, poiché i dati possono essere automaticamente rimossi quando l'oggetto non è più necessario</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di un nuovo WeakMap
    let weakMap = new WeakMap();
    
    // Creazione di oggetti
    let obj1 = { nome: "Mario" };
    let obj2 = { nome: "Luigi" };
    
    // Aggiunta di coppie chiave-valore a WeakMap
    weakMap.set(obj1, "Informazioni private su Mario");
    weakMap.set(obj2, "Informazioni private su Luigi");
    
    // Recuperare il valore associato a un oggetto
    console.log(weakMap.get(obj1)); // "Informazioni private su Mario"
    
    // Verifica se una chiave esiste nel WeakMap
    console.log(weakMap.has(obj2)); // true
    
    // Rimozione di una coppia chiave-valore
    weakMap.delete(obj2);
    console.log(weakMap.has(obj2)); // false
    
    // Se obj1 non è più referenziato da nessuna parte nel codice, verrà rimosso automaticamente dalla memoria
                                </code></pre></div></li><li>Alternative:<ul><li><code>Map</code>: per memorizzare chiavi-valore con chiavi di qualsiasi tipo e garantire la persistenza delle chiavi finché non vengono esplicitamente rimosse</li><li><code>WeakSet</code>: simile a `WeakMap`, ma memorizza solo valori unici senza associazione chiave-valore, con chiavi deboli (solo oggetti)</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `WeakMap` con `Map`, aspettandosi di poter iterare sugli elementi o conoscere la dimensione del contenitore</li><li>Utilizzare valori primitivi (es. stringhe, numeri) come chiavi, che non sono supportati in un `WeakMap` (le chiavi devono essere oggetti)</li><li>Dimenticare che le chiavi non persistono se gli oggetti non sono più referenziati altrove, quindi i dati associati potrebbero sparire inaspettatamente</li></ul></li><li>Impatto sulle performance:<ul><li>Le `WeakMap` offrono un uso della memoria più efficiente grazie alla rimozione automatica delle chiavi non più referenziate</li><li>La gestione debole delle chiavi evita i memory leak in applicazioni che lavorano con molti oggetti temporanei</li></ul></li><li>Conclusioni: `WeakMap` è uno strumento potente per gestire associazioni chiave-valore in cui le chiavi sono oggetti che potrebbero essere eliminati dalla memoria quando non più referenziati. Questo la rende ideale per la gestione di dati privati o temporanei associati a oggetti, senza doversi preoccupare della gestione esplicita della memoria. Tuttavia, l'impossibilità di iterare o conoscere la dimensione del `WeakMap` lo rende inadatto a scenari in cui è necessario un controllo più ampio sulla collezione di dati.</li></ol></details><details><summary>WeakSet<span class="tag-description" aria-label="descrizione tag">Struttura dati simile a `Set`, che memorizza solo oggetti come valori e con riferimenti deboli.</span><div class="tag-group" aria-label="gruppo">2. Tipo di Dato</div></summary><ol><li>Cos'è: `WeakSet` è una struttura dati in JavaScript simile a `Set`, ma memorizza esclusivamente oggetti come valori e i riferimenti a tali oggetti sono deboli. Questo significa che se un oggetto memorizzato in un `WeakSet` non è referenziato da nessun'altra parte, può essere eliminato dalla memoria tramite la garbage collection, evitando memory leak.</li><li>A cosa serve: `WeakSet` viene utilizzato per memorizzare oggetti in modo che possano essere automaticamente rimossi dalla memoria quando non più utilizzati. È utile per gestire gruppi di oggetti che potrebbero essere eliminati dinamicamente senza la necessità di gestire manualmente la loro rimozione.</li><li>Quando usarlo: Si utilizza `WeakSet` quando si ha bisogno di un insieme di oggetti in cui la gestione della memoria è automatica. È utile per casi come il tracciamento di oggetti temporanei o la registrazione di oggetti che devono essere rimossi dalla memoria quando non più referenziati da nessun'altra parte.</li><li>Rilevanza semantica: Il `WeakSet` rappresenta un insieme di oggetti in cui ogni riferimento è debole, il che significa che non impedisce la garbage collection degli oggetti. A differenza di un `Set`, questo rende il `WeakSet` utile in situazioni in cui si vuole tracciare oggetti senza preoccuparsi di memory leak.</li><li>Principali caratteristiche:<ul><li>Memorizza solo **oggetti** come valori, non supporta tipi primitivi come numeri o stringhe</li><li>I riferimenti agli oggetti sono deboli, il che permette loro di essere rimossi automaticamente dalla memoria quando non sono più referenziati</li><li>Non supporta iterazione, quindi non è possibile ottenere o iterare direttamente sugli oggetti contenuti in un `WeakSet`</li><li>Supporta i metodi <code>add()</code>, <code>delete()</code> e <code>has()</code> per gestire i valori nel `WeakSet`</li><li>Non è possibile conoscere la dimensione di un `WeakSet`, poiché non esiste una proprietà <code>size</code></li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ECMAScript 2015+)</li><li>Funziona in tutti i browser moderni</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usare `WeakSet` quando si vuole mantenere un insieme di oggetti che devono essere automaticamente eliminati dalla memoria quando non più utilizzati</li><li>Evitare di usare `WeakSet` quando è necessario iterare sugli elementi o mantenere valori primitivi (come stringhe o numeri)</li><li>Perfetto per tracciare oggetti temporanei senza preoccuparsi della loro rimozione manuale dalla memoria</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Creazione di un nuovo WeakSet
    let weakSet = new WeakSet();
    
    // Creazione di oggetti
    let obj1 = { nome: "Mario" };
    let obj2 = { nome: "Luigi" };
    
    // Aggiunta di oggetti a WeakSet
    weakSet.add(obj1);
    weakSet.add(obj2);
    
    // Verifica se un oggetto è presente nel WeakSet
    console.log(weakSet.has(obj1)); // true
    
    // Rimozione di un oggetto dal WeakSet
    weakSet.delete(obj2);
    console.log(weakSet.has(obj2)); // false
    
    // Se obj1 non è più referenziato da nessuna parte, verrà rimosso automaticamente dalla memoria
                                </code></pre></div></li><li>Alternative:<ul><li><code>Set</code>: per memorizzare collezioni di valori, inclusi oggetti e tipi primitivi, che non vengono automaticamente rimossi dalla memoria</li><li><code>WeakMap</code>: simile a `WeakSet`, ma memorizza coppie chiave-valore dove le chiavi devono essere oggetti e i riferimenti sono deboli</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `WeakSet` con `Set`, aspettandosi di poter iterare sugli elementi o ottenere informazioni sulla loro dimensione</li><li>Usare valori primitivi come chiavi, che non sono supportati in un `WeakSet` (possono contenere solo oggetti)</li><li>Dimenticare che non è possibile iterare su un `WeakSet` e quindi non si può accedere direttamente agli oggetti memorizzati</li></ul></li><li>Impatto sulle performance:<ul><li>Grazie ai riferimenti deboli, `WeakSet` offre una gestione della memoria efficiente, in quanto gli oggetti non più referenziati vengono rimossi automaticamente</li><li>Ottimo per evitare memory leak, soprattutto quando si gestiscono molti oggetti temporanei che non devono essere trattenuti in memoria a lungo</li></ul></li><li>Conclusioni: `WeakSet` è una struttura dati ideale per gestire gruppi di oggetti senza preoccuparsi di memory leak, poiché gli oggetti vengono automaticamente eliminati quando non sono più necessari. Sebbene non offra funzioni di iterazione o di gestione delle dimensioni, è perfetto per casi in cui è sufficiente tracciare la presenza o l'assenza di oggetti in un insieme temporaneo. Tuttavia, per casi in cui è necessaria una gestione più complessa o iterabile degli elementi, potrebbe essere preferibile utilizzare un `Set` o un'altra struttura dati.</li></ol></details><details><summary>Addizione<span class="tag-description" aria-label="descrizione tag">Operatore che somma due operandi o concatena stringhe.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di addizione (`+`) in JavaScript è utilizzato per sommare due numeri o per concatenare due stringhe. Il comportamento dell'operatore varia in base ai tipi di dati coinvolti.</li><li>A cosa serve: Viene utilizzato per eseguire operazioni aritmetiche su numeri o per concatenare stringhe. Se almeno uno dei due operandi è una stringa, l'operatore `+` effettuerà la concatenazione.</li><li>Quando usarlo: Usa l'operatore di addizione per sommare numeri o per unire (concatenare) stringhe. È comunemente usato in espressioni aritmetiche e nella costruzione di messaggi o testi dinamici.</li><li>Rilevanza semantica: L'operatore di addizione è uno degli operatori più fondamentali in JavaScript e in tutti i linguaggi di programmazione, poiché esegue l'operazione basilare di somma. In JavaScript ha la particolarità di funzionare anche per la concatenazione di stringhe, offrendo versatilità.</li><li>Principali caratteristiche:<ul><li>Somma due numeri o concatena due stringhe</li><li>Se uno degli operandi è una stringa, effettua la concatenazione anziché la somma</li><li>È associativo da sinistra a destra: l'espressione viene valutata da sinistra a destra</li><li>Se uno degli operandi non è né un numero né una stringa, JavaScript tenta di convertirlo</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa l'operatore `+` per sommare numeri quando sei sicuro che entrambi gli operandi siano numerici</li><li>Quando concateni stringhe, assicurati che almeno uno degli operandi sia una stringa per evitare conversioni non intenzionali</li><li>Preferisci i template literal (`` `${}` ``) per concatenare stringhe in modo più leggibile, soprattutto con valori dinamici</li><li>Verifica sempre il tipo degli operandi per evitare comportamenti inattesi dovuti a coercizioni implicite</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Somma tra due numeri
    let a = 10;
    let b = 20;
    console.log(a + b); // Output: 30
    
    // Concatenazione di stringhe
    let nome = "Mario";
    let saluto = "Ciao, " + nome + "!";
    console.log(saluto); // Output: Ciao, Mario!
    
    // Coercizione implicita: concatenazione con un numero
    let anno = 2024;
    let messaggio = "Siamo nel " + anno;
    console.log(messaggio); // Output: Siamo nel 2024
    
    // Uso di template literal (miglior pratica)
    let messaggio2 = `Siamo nel ${anno}`;
    console.log(messaggio2); // Output: Siamo nel 2024
    
    // Attenzione alla coercizione implicita
    let risultato = "10" + 5;
    console.log(risultato); // Output: 105 (concatenazione, non somma)
                                </code></pre></div></li><li>Alternative:<ul><li>Per sommare numeri senza rischiare la concatenazione, verifica esplicitamente che entrambi gli operandi siano numeri</li><li>Per la concatenazione di stringhe, i template literal offrono una sintassi più pulita e leggibile</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere la somma con la concatenazione quando uno degli operandi è una stringa</li><li>Non considerare la coercizione implicita dei tipi, che può portare a risultati inattesi</li><li>Usare l'operatore `+` su tipi di dato non numerici o stringhe, causando conversioni implicite o errori logici</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore di addizione è estremamente veloce e ottimizzato. Tuttavia, operazioni ripetute di concatenazione su grandi stringhe possono essere meno efficienti rispetto all'uso di `Array.join()`</li><li>Coercizioni implicite possono introdurre comportamenti inattesi, quindi è meglio verificare i tipi di dato prima di eseguire operazioni aritmetiche</li></ul></li><li>Conclusioni: L'operatore di addizione (`+`) è uno degli strumenti più versatili e comuni in JavaScript, utilizzato sia per sommare numeri che per concatenare stringhe. Comprendere il suo comportamento, soprattutto in relazione alla coercizione dei tipi, è fondamentale per evitare errori e scrivere codice leggibile e affidabile. Sebbene l'operatore sia semplice, va usato con attenzione quando si lavora con tipi di dati misti.</li></ol></details><details><summary>Sottrazione<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per la sottrazione di valori numerici.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di sottrazione (-) in JavaScript è un operatore aritmetico binario che sottrae il secondo operando dal primo.</li><li>A cosa serve: Viene utilizzato per eseguire operazioni di sottrazione tra numeri, calcolare differenze e gestire operazioni matematiche in generale.</li><li>Quando usarlo: Si utilizza quando è necessario calcolare la differenza tra due numeri, decrementare valori in combinazione con l'assegnazione, effettuare calcoli matematici complessi o manipolare date rappresentate come timestamp.</li><li>Rilevanza semantica: Rappresenta l'operazione matematica di sottrazione e può essere utilizzato sia con numeri interi che con numeri decimali.</li><li>Principali caratteristiche:<ul><li>È un operatore binario (richiede due operandi)</li><li>Può essere combinato con l'operatore di assegnazione (-=)</li><li>Converte automaticamente gli operandi in numeri quando possibile</li><li>Può generare risultati speciali come NaN o Infinity in casi particolari</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in modo consistente in tutti i browser moderni</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Verificare sempre che gli operandi siano effettivamente numeri</li><li>Gestire casi speciali come NaN e Infinity</li><li>Utilizzare parentesi per chiarire l'ordine delle operazioni in espressioni complesse</li><li>Considerare l'uso di librerie matematiche per calcoli di precisione con decimali</li><li>Documentare chiaramente le operazioni matematiche complesse</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Sottrazione base
    let risultato = 10 - 5;  // risultato = 5
    
    // Sottrazione con decimali
    let decimali = 3.14 - 1.14;  // decimali = 2
    
    // Operatore di assegnazione con sottrazione
    let contatore = 10;
    contatore -= 3;  // contatore = 7
    
    // Sottrazione con date (timestamp)
    const data1 = new Date('2024-01-01');
    const data2 = new Date('2023-12-31');
    const differenzaGiorni = (data1 - data2) / (1000 * 60 * 60 * 24);  // 1
    
    // Gestione casi speciali
    console.log(10 - 'abc');  // NaN
    console.log(Infinity - Infinity);  // NaN
    console.log(10 - undefined);  // NaN
                                </code></pre></div></li><li>Alternative:<ul><li>Metodi di librerie matematiche per calcoli di precisione</li><li>Operatore decremento (--) per sottrarre 1</li><li>Math.subtract() di librerie come math.js per calcoli più precisi</li></ul></li><li>Potenziali errori comuni:<ul><li>Non gestire la conversione automatica di tipi</li><li>Ignorare il problema della precisione dei numeri in virgola mobile</li><li>Non considerare i casi di NaN o Infinity</li><li>Errori di precedenza degli operatori in espressioni complesse</li></ul></li><li>Impatto sulle performance:<ul><li>Operazione molto efficiente a livello di CPU</li><li>Nessun overhead significativo rispetto ad altri operatori aritmetici</li><li>Possibile impatto nelle operazioni con numeri decimali dovuto alla rappresentazione in virgola mobile</li></ul></li><li>Conclusioni: L'operatore di sottrazione è uno strumento fondamentale in JavaScript per eseguire calcoli matematici. Sebbene sia semplice da utilizzare, è importante comprenderne le peculiarità, come la conversione automatica dei tipi e i possibili casi speciali. Per calcoli che richiedono alta precisione, specialmente con numeri decimali, è consigliabile considerare l'uso di librerie matematiche specializzate. La sua semplicità e universalità lo rendono uno degli operatori più utilizzati nel linguaggio.</li></ol></details><details><summary>Moltiplicazione<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per la moltiplicazione di valori numerici.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di moltiplicazione (*) in JavaScript è un operatore aritmetico binario che moltiplica due operandi, restituendo il loro prodotto.</li><li>A cosa serve: Viene utilizzato per eseguire operazioni di moltiplicazione tra numeri, calcolare prodotti e gestire calcoli matematici che richiedono moltiplicazione.</li><li>Quando usarlo: Si utilizza quando è necessario calcolare il prodotto tra due o più numeri, scalare valori come nei calcoli percentuali, effettuare calcoli matematici complessi o gestire trasformazioni e scaling in grafica e animazioni.</li><li>Rilevanza semantica: Rappresenta l'operazione matematica di moltiplicazione e può essere utilizzato con qualsiasi tipo di numero (intero o decimale).</li><li>Principali caratteristiche:<ul><li>È un operatore binario (richiede due operandi)</li><li>Può essere combinato con l'operatore di assegnazione (*=)</li><li>Converte automaticamente gli operandi non numerici in numeri quando possibile</li><li>Rispetta le regole matematiche di precedenza degli operatori</li><li>Gestisce casi speciali come Infinity e NaN</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Comportamento consistente in tutti i browser</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Verificare sempre la validità degli operandi prima della moltiplicazione</li><li>Utilizzare parentesi per chiarire l'ordine delle operazioni in espressioni complesse</li><li>Prestare attenzione alla precisione dei numeri decimali</li><li>Gestire appropriatamente i casi di overflow</li><li>Considerare l'uso di BigInt per numeri molto grandi</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Moltiplicazione base
    let prodotto = 5 * 3;  // prodotto = 15
    
    // Moltiplicazione con decimali
    let decimali = 2.5 * 3.2;  // decimali = 8
    
    // Operatore di assegnazione con moltiplicazione
    let valore = 4;
    valore *= 3;  // valore = 12
    
    // Calcolo percentuale
    let prezzo = 100;
    let sconto = 0.2;  // 20%
    let prezzoScontato = prezzo * (1 - sconto);  // 80
    
    // Casi speciali
    console.log(5 * Infinity);  // Infinity
    console.log(0 * Infinity);  // NaN
    console.log(5 * 'abc');     // NaN
    
    // Uso con BigInt
    let numeroBig = 9007199254740991n * 2n;  // Per numeri molto grandi
    
    // Scaling in grafica
    let scala = 2;
    let larghezza = 100;
    let altezza = 50;
    let nuovaLarghezza = larghezza * scala;  // 200
    let nuovaAltezza = altezza * scala;      // 100
                                </code></pre></div></li><li>Alternative:<ul><li>Math.imul() per moltiplicazione di interi a 32 bit</li><li>Librerie matematiche per calcoli di alta precisione</li><li>BigInt per numeri molto grandi</li><li>Metodi specializzati per calcoli matematici complessi</li></ul></li><li>Potenziali errori comuni:<ul><li>Non considerare la perdita di precisione con numeri decimali</li><li>Ignorare possibili overflow con numeri grandi</li><li>Non gestire correttamente la conversione automatica dei tipi</li><li>Errori di precedenza in espressioni matematiche complesse</li><li>Non gestire correttamente i casi speciali (NaN, Infinity)</li></ul></li><li>Impatto sulle performance:<ul><li>Operazione molto efficiente per numeri standard</li><li>Possibile overhead con BigInt per numeri molto grandi</li><li>Impatto minimo sulle prestazioni in operazioni normali</li><li>Potenziale impatto con calcoli in virgola mobile complessi</li></ul></li><li>Conclusioni: L'operatore di moltiplicazione è uno strumento fondamentale in JavaScript per eseguire calcoli matematici. È versatile e potente, ma richiede attenzione particolare quando si lavora con numeri decimali o molto grandi. La sua semplicità di utilizzo non deve far sottovalutare l'importanza di gestire correttamente i casi speciali e le potenziali perdite di precisione. Per calcoli che richiedono alta precisione o coinvolgono numeri molto grandi, è consigliabile considerare l'uso di librerie matematiche specializzate o BigInt.</li></ol></details><details><summary>Divisione<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per la divisione di valori numerici.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di divisione (/) in JavaScript è un operatore aritmetico binario che divide il primo operando (dividendo) per il secondo operando (divisore).</li><li>A cosa serve: Viene utilizzato per eseguire operazioni di divisione tra numeri, calcolare quozienti e gestire operazioni matematiche che richiedono divisione.</li><li>Quando usarlo: Si utilizza quando è necessario calcolare il risultato della divisione tra due numeri, convertire unità di misura, calcolare proporzioni e rapporti, effettuare scaling inverso o calcolare medie e distribuzioni.</li><li>Rilevanza semantica: Rappresenta l'operazione matematica di divisione e gestisce sia divisioni intere che decimali, producendo sempre un risultato in virgola mobile.</li><li>Principali caratteristiche:<ul><li>È un operatore binario (richiede due operandi)</li><li>Può essere combinato con l'operatore di assegnazione (/=)</li><li>Restituisce sempre un numero in virgola mobile (Float)</li><li>Gestisce casi speciali come la divisione per zero (Infinity o -Infinity)</li><li>Converte automaticamente gli operandi non numerici quando possibile</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Comportamento consistente in tutti i browser moderni</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Controllare sempre che il divisore non sia zero</li><li>Gestire appropriatamente i casi di divisione per zero</li><li>Arrotondare i risultati quando necessario per evitare imprecisioni dei decimali</li><li>Utilizzare metodi appropriati per la gestione della precisione decimale</li><li>Documentare le assunzioni sui valori di input</li><li>Considerare l'uso di librerie matematiche per calcoli di precisione</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Divisione base
    let risultato = 10 / 2;  // risultato = 5
    
    // Divisione con decimali
    let decimale = 7 / 2;    // decimale = 3.5
    
    // Operatore di assegnazione con divisione
    let valore = 15;
    valore /= 3;  // valore = 5
    
    // Gestione della precisione decimale
    let prezzo = 10.99;
    let quantità = 3;
    let prezzoUnitario = (prezzo / quantità).toFixed(2);  // "3.66"
    
    // Casi speciali
    console.log(10 / 0);        // Infinity
    console.log(-10 / 0);       // -Infinity
    console.log(0 / 0);         // NaN
    console.log(Infinity / 2);  // Infinity
    
    // Conversione di unità
    function convertKmToMiles(km) {
        return km / 1.60934;
    }
    
    // Calcolo percentuali
    function calcolaPercentuale(parte, totale) {
        return (parte / totale * 100).toFixed(1) + '%';
    }
    
    // Divisione sicura con controllo del divisore
    function divisioneSicura(dividendo, divisore) {
        if (divisore === 0) {
            throw new Error('Divisione per zero non permessa');
        }
        return dividendo / divisore;
    }
    
    // Calcolo media
    function calcolaMedia(numeri) {
        return numeri.reduce((acc, val) =&gt; acc + val, 0) / numeri.length;
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Math.floor() o Math.trunc() per divisione intera</li><li>Operatore % (modulo) per ottenere il resto della divisione</li><li>Librerie matematiche per calcoli di alta precisione</li><li>Metodi personalizzati per gestire casi speciali</li></ul></li><li>Potenziali errori comuni:<ul><li>Non gestire la divisione per zero</li><li>Ignorare gli errori di arrotondamento con numeri decimali</li><li>Non considerare la precisione dei numeri in virgola mobile</li><li>Assumere che il risultato sia sempre un numero intero</li><li>Non gestire correttamente i casi di NaN e Infinity</li></ul></li><li>Impatto sulle performance:<ul><li>Operazione più costosa rispetto a moltiplicazione e addizione</li><li>Impatto minimo in operazioni normali</li><li>Possibile overhead con numeri decimali molto precisi</li><li>Considerare l'uso di bitshift (>> o >>>) per divisioni per potenze di 2 in caso di ottimizzazioni critiche</li></ul></li><li>Conclusioni: L'operatore di divisione è uno strumento fondamentale in JavaScript che richiede particolare attenzione nella gestione dei casi speciali e della precisione dei risultati. La sua natura di produrre sempre risultati in virgola mobile e la possibilità di generare valori speciali come Infinity o NaN lo rendono un operatore che richiede una gestione attenta degli edge case. Per applicazioni che richiedono alta precisione nei calcoli o gestione specifica dei casi limite, è consigliabile implementare funzioni wrapper appropriate o utilizzare librerie matematiche specializzate.</li></ol></details><details><summary>Modulo<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per il calcolo del resto della divisione tra due numeri.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore modulo (%) in JavaScript restituisce il resto della divisione tra due numeri. È un operatore aritmetico binario che calcola quanto rimane dopo che il primo operando è stato diviso il più possibile per il secondo operando.</li><li>A cosa serve: Viene utilizzato per calcolare il resto di una divisione, verificare se un numero è pari o dispari, implementare cicli circolari, limitare numeri entro un range e creare pattern ripetitivi.</li><li>Quando usarlo: Si utilizza quando è necessario determinare la divisibilità tra numeri, implementare algoritmi ciclici, gestire rotazioni e cicli, creare distribuzioni uniformi o validare e formattare dati numerici.</li><li>Rilevanza semantica: Rappresenta il concetto matematico di resto della divisione e viene spesso utilizzato in programmazione per operazioni cicliche e di controllo.</li><li>Principali caratteristiche:<ul><li>È un operatore binario (richiede due operandi)</li><li>Può essere combinato con l'operatore di assegnazione (%=)</li><li>Mantiene il segno del dividendo</li><li>Restituisce sempre un numero minore del divisore in valore assoluto</li><li>Può operare su numeri decimali</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Comportamento consistente in tutti i browser moderni</li><li>Funziona con BigInt (usando lo stesso operatore %)</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Verificare sempre che il divisore non sia zero</li><li>Considerare il comportamento con numeri negativi</li><li>Utilizzare per verifiche di divisibilità</li><li>Documentare chiaramente l'intento dell'operazione</li><li>Gestire appropriatamente i casi limite</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Calcolo base del resto
    console.log(10 % 3);  // 1
    console.log(15 % 4);  // 3
    
    // Verifica numero pari/dispari
    function isPari(numero) {
        return numero % 2 === 0;
    }
    
    // Limitare un numero in un range (utile per rotazioni)
    function limitaInRange(numero, max) {
        return numero % max;
    }
    
    // Implementazione di un orologio circolare (0-23)
    function getOra(ore) {
        return ore % 24;
    }
    
    // Distribuzione ciclica di elementi
    function distribuisciElemento(indice, numeroColonne) {
        return {
            riga: Math.floor(indice / numeroColonne),
            colonna: indice % numeroColonne
        };
    }
    
    // Creazione pattern ripetitivo
    function creaPattern(posizione, lunghezzaPattern) {
        return posizione % lunghezzaPattern;
    }
    
    // Gestione di indici circolari in un array
    function getElementoCircolare(array, indice) {
        return array[indice % array.length];
    }
    
    // Esempi con numeri negativi
    console.log(-10 % 3);   // -1
    console.log(10 % -3);   // 1
    console.log(-10 % -3);  // -1
    
    // Uso con operatore di assegnazione
    let numero = 10;
    numero %= 3;  // numero = 1
    
    // Validazione input numerico
    function validaInput(numero, max) {
        if (numero % 1 !== 0) {
            throw new Error('Il numero deve essere intero');
        }
        return numero % max;
    }
    
    // Generazione colori alternati
    function getColoreAlternato(indice) {
        return indice % 2 === 0 ? '#fff' : '#f0f0f0';
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Math.floor() con divisione per calcoli più espliciti</li><li>Sottrazione ripetuta per casi specifici</li><li>Bitwise operators per potenze di 2</li><li>Funzioni matematiche specializzate per casi complessi</li></ul></li><li>Potenziali errori comuni:<ul><li>Non considerare il comportamento con numeri negativi</li><li>Ignorare la divisione per zero</li><li>Assumere che il risultato sia sempre positivo</li><li>Non gestire correttamente i numeri decimali</li><li>Confondere il modulo con la divisione intera</li></ul></li><li>Impatto sulle performance:<ul><li>Operazione relativamente costosa rispetto ad altre operazioni aritmetiche</li><li>Efficiente per potenze di 2 (può essere ottimizzato dal motore JS)</li><li>Impatto trascurabile in operazioni normali</li><li>Può essere più lento con numeri decimali</li></ul></li><li>Conclusioni: L'operatore modulo è uno strumento potente e versatile in JavaScript, particolarmente utile per operazioni cicliche, validazioni e pattern ripetitivi. La sua capacità di limitare numeri in range specifici lo rende indispensabile in molti scenari di programmazione. Tuttavia, è importante comprenderne il comportamento con numeri negativi e decimali per evitare risultati inaspettati. Per casi d'uso avanzati o calcoli di alta precisione, potrebbero essere necessarie implementazioni personalizzate o l'uso di librerie matematiche specializzate.</li></ol></details><details><summary>Esponenziazione<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per il calcolo della potenza di un numero.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di esponenziazione (**) in JavaScript è un operatore aritmetico binario che eleva il primo operando (base) alla potenza del secondo operando (esponente).</li><li>A cosa serve: Viene utilizzato per calcolare potenze di numeri, implementare formule matematiche, calcolare crescite esponenziali, eseguire calcoli geometrici e implementare algoritmi scientifici.</li><li>Quando usarlo: Si utilizza quando è necessario calcolare quadrati, cubi e altre potenze, implementare formule matematiche complesse, calcolare crescite composte, eseguire calcoli scientifici o gestire scale logaritmiche.</li><li>Rilevanza semantica: Rappresenta l'operazione matematica di elevamento a potenza, fornendo una sintassi più chiara e intuitiva rispetto all'uso di Math.pow().</li><li>Principali caratteristiche:<ul><li>È un operatore binario (richiede due operandi)</li><li>Può essere combinato con l'operatore di assegnazione (**=)</li><li>Introdotto in ECMAScript 2016</li><li>Supporta esponenti decimali e negativi</li><li>Equivalente funzionale di Math.pow()</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutti i browser moderni</li><li>Richiede ES2016 o versioni successive</li><li>Alternative disponibili per browser legacy (Math.pow)</li><li>Funziona con BigInt (usando lo stesso operatore **)</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Verificare la compatibilità del browser se necessario</li><li>Gestire possibili overflow con numeri grandi</li><li>Considerare la precisione con numeri decimali</li><li>Documentare i casi limite</li><li>Gestire appropriatamente gli errori per esponenti non validi</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Esponenziazione base
    console.log(2 ** 3);    // 8
    console.log(10 ** 2);   // 100
    
    // Con numeri decimali
    console.log(2.5 ** 2);  // 6.25
    console.log(16 ** 0.5); // 4 (radice quadrata)
    
    // Esponenti negativi
    console.log(2 ** -2);   // 0.25
    console.log(10 ** -1);  // 0.1
    
    // Operatore di assegnazione
    let numero = 2;
    numero **= 3;  // numero = 8
    
    // Calcolo area cerchio
    function areaCircolo(raggio) {
        return Math.PI * (raggio ** 2);
    }
    
    // Crescita composta
    function crescitaComposta(principale, tasso, anni) {
        return principale * ((1 + tasso) ** anni);
    }
    
    // Calcolo scala logaritmica
    function valoreScalaLog(base, livello) {
        return base ** livello;
    }
    
    // Conversione unità
    function convertiPotenzeDiDieci(numero, esponente) {
        return numero * (10 ** esponente);
    }
    
    // Gestione errori
    function potenzaSicura(base, esponente) {
        if (base === 0 &amp;&amp; esponente &lt; 0) {
            throw new Error('Divisione per zero non permessa');
        }
        return base ** esponente;
    }
    
    // Calcolo radici n-esime
    function radiceNesima(numero, n) {
        return numero ** (1/n);
    }
    
    // Esempi con BigInt
    console.log(2n ** 3n);  // 8n
    console.log(10n ** 2n); // 100n
    
    // Calcolo distanza euclidea
    function distanzaEuclidea(x1, y1, x2, y2) {
        return ((x2 - x1) ** 2 + (y2 - y1) ** 2) ** 0.5;
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Math.pow() per compatibilità con browser più vecchi</li><li>Math.sqrt() per radici quadrate specifiche</li><li>Moltiplicazioni ripetute per potenze intere basse</li><li>Librerie matematiche per calcoli di alta precisione</li></ul></li><li>Potenziali errori comuni:<ul><li>Non gestire overflow con esponenti grandi</li><li>Ignorare la perdita di precisione con decimali</li><li>Non gestire casi speciali (0⁰, ∞, NaN)</li><li>Uso errato con base negativa ed esponenti decimali</li><li>Non considerare limiti di precisione JavaScript</li></ul></li><li>Impatto sulle performance:<ul><li>Generalmente più veloce di implementazioni manuali</li><li>Potenzialmente costoso per esponenti grandi</li><li>Ottimizzato dai motori JavaScript moderni</li><li>Impatto significativo con BigInt per numeri molto grandi</li></ul></li><li>Conclusioni: L'operatore di esponenziazione è un'aggiunta relativamente recente a JavaScript che semplifica notevolmente la scrittura di calcoli matematici che coinvolgono potenze. La sua sintassi intuitiva e le prestazioni ottimizzate lo rendono preferibile rispetto a Math.pow() in codice moderno. Tuttavia, è importante gestire correttamente i casi limite e considerare la precisione dei calcoli, specialmente quando si lavora con numeri decimali o molto grandi. Per calcoli matematici complessi o che richiedono alta precisione, potrebbe essere necessario considerare l'uso di librerie matematiche specializzate.</li></ol></details><details><summary>Incremento<span class="tag-description" aria-label="descrizione tag">Operatore aritmetico per aumentare il valore di una variabile di una unità.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di incremento (++) in JavaScript è un operatore unario che aumenta il valore di una variabile di una unità. Può essere utilizzato sia come prefisso (++x) che come suffisso (x++).</li><li>A cosa serve: L'operatore viene utilizzato per incrementare contatori, gestire cicli iterativi, implementare sequenze numeriche, aggiornare indici di array e gestire progressioni aritmetiche.</li><li>Quando usarlo: Si utilizza quando è necessario incrementare variabili in cicli `for`, gestire conteggi progressivi, implementare contatori, aggiornare posizioni in strutture dati e gestire iterazioni sequenziali.</li><li>Rilevanza semantica: Rappresenta l'operazione matematica di incremento unitario, fornendo una sintassi concisa e chiara per aumentare il valore di una variabile.</li><li>Principali caratteristiche:<ul><li>È un operatore unario (richiede un solo operando)</li><li>Esistono due forme: prefissa (++x) e suffissa (x++)</li><li>La forma prefissa restituisce il valore dopo l'incremento</li><li>La forma suffissa restituisce il valore prima dell'incremento</li><li>Modifica il valore originale della variabile</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona con tutti i browser</li><li>Non utilizzabile con costanti (const)</li><li>Non utilizzabile con valori letterali</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Preferire la forma prefissa quando il valore di ritorno è importante</li><li>Evitare l'uso in espressioni complesse per maggiore leggibilità</li><li>Non utilizzare più operatori di incremento nella stessa espressione</li><li>Documentare chiaramente quando si usa la forma suffissa</li><li>Considerare l'uso di += 1 per maggiore chiarezza in alcuni contesti</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Incremento base
    let contatore = 0;
    contatore++;     // contatore = 1
    ++contatore;     // contatore = 2
    
    // Differenza tra prefisso e suffisso
    let a = 1;
    let b = a++;    // b = 1, a = 2
    let c = ++a;    // c = 3, a = 3
    
    // Uso in cicli for
    for (let i = 0; i &lt; 5; i++) {
        console.log(i);  // Stampa 0,1,2,3,4
    }
    
    // Iterazione su array
    const array = ['a', 'b', 'c'];
    let index = 0;
    while (index &lt; array.length) {
        console.log(array[index++]);
    }
    
    // Contatore personalizzato
    function createCounter() {
        let count = 0;
        return {
            increment: () =&gt; ++count,
            getValue: () =&gt; count
        };
    }
    
    // Gestione di sequenze
    function* numberSequence() {
        let num = 0;
        while (true) {
            yield ++num;
        }
    }
    
    // Implementazione di un iteratore
    class Iterator {
        constructor(start = 0) {
            this.value = start;
        }
        
        next() {
            return this.value++;
        }
    }
    
    // Gestione di indici circolari
    function circularIndex(current, max) {
        return (current + 1) % max;
    }
    
    // Contatore con limite
    function boundedIncrement(value, max) {
        return value &lt; max ? ++value : value;
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Operatore += 1 per incremento più esplicito</li><li>Assegnazione diretta (x = x + 1)</li><li>Metodi personalizzati per incrementi specifici</li><li>Funzioni di ordine superiore per iterazioni</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere prefisso e suffisso nell'uso del valore di ritorno</li><li>Utilizzare l'incremento su tipi non numerici</li><li>Tentare di incrementare costanti o valori letterali</li><li>Creare side effects non intenzionali in espressioni complesse</li><li>Non considerare l'overflow con numeri grandi</li></ul></li><li>Impatto sulle performance:<ul><li>Operazione estremamente efficiente</li><li>Ottimizzata dai motori JavaScript moderni</li><li>Nessun overhead significativo rispetto alle alternative</li><li>Prestazioni migliori rispetto a metodi più verbosi</li></ul></li><li>Conclusioni: L'operatore di incremento è uno strumento fondamentale in JavaScript che offre un modo conciso ed efficiente per aumentare il valore di una variabile. La sua duplice natura (prefissa e suffissa) offre flessibilità nell'implementazione, ma richiede attenzione per evitare comportamenti inattesi. È particolarmente utile nei cicli e nella gestione di contatori, ma deve essere usato con consapevolezza delle sue caratteristiche e potenziali insidie. La sua semplicità e diffusione lo rendono uno degli operatori più utilizzati nel linguaggio, ma è importante mantenere la leggibilità del codice e considerare alternative più esplicite quando appropriato.</li></ol></details><details><summary>Decremento<span class="tag-description" aria-label="descrizione tag">Operatore unario che diminuisce di una unità il valore di una variabile numerica.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di decremento (--), in JavaScript, è un operatore unario che riduce il valore di una variabile numerica di 1.</li><li>A cosa serve: Viene utilizzato per ridurre il valore di una variabile di un'unità. È comunemente usato in contatori e cicli, dove il valore di una variabile deve essere decrementato progressivamente.</li><li>Quando usarlo: Si utilizza quando è necessario diminuire progressivamente il valore di una variabile, specialmente in contesti come cicli, iterazioni o conteggi alla rovescia.</li><li>Rilevanza semantica: Indica un'operazione di sottrazione unitaria, segnalando chiaramente l'intenzione di ridurre un valore in modo incrementale.</li><li>Principali caratteristiche:<ul><li>Può essere usato in forma **prefissa** (--x) o **postfissa** (x--)</li><li>Modifica direttamente il valore della variabile</li><li>Restituisce un valore che dipende dalla forma usata: il nuovo valore nella forma prefissa, il valore originale nella forma postfissa</li><li>Può essere usato solo su variabili, non su valori letterali</li><li>Funziona esclusivamente con valori numerici</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona uniformemente in tutti i browser moderni</li><li>Non presenta problemi di compatibilità cross-browser</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Preferire la forma **prefissa** quando è importante ottenere subito il nuovo valore</li><li>Evitare l'uso in espressioni complesse per una migliore leggibilità</li><li>Non utilizzarlo più volte sulla stessa variabile nella stessa espressione</li><li>Documentare chiaramente l'uso in contesti non ovvi, specialmente per chi legge il codice</li><li>Evitare l'uso con tipi non numerici</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Decremento prefisso
    let a = 5;
    let b = --a; // a = 4, b = 4
    
    // Decremento postfisso
    let x = 5;
    let y = x--; // x = 4, y = 5
    
    // Uso in un ciclo
    for (let i = 10; i &gt; 0; i--) {
        console.log(i); // Conto alla rovescia da 10 a 1
    }
    
    // Uso come contatore
    let counter = 3;
    while (counter--) {
        console.log('Iterazione rimanente:', counter);
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Operatore di sottrazione (x -= 1)</li><li>Assegnazione diretta (x = x - 1)</li><li>Metodi di array come <code>pop()</code> per rimuovere elementi da una struttura dati</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere il comportamento tra la forma prefissa e quella postfissa</li><li>Utilizzarlo su valori non numerici</li><li>Usarlo su variabili dichiarate con <code>const</code>, che non possono essere modificate</li><li>Utilizzarlo in espressioni troppo complesse, rendendo il codice difficile da leggere</li><li>Decrementare involontariamente la stessa variabile più volte</li></ul></li><li>Impatto sulle performance:<ul><li>Ha un impatto minimo sulle performance rispetto ad altre operazioni</li><li>È leggermente più efficiente rispetto all'uso di <code>x = x - 1</code></li><li>Non presenta overhead significativo, ed è ottimizzato dai motori JavaScript moderni</li></ul></li><li>Conclusioni: L'operatore di decremento è uno strumento fondamentale per la manipolazione di valori numerici in JavaScript. È particolarmente utile in contesti di iterazione e conteggio. La sua doppia forma, prefissa e postfissa, offre una certa flessibilità ma richiede attenzione per evitare errori. Sebbene semplice, la corretta comprensione del suo comportamento è essenziale per scrivere codice JavaScript efficace e manutenibile. Un uso appropriato può rendere il codice più conciso e leggibile, specialmente in cicli e contatori.</li></ol></details><details><summary>Assegnamento<span class="tag-description" aria-label="descrizione tag">Operatore che assegna un valore a una variabile.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di assegnamento (=) in JavaScript è un operatore che assegna un valore a una variabile. Prende il valore a destra dell'operatore e lo memorizza nella variabile a sinistra.</li><li>A cosa serve: Viene utilizzato per assegnare valori a variabili. Può essere usato per inizializzare variabili, aggiornare il loro contenuto e salvare il risultato di espressioni o funzioni.</li><li>Quando usarlo: Si utilizza quando è necessario dare un valore iniziale a una variabile o aggiornare il valore di una variabile esistente. È essenziale in qualsiasi contesto in cui è necessario memorizzare e manipolare dati.</li><li>Rilevanza semantica: Indica l'operazione di assegnazione, che è una delle operazioni fondamentali in qualsiasi linguaggio di programmazione. L'operatore comunica al motore JavaScript l'intenzione di legare un valore a un identificatore.</li><li>Principali caratteristiche:<ul><li>Assegna il valore alla variabile alla sua sinistra</li><li>Funziona con variabili di qualsiasi tipo, inclusi numeri, stringhe, oggetti, array, e funzioni</li><li>È il primo passo per utilizzare qualsiasi variabile in un programma</li><li>Può essere combinato con altri operatori in forme di assegnazione avanzata, come +=, -=, *=, /=</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona uniformemente in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Dichiarare e assegnare sempre le variabili con let o const per evitare l'inquinamento dello scope globale</li><li>Evitare di usare l'operatore di assegnamento in espressioni complesse per garantire la leggibilità</li><li>Assicurarsi di assegnare valori coerenti al tipo di dati previsto per la variabile</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Assegnazione di un valore numerico
    let x = 10;
    
    // Assegnazione di una stringa
    let name = "Mario";
    
    // Assegnazione del risultato di un'operazione
    let sum = 5 + 3;
    
    // Assegnazione di una funzione a una variabile
    let greet = function() {
        console.log("Ciao!");
    };
                                </code></pre></div></li><li>Alternative:<ul><li>Operatore di assegnazione combinata (+=, -=, etc.) per aggiornare il valore di una variabile con un'operazione</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'operatore di assegnamento (=) con l'operatore di confronto (== o ===)</li><li>Assegnare valori a variabili dichiarate con const, che non possono essere riassegnate</li><li>Non assegnare un valore iniziale a una variabile, portando a undefined</li></ul></li><li>Impatto sulle performance:<ul><li>Non ha un impatto significativo sulle performance, poiché l'assegnazione è una delle operazioni più rapide in JavaScript</li><li>Il tipo di dato assegnato potrebbe influenzare la memoria utilizzata, ma l'operatore in sé non incide significativamente sulle prestazioni</li></ul></li><li>Conclusioni: L'operatore di assegnamento è uno degli elementi più basilari e indispensabili in JavaScript. Consente di associare un valore a una variabile, permettendo al programma di memorizzare e manipolare dati. Una corretta comprensione e uso dell'operatore è fondamentale per scrivere codice efficace e manutenibile.</li></ol></details><details><summary>Uguaglianza non stretta<span class="tag-description" aria-label="descrizione tag">Confronta due valori verificandone l'uguaglianza dopo la conversione implicita di tipo.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di uguaglianza non stretta (==) in JavaScript è un operatore di confronto che verifica se due valori sono uguali, applicando una conversione implicita di tipo (coercizione) quando i tipi dei due operandi sono differenti.</li><li>A cosa serve: Viene utilizzato per confrontare due valori e verificare se sono considerati equivalenti dal punto di vista del contenuto, anche se appartengono a tipi diversi. L'operatore converte i valori prima di confrontarli, consentendo confronti flessibili tra numeri, stringhe e altri tipi.</li><li>Quando usarlo: Si utilizza quando è necessario confrontare valori che potrebbero essere di tipi diversi, ma si desidera comunque sapere se il loro contenuto è equivalente dopo la conversione. Ad esempio, è utile quando si confrontano stringhe e numeri o altri tipi che possono essere coerced per confronti più permissivi.</li><li>Rilevanza semantica: Indica un confronto tra due valori che tiene conto della possibilità di conversione di tipo. La coercizione permette di confrontare valori con tipi differenti che potrebbero essere considerati equivalenti secondo il linguaggio JavaScript, anche se non strettamente identici.</li><li>Principali caratteristiche:<ul><li>Converte automaticamente i tipi dei valori coinvolti nel confronto</li><li>Restituisce <code>true</code> se, dopo la conversione, i due valori sono uguali</li><li>Può portare a risultati inattesi a causa della coercizione implicita</li><li>Non confronta strettamente il tipo, diversamente dall'operatore di uguaglianza stretta (===)</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona uniformemente in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare l'operatore di uguaglianza stretta (===) nella maggior parte dei casi, per evitare risultati inaspettati dovuti alla coercizione implicita</li><li>Riservare l'uso dell'uguaglianza non stretta solo quando si è consapevoli della coercizione e si vuole sfruttare il comportamento permissivo</li><li>Evitare di usarlo in contesti complessi o dove i tipi di dati possono essere incerti</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Confronto tra numero e stringa
    console.log(5 == '5'); // true, a causa della coercizione
    
    // Confronto tra booleano e numero
    console.log(true == 1); // true, true viene convertito in 1
    
    // Confronto tra null e undefined
    console.log(null == undefined); // true, questi due valori sono considerati uguali in questo contesto
    
    // Confronto che genera un risultato inatteso
    console.log(0 == false); // true, a causa della coercizione implicita
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore di uguaglianza stretta (===) per confrontare sia il valore che il tipo</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'uguaglianza non stretta (==) con l'uguaglianza stretta (===), che confronta anche il tipo</li><li>Ottenere risultati inattesi a causa della coercizione implicita, specialmente in confronti tra booleani, numeri e stringhe</li><li>Usarlo in contesti dove i tipi di dati sono incerti, il che può portare a bug difficili da rilevare</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore di uguaglianza non stretta può comportare un leggero overhead dovuto alla coercizione implicita, ma questo impatto è generalmente trascurabile</li><li>La performance è comparabile a quella dell'operatore di uguaglianza stretta (===) nella maggior parte dei casi</li></ul></li><li>Conclusioni: L'operatore di uguaglianza non stretta (==) offre un modo flessibile per confrontare valori in JavaScript, ma la sua natura permissiva può introdurre comportamenti inattesi a causa della coercizione implicita dei tipi. Anche se utile in alcuni contesti, il suo uso deve essere fatto con cautela e consapevolezza. Nella maggior parte dei casi, è preferibile utilizzare l'operatore di uguaglianza stretta (===) per evitare problemi legati alla coercizione. Tuttavia, l'uguaglianza non stretta rimane uno strumento importante quando si vogliono confrontare valori di tipo diverso ma concettualmente equivalenti.</li></ol></details><details><summary>Uguaglianza Stretta<span class="tag-description" aria-label="descrizione tag">Confronta sia il valore che il tipo dei due operandi senza applicare la coercizione implicita.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di uguaglianza stretta (`===`) in JavaScript è un operatore di confronto che verifica se due valori sono identici, senza applicare la coercizione di tipo. Confronta sia il valore che il tipo dei due operandi, restituendo `true` solo se entrambi sono uguali e appartengono allo stesso tipo.</li><li>A cosa serve: Viene utilizzato per confrontare due valori verificando sia il loro contenuto che il loro tipo. È preferibile all'operatore di uguaglianza non stretta (`==`) quando si vuole evitare risultati inattesi dovuti alla coercizione implicita.</li><li>Quando usarlo: Si utilizza quando è necessario confrontare valori in modo rigoroso, assicurandosi che i due operandi abbiano lo stesso valore **e** lo stesso tipo. È particolarmente utile in situazioni dove si vuole evitare errori dovuti alla conversione automatica di tipo, come nel confronto tra numeri e stringhe o booleani e numeri.</li><li>Rilevanza semantica: Indica un confronto rigoroso che tiene conto sia del valore che del tipo dei due operandi. Assicura che non venga effettuata alcuna conversione implicita, garantendo così che il confronto sia preciso e affidabile.</li><li>Principali caratteristiche:<ul><li>Non applica la coercizione di tipo</li><li>Restituisce <code>true</code> solo se i due valori hanno lo stesso valore e tipo</li><li>Evita risultati inattesi che potrebbero derivare dalla conversione automatica dei tipi</li><li>Preferibile all'operatore di uguaglianza non stretta (`==`) nella maggior parte dei casi</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona uniformemente in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare sempre l'operatore di uguaglianza stretta (`===`) per evitare problemi dovuti alla coercizione di tipo</li><li>Assicurarsi che i valori da confrontare siano dello stesso tipo prima di usare l'operatore</li><li>Preferirlo rispetto all'operatore di uguaglianza non stretta (`==`), a meno che non sia necessario confrontare valori di tipi differenti con coercizione</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Confronto tra numero e stringa
    console.log(5 === '5'); // false, tipi diversi (numero e stringa)
    
    // Confronto tra numeri
    console.log(5 === 5); // true, stesso valore e stesso tipo
    
    // Confronto tra booleano e numero
    console.log(true === 1); // false, tipi diversi (booleano e numero)
    
    // Confronto tra null e undefined
    console.log(null === undefined); // false, tipi diversi
    
    // Confronto tra oggetti (riferimenti)
    let obj1 = { a: 1 };
    let obj2 = { a: 1 };
    console.log(obj1 === obj2); // false, riferimenti a oggetti diversi
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore di uguaglianza non stretta (`==`) se è necessario confrontare valori con coercizione di tipo</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'uguaglianza stretta (`===`) con l'uguaglianza non stretta (`==`), che applica la coercizione</li><li>Confrontare oggetti o array con `===`, dimenticando che questi confrontano i riferimenti e non i valori interni</li><li>Non considerare la differenza tra tipi primitivi e tipi di riferimento (oggetti, array) nei confronti</li></ul></li><li>Impatto sulle performance:<ul><li>È leggermente più veloce dell'operatore di uguaglianza non stretta (`==`), poiché non effettua conversioni implicite</li><li>Non ha un impatto significativo sulle performance nella maggior parte dei casi</li></ul></li><li>Conclusioni: L'operatore di uguaglianza stretta (`===`) è lo strumento preferito per confrontare valori in JavaScript, poiché offre un confronto preciso e rigoroso che evita risultati inattesi causati dalla coercizione implicita. Garantisce che i due operandi siano sia dello stesso tipo che dello stesso valore, rendendolo la scelta ideale per la maggior parte dei confronti nel codice. Comprendere la differenza tra `===` e `==` è essenziale per evitare errori comuni e garantire un comportamento prevedibile nelle operazioni di confronto.</li></ol></details><details><summary>Disuguaglianza non stretta<span class="tag-description" aria-label="descrizione tag">Verifica se due valori sono diversi, applicando la conversione implicita di tipo se necessario.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di disuguaglianza non stretta (`!=`) in JavaScript confronta due valori e verifica se **non sono uguali**, applicando la **coercizione di tipo** se necessario. Restituisce `true` se i valori sono considerati diversi dopo la conversione implicita.</li><li>A cosa serve: Viene utilizzato per verificare se due valori sono diversi tra loro, anche se appartengono a tipi differenti. Grazie alla coercizione implicita, l'operatore tenta di rendere i valori comparabili convertendoli automaticamente in un tipo comune, prima di verificarne la disuguaglianza.</li><li>Quando usarlo: Si utilizza quando è necessario verificare la disuguaglianza tra valori di tipi diversi, oppure quando si vuole ottenere una risposta flessibile, permettendo al linguaggio di gestire la conversione di tipo. Ad esempio, può essere utile quando si confrontano stringhe e numeri o altri tipi che possono essere coerced per confronti meno rigidi.</li><li>Rilevanza semantica: L'operatore indica che si sta verificando se due valori sono diversi, tenendo conto della possibilità di una conversione implicita di tipo. Consente una flessibilità che permette di confrontare valori che, altrimenti, non sarebbero considerati confrontabili senza conversione.</li><li>Principali caratteristiche:<ul><li>Applica la coercizione di tipo quando i due valori appartengono a tipi differenti</li><li>Restituisce <code>true</code> se, dopo la coercizione, i valori risultano diversi</li><li>Non confronta strettamente il tipo, quindi può portare a risultati inattesi a causa della coercizione</li><li>Può essere usato per confronti flessibili tra numeri, stringhe, booleani e altri tipi di dati</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Preferire l'operatore di disuguaglianza stretta (`!==`) per evitare risultati imprevisti dovuti alla coercizione di tipo</li><li>Riservare l'uso della disuguaglianza non stretta quando si è consapevoli del comportamento della coercizione e si desidera sfruttare questa flessibilità</li><li>Evitare l'uso in contesti complessi o quando i tipi di dati coinvolti possono variare in modo imprevedibile</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Confronto tra numero e stringa
    console.log(5 != '5'); // false, coercizione: '5' viene convertita in numero
    
    // Confronto tra booleano e numero
    console.log(true != 1); // false, coercizione: true viene convertito in 1
    
    // Confronto tra null e undefined
    console.log(null != undefined); // false, null e undefined sono considerati equivalenti in questo caso
    
    // Confronto tra numero e booleano
    console.log(0 != false); // false, coercizione: false viene convertito in 0
                                </code></pre></div></li><li>Alternative:<ul><li>Usare l'operatore di disuguaglianza stretta (`!==`) per confrontare sia il valore che il tipo senza coercizione implicita</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'operatore di disuguaglianza non stretta (`!=`) con l'operatore di disuguaglianza stretta (`!==`), che non applica la coercizione di tipo</li><li>Ottenere risultati inattesi a causa della coercizione implicita, specialmente con booleani, numeri e stringhe</li><li>Utilizzarlo in espressioni complesse, dove la coercizione di tipo può introdurre bug difficili da individuare</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore di disuguaglianza non stretta può avere un leggero overhead a causa della coercizione di tipo, ma questo impatto è generalmente trascurabile</li><li>Le performance sono comparabili a quelle dell'operatore di disuguaglianza stretta (`!==`), salvo nei casi in cui la coercizione richiede conversioni complesse</li></ul></li><li>Conclusioni: L'operatore di disuguaglianza non stretta (`!=`) offre un modo flessibile per confrontare valori diversi in JavaScript, ma la coercizione implicita di tipo può portare a risultati inattesi. Nella maggior parte dei casi, è preferibile utilizzare l'operatore di disuguaglianza stretta (`!==`) per evitare comportamenti inaspettati. Tuttavia, in alcuni contesti in cui è utile confrontare valori di tipo diverso, la disuguaglianza non stretta può essere vantaggiosa. È essenziale comprendere a fondo il meccanismo della coercizione per evitare errori di programmazione.</li></ol></details><details><summary>Disuguaglianza Stretta<span class="tag-description" aria-label="descrizione tag">Confronta sia il valore che il tipo.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di disuguaglianza stretta (`!==`) in JavaScript confronta due valori verificando se **non sono uguali** sia nel valore che nel tipo, senza applicare la coercizione di tipo. Restituisce `true` se i due operandi hanno valori diversi o tipi diversi.</li><li>A cosa serve: Viene utilizzato per confrontare due valori in modo rigoroso, assicurandosi che siano considerati disuguali se differiscono sia per valore che per tipo. È utile per evitare risultati inattesi dovuti alla conversione implicita dei tipi che avviene con l'operatore di disuguaglianza non stretta (`!=`).</li><li>Quando usarlo: Si utilizza quando è necessario un confronto preciso tra due valori, garantendo che il confronto verifichi sia il valore che il tipo dei due operandi. È particolarmente utile per evitare risultati imprevisti in situazioni in cui i tipi di dati sono importanti e non devono essere convertiti automaticamente.</li><li>Rilevanza semantica: Indica che due valori sono considerati diversi **solo** se differiscono per tipo o per valore, senza applicare alcuna conversione automatica. Questo rende il confronto più rigoroso rispetto all'operatore di disuguaglianza non stretta.</li><li>Principali caratteristiche:<ul><li>Non applica la **coercizione di tipo**, contrariamente all'operatore di disuguaglianza non stretta (`!=`)</li><li>Restituisce <code>true</code> solo se i valori sono diversi o appartengono a tipi differenti</li><li>Garantisce un confronto più rigoroso e prevedibile rispetto alla disuguaglianza non stretta</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Preferire l'uso dell'operatore di disuguaglianza stretta (`!==`) rispetto a quello non stretta (`!=`) per evitare sorprese dovute alla coercizione implicita di tipo</li><li>Utilizzarlo in tutti i contesti dove è importante confrontare sia il valore che il tipo dei due operandi</li><li>Evitare di usare `!==` con tipi di riferimento come oggetti e array, poiché confronta i riferimenti in memoria e non i contenuti</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Confronto tra numero e stringa
    console.log(5 !== '5'); // true, tipi diversi (numero e stringa)
    
    // Confronto tra booleano e numero
    console.log(true !== 1); // true, tipi diversi (booleano e numero)
    
    // Confronto tra numeri uguali
    console.log(5 !== 5); // false, stesso valore e stesso tipo
    
    // Confronto tra null e undefined
    console.log(null !== undefined); // true, tipi diversi
    
    // Confronto tra oggetti
    let obj1 = { a: 1 };
    let obj2 = { a: 1 };
    console.log(obj1 !== obj2); // true, diversi riferimenti in memoria
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore di disuguaglianza non stretta (`!=`) se si desidera che la coercizione di tipo venga applicata</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'operatore di disuguaglianza stretta (`!==`) con l'operatore di disuguaglianza non stretta (`!=`), che permette la coercizione di tipo</li><li>Confrontare oggetti o array con `!==`, dimenticando che il confronto riguarda i riferimenti e non i contenuti</li><li>Non considerare che `!==` richiede che entrambi i valori siano identici nel tipo e nel valore per restituire `false`</li></ul></li><li>Impatto sulle performance:<ul><li>Generalmente più veloce rispetto all'operatore di disuguaglianza non stretta (`!=`), poiché non deve eseguire coercizione di tipo</li><li>L'operatore ha un impatto minimo sulle performance, in linea con gli altri operatori di confronto</li></ul></li><li>Conclusioni: L'operatore di disuguaglianza stretta (`!==`) è uno strumento essenziale per confrontare valori in JavaScript in modo preciso, senza coercizione implicita di tipo. Garantisce che due valori vengano considerati disuguali se differiscono per tipo o per valore, offrendo così una maggiore prevedibilità rispetto alla disuguaglianza non stretta (`!=`). È l'opzione preferita per evitare errori legati alla conversione automatica dei tipi, specialmente quando i tipi dei dati sono fondamentali per il corretto funzionamento del codice.</li></ol></details><details><summary>AND Logico<span class="tag-description" aria-label="descrizione tag">Valuta le espressioni e restituisce il primo valore falsy o l'ultimo valore truthy.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore AND logico (`&&`) in JavaScript è utilizzato per valutare due o più espressioni. Restituisce il primo valore "falsy" trovato o, se tutte le espressioni sono "truthy", l'ultimo valore valutato.</li><li>A cosa serve: Serve a eseguire operazioni logiche, verificando se più condizioni sono tutte vere. È comunemente usato nei controlli condizionali per verificare che più condizioni siano soddisfatte.</li><li>Quando usarlo: Utilizzalo quando devi verificare che tutte le condizioni siano vere per eseguire una determinata operazione, come ad esempio controllare che un utente sia autenticato e che abbia i permessi per accedere a una risorsa.</li><li>Rilevanza semantica: Indica che l'operazione è vera solo se **tutte** le condizioni coinvolte sono vere. Se una delle condizioni è falsa, l'operazione restituisce "falso" e interrompe l'ulteriore valutazione.</li><li>Principali caratteristiche:<ul><li>Valuta da sinistra a destra, restituendo il primo valore "falsy" trovato.</li><li>Se tutte le espressioni sono "truthy", restituisce l'ultimo valore.</li><li>Non esegue il codice a destra dell'operatore se trova un valore "falsy" (short-circuiting).</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare l'operatore AND (`&&`) per eseguire verifiche multiple in una sola condizione.</li><li>Sfruttare il "short-circuiting" per evitare esecuzioni non necessarie di codice.</li><li>Non abusare dell'operatore per concatenare troppe condizioni complesse; mantieni la leggibilità del codice.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Controllo di due condizioni
    let isAuthenticated = true;
    let hasAccess = true;
    if (isAuthenticated &amp;&amp; hasAccess) {
        console.log('Accesso consentito');
    } else {
        console.log('Accesso negato');
    }
    
    // Valore "falsy" in una catena di espressioni
    console.log(null &amp;&amp; 'Hello'); // Restituisce null, primo valore "falsy"
    
    // Tutti valori "truthy"
    console.log('Hello' &amp;&amp; 123 &amp;&amp; true); // Restituisce true, ultimo valore valutato
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore OR (`||`) se si desidera verificare che **almeno una** delle condizioni sia vera.</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare che l'operatore AND (`&&`) restituisce il primo valore "falsy" trovato, il che può portare a risultati inattesi.</li><li>Confondere l'operatore con l'OR (`||`), che invece restituisce il primo valore "truthy".</li></ul></li><li>Impatto sulle performance:<ul><li>Può migliorare le performance evitando valutazioni superflue grazie al "short-circuiting".</li><li>Generalmente ha un impatto minimo sulle performance rispetto ad altre operazioni logiche.</li></ul></li><li>Conclusioni: L'operatore AND logico (`&&`) è essenziale per la valutazione di condizioni multiple in JavaScript. La sua capacità di restituire il primo valore "falsy" o l'ultimo valore "truthy" consente di scrivere controlli condizionali efficienti e di evitare esecuzioni superflue grazie al "short-circuiting".</li></ol></details><details><summary>OR Logico<span class="tag-description" aria-label="descrizione tag">Valuta le espressioni e restituisce il primo valore truthy o l'ultimo valore falsy.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore OR logico (`||`) in JavaScript è utilizzato per valutare due o più espressioni. Restituisce il primo valore "truthy" trovato o, se tutte le espressioni sono "falsy", l'ultimo valore valutato.</li><li>A cosa serve: Serve a verificare se almeno una tra le condizioni è vera. È spesso utilizzato nei controlli condizionali per eseguire operazioni alternative quando almeno una delle condizioni è soddisfatta.</li><li>Quando usarlo: Utilizzalo quando vuoi che un'operazione venga eseguita se almeno una tra le condizioni è vera, come ad esempio verificare se un utente ha inserito almeno una delle opzioni richieste.</li><li>Rilevanza semantica: Indica che l'operazione è vera se **almeno una** delle condizioni coinvolte è vera. Se tutte le condizioni sono false, l'operazione restituisce "falso".</li><li>Principali caratteristiche:<ul><li>Valuta da sinistra a destra, restituendo il primo valore "truthy" trovato.</li><li>Se tutte le espressioni sono "falsy", restituisce l'ultimo valore.</li><li>Non valuta il codice a destra dell'operatore se trova un valore "truthy" (short-circuiting).</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Funziona in tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizzare l'operatore OR (`||`) per fornire valori di default in caso di valori non definiti o nulli.</li><li>Sfruttare il "short-circuiting" per evitare esecuzioni non necessarie di codice.</li><li>Evitare di concatenare troppe condizioni complesse, poiché potrebbe ridurre la leggibilità del codice.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso per fornire un valore di default
    let userName = userInput || 'Guest';
    console.log(userName); // Restituisce 'Guest' se userInput è falsy
    
    // Valore "truthy" in una catena di espressioni
    console.log('Hello' || null); // Restituisce 'Hello', primo valore "truthy"
    
    // Tutti valori "falsy"
    console.log(null || 0 || ''); // Restituisce '', ultimo valore valutato
    
    // Short-circuiting: evita esecuzione di funzioni costose
    let isLoggedIn = true;
    isLoggedIn || expensiveFunction(); // La funzione non viene chiamata
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore AND (`&&`) se si desidera verificare che **tutte** le condizioni siano vere.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'operatore OR (`||`) con l'AND (`&&`), che invece restituisce il primo valore "falsy".</li><li>Usare l'operatore per assegnare valori di default senza considerare che valori come `0`, `''`, o `false` sono considerati "falsy".</li></ul></li><li>Impatto sulle performance:<ul><li>Può migliorare le performance evitando valutazioni superflue grazie al "short-circuiting".</li><li>Generalmente ha un impatto minimo sulle performance rispetto ad altre operazioni logiche.</li></ul></li><li>Conclusioni: L'operatore OR logico (`||`) è essenziale per la valutazione di condizioni multiple in JavaScript. La sua capacità di restituire il primo valore "truthy" o l'ultimo valore "falsy" permette di scrivere controlli condizionali efficienti e di evitare esecuzioni superflue grazie al "short-circuiting". È particolarmente utile per fornire valori di fallback o predefiniti.</li></ol></details><details><summary>NOT Logico<span class="tag-description" aria-label="descrizione tag">Inverte il valore di verità di un'espressione.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore NOT logico (`!`) in JavaScript è utilizzato per invertire il valore di verità di un'espressione. Se l'espressione è "truthy", diventa "falsy", e viceversa.</li><li>A cosa serve: Serve a verificare la negazione di una condizione. Viene comunemente utilizzato per controllare se un'espressione non è vera o per convertire un valore "truthy" o "falsy" in un valore booleano.</li><li>Quando usarlo: Utilizzalo quando vuoi negare una condizione o verificare se un valore non soddisfa una determinata condizione. È spesso usato in dichiarazioni condizionali e per la conversione esplicita di valori in booleani.</li><li>Rilevanza semantica: Indica che l'operazione è vera solo se l'espressione originale è falsa. È un modo semplice per esprimere una condizione inversa.</li><li>Principali caratteristiche:<ul><li>Inverte il valore di verità di un'espressione.</li><li>Converte qualsiasi valore in un booleano (true o false).</li><li>Può essere combinato due volte (`!!`) per forzare la conversione di un valore in un booleano.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usare l'operatore NOT (`!`) per invertire il valore di condizioni booleane.</li><li>Sfruttare la doppia negazione (`!!`) per convertire un valore in un booleano.</li><li>Evitare di abusare della doppia negazione per non ridurre la leggibilità del codice.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Inversione di una condizione
    let isOnline = false;
    if (!isOnline) {
        console.log('L\'utente non è online');
    }
    
    // Conversione di un valore in booleano
    let inputValue = 'Hello';
    console.log(!inputValue); // false, perché 'Hello' è "truthy"
    
    // Doppia negazione per ottenere un valore booleano
    console.log(!!inputValue); // true, forza la conversione in booleano
    
    // Uso in un'espressione complessa
    let isLoggedIn = true;
    let hasAccess = false;
    if (!(isLoggedIn &amp;&amp; hasAccess)) {
        console.log('Accesso negato');
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare costrutti condizionali tradizionali per controllare il valore di una variabile senza l'inversione esplicita.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere il risultato dell'operatore NOT (`!`) con il valore originale.</li><li>Abusare della doppia negazione (`!!`), riducendo la leggibilità del codice.</li><li>Non considerare che l'operatore inverte qualsiasi valore in un booleano, inclusi valori numerici e stringhe.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore NOT (`!`) ha un impatto minimo sulle performance, in linea con altri operatori logici.</li><li>La doppia negazione (`!!`) è generalmente utilizzata per la conversione rapida dei valori, senza impatti significativi sulle prestazioni.</li></ul></li><li>Conclusioni: L'operatore NOT logico (`!`) è uno strumento fondamentale in JavaScript per invertire il valore di verità di un'espressione o convertire un valore in un booleano. La sua versatilità lo rende essenziale nei controlli condizionali e nella gestione dei valori "truthy" e "falsy". Tuttavia, è importante utilizzarlo con moderazione per mantenere la chiarezza del codice.</li></ol></details><details><summary>Operatore Ternario<span class="tag-description" aria-label="descrizione tag">Esegue un'operazione in base a una condizione.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore ternario (`? :`) in JavaScript è un'operazione condizionale che valuta un'espressione e restituisce un valore se la condizione è vera, altrimenti restituisce un altro valore se la condizione è falsa. La sintassi è: `condizione ? valoreSeVero : valoreSeFalso`.</li><li>A cosa serve: Serve a scrivere espressioni condizionali compatte, simili a un'istruzione `if-else`, ma in una sola riga di codice. È comunemente utilizzato per assegnare valori in base a una condizione o per gestire il rendering di contenuti dinamici.</li><li>Quando usarlo: Utilizzalo quando hai bisogno di una semplice valutazione condizionale che può essere espressa in una singola riga. È ideale per assegnare valori o eseguire brevi operazioni condizionali in modo conciso.</li><li>Rilevanza semantica: L'operatore ternario permette di eseguire un'operazione in base a una condizione in modo sintetico, mantenendo il codice più leggibile e compatto rispetto a un'istruzione `if-else` completa.</li><li>Principali caratteristiche:<ul><li>Restituisce un valore in base alla condizione: se vera, restituisce il primo valore; se falsa, il secondo.</li><li>Può essere nidificato, ma è sconsigliato perché riduce la leggibilità del codice.</li><li>Spesso utilizzato per assegnare valori condizionali o eseguire operazioni semplici.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizza l'operatore ternario solo per operazioni semplici, come l'assegnazione di valori o brevi condizioni.</li><li>Evita di nidificare più operatori ternari, poiché può rendere il codice difficile da comprendere.</li><li>Usalo per rendere il codice più conciso, ma considera la leggibilità quando le condizioni diventano complesse.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Assegnazione di un valore in base a una condizione
    let age = 18;
    let canVote = age &gt;= 18 ? 'Può votare' : 'Non può votare';
    console.log(canVote); // 'Può votare'
    
    // Operazione condizionale in una funzione
    function getDiscount(price) {
        return price &gt; 100 ? 'Sconto del 10%' : 'Nessuno sconto';
    }
    console.log(getDiscount(120)); // 'Sconto del 10%'
    
    // Uso con valori "truthy" e "falsy"
    let userName = null;
    let displayName = userName ? userName : 'Ospite';
    console.log(displayName); // 'Ospite'
    
    // Valore predefinito con operatore OR
    let inputValue = '';
    let output = inputValue || 'Valore di default';
    console.log(output); // 'Valore di default'
                                </code></pre></div></li><li>Alternative:<ul><li>Usare un'istruzione `if-else` tradizionale per condizioni più complesse.</li><li>Utilizzare l'operatore OR (`||`) o AND (`&&`) per assegnazioni condizionali semplici.</li></ul></li><li>Potenziali errori comuni:<ul><li>Nidificare operatori ternari, causando una lettura complessa e confusa.</li><li>Confondere l'ordine degli operandi, il che porta a risultati inattesi.</li><li>Non considerare che l'operatore ternario restituisce sempre un valore, quindi deve essere usato in contesti appropriati.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore ternario è efficiente e ha un impatto minimo sulle performance.</li><li>Può migliorare la leggibilità e ridurre il numero di righe di codice rispetto a un'istruzione `if-else`.</li></ul></li><li>Conclusioni: L'operatore ternario (`? :`) è uno strumento potente per scrivere condizioni compatte in JavaScript. È ideale per assegnare valori in base a una condizione o per brevi valutazioni condizionali, migliorando la concisione del codice. Tuttavia, è importante evitare nidificazioni eccessive e mantenere il codice leggibile.</li></ol></details><details><summary>Operatore di Concatenazione Opzionale<span class="tag-description" aria-label="descrizione tag">Accesso sicuro a proprietà annidate senza causare errori.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di concatenazione opzionale (`?.`) in JavaScript consente di accedere in modo sicuro a proprietà di oggetti annidati. Se il valore alla sinistra dell'operatore è `null` o `undefined`, l'espressione restituisce `undefined` senza generare errori, evitando così errori di tipo "Cannot read property of undefined".</li><li>A cosa serve: Serve a prevenire errori durante l'accesso a proprietà annidate di oggetti che potrebbero non esistere, fornendo un modo sicuro per verificare la presenza di una proprietà prima di accedere al suo valore.</li><li>Quando usarlo: Utilizzalo quando lavori con oggetti annidati o strutture di dati complesse in cui una o più proprietà potrebbero non essere definite. È particolarmente utile per accedere a proprietà facoltative in dati provenienti da fonti esterne come API.</li><li>Rilevanza semantica: Indica che l'accesso alla proprietà è condizionato: verrà effettuato solo se l'oggetto o la proprietà esistono. Altrimenti, l'espressione restituisce `undefined` invece di sollevare un errore.</li><li>Principali caratteristiche:<ul><li>Permette l'accesso condizionale a proprietà annidate, chiamate di funzioni e accesso agli elementi degli array.</li><li>Restituisce `undefined` se il valore alla sinistra dell'operatore è `null` o `undefined`.</li><li>Non previene errori in altri casi, come tentativi di accedere a proprietà non esistenti su un oggetto definito.</li></ul></li><li>Compatibilità:<ul><li>Supportato nelle versioni più recenti di JavaScript (ES2020 e successive).</li><li>Compatibile con la maggior parte dei browser moderni, ma non con versioni più vecchie di Internet Explorer.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usalo per evitare errori durante l'accesso a dati facoltativi o proprietà annidate.</li><li>Non abusare dell'operatore in contesti dove l'assenza di una proprietà deve essere gestita esplicitamente.</li><li>Combinare con l'operatore di coalescenza nulla (`??`) per fornire valori di fallback in caso di `undefined`.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Accesso sicuro a una proprietà annidata
    let user = { profile: { name: 'Mario' } };
    console.log(user.profile?.name); // 'Mario'
    console.log(user.address?.city); // undefined, 'address' non esiste
    
    // Chiamata di una funzione in modo sicuro
    let obj = { greet: () =&gt; 'Ciao' };
    console.log(obj.greet?.()); // 'Ciao'
    console.log(obj.sayGoodbye?.()); // undefined, 'sayGoodbye' non esiste
    
    // Accesso sicuro agli elementi di un array
    let fruits = null;
    console.log(fruits?.[0]); // undefined, 'fruits' è null
    
    // Combinazione con l'operatore di coalescenza nulla
    let result = user.profile?.age ?? 'Età sconosciuta';
    console.log(result); // 'Età sconosciuta', 'age' non è definito
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare controlli condizionali espliciti con l'operatore `&&` per verificare la presenza delle proprietà.</li><li>Gestire manualmente gli errori con `try-catch` se necessario.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'uso dell'operatore con l'accesso a proprietà definite ma non presenti sull'oggetto (non risolve questi casi).</li><li>Assumere che l'operatore possa gestire qualsiasi tipo di errore durante l'accesso alle proprietà.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore ha un impatto minimo sulle performance, poiché si limita a valutare la presenza di valori `null` o `undefined`.</li><li>Può migliorare la stabilità del codice riducendo la necessità di verifiche condizionali esplicite.</li></ul></li><li>Conclusioni: L'operatore di concatenazione opzionale (`?.`) è uno strumento potente per accedere in modo sicuro a proprietà annidate o opzionali in JavaScript. Riduce la probabilità di errori durante l'accesso a dati complessi e migliora la leggibilità del codice. Tuttavia, è importante comprenderne i limiti e usarlo in modo appropriato.</li></ol></details><details><summary>Operatore di Coalescenza Nulla<span class="tag-description" aria-label="descrizione tag">Restituisce il primo operando che non è null o undefined.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di coalescenza nulla (`??`) in JavaScript restituisce il primo operando che non è `null` o `undefined`. È utilizzato per fornire un valore di default quando una variabile potrebbe avere uno di questi due valori.</li><li>A cosa serve: Serve a gestire valori opzionali, evitando che espressioni restituiscano `null` o `undefined` in caso di assenza di un valore. Viene comunemente usato per fornire valori di fallback in modo più sicuro rispetto all'operatore OR (`||`), che considera "falsy" anche valori come `0`, `''`, o `false`.</li><li>Quando usarlo: Utilizzalo quando vuoi assegnare un valore di default solo se una variabile è `null` o `undefined`, senza sostituire valori "falsy" come `0`, `false`, o stringhe vuote.</li><li>Rilevanza semantica: Indica che un valore alternativo verrà utilizzato solo in caso di `null` o `undefined`, rendendo l'assegnazione condizionale più precisa rispetto all'operatore OR (`||`), che può restituire risultati inattesi per altri valori "falsy".</li><li>Principali caratteristiche:<ul><li>Restituisce il primo valore non `null` o `undefined` trovato.</li><li>Non considera come "falsy" valori come `0`, `false`, o stringhe vuote.</li><li>È utile per assegnare valori di default in modo sicuro e preciso.</li></ul></li><li>Compatibilità:<ul><li>Supportato nelle versioni più recenti di JavaScript (ES2020 e successive).</li><li>Compatibile con la maggior parte dei browser moderni, ma non con versioni più vecchie di Internet Explorer.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usalo per fornire valori di fallback in caso di valori `null` o `undefined`.</li><li>Evita di utilizzarlo per valori che potrebbero essere "falsy" ma validi, come `0` o `false`.</li><li>Combinalo con l'operatore di concatenazione opzionale (`?.`) per gestire valori opzionali e annidati in modo sicuro.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Assegnazione di un valore di default
    let userAge = null;
    let age = userAge ?? 18;
    console.log(age); // 18, perché userAge è null
    
    // Valore "falsy" considerato valido
    let input = '';
    let value = input ?? 'Valore di default';
    console.log(value); // '', perché input non è null o undefined
    
    // Combinazione con l'operatore di concatenazione opzionale
    let user = { preferences: { theme: null } };
    let theme = user.preferences?.theme ?? 'light';
    console.log(theme); // 'light', perché il tema è null
    
    // Differenza rispetto all'operatore OR
    let count = 0;
    let result = count || 10;
    console.log(result); // 10, perché 0 è "falsy"
    
    result = count ?? 10;
    console.log(result); // 0, perché count non è null o undefined
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore OR (`||`) per valori che possono essere "falsy" ma accettabili come `null` o `undefined`.</li><li>Gestire manualmente le condizioni con istruzioni `if-else` per maggiore controllo.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere l'uso dell'operatore con l'OR (`||`), che considera "falsy" anche `0`, `''`, o `false`.</li><li>Utilizzare `??` per valori che dovrebbero essere gestiti in modo diverso da `null` o `undefined`.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore ha un impatto minimo sulle performance, essendo una semplice verifica di `null` o `undefined`.</li><li>Può migliorare la leggibilità del codice e ridurre la necessità di controlli espliciti.</li></ul></li><li>Conclusioni: L'operatore di coalescenza nulla (`??`) è utile per gestire in modo sicuro e preciso valori opzionali o assenti in JavaScript. Permette di fornire un valore di default solo quando una variabile è `null` o `undefined`, evitando risultati inattesi che possono derivare dall'uso dell'operatore OR (`||`). È ideale per assegnazioni condizionali concise e più affidabili.</li></ol></details><details><summary>Operatore di Diffusione (Spread)<span class="tag-description" aria-label="descrizione tag">Espande elementi di array o proprietà di oggetti.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore di diffusione (`...`) in JavaScript permette di espandere elementi di array o proprietà di oggetti. È usato per copiare, concatenare o passare gli elementi di un array e per clonare o unire oggetti in modo semplice e leggibile.</li><li>A cosa serve: Serve a lavorare con array e oggetti in modo più conciso. Permette di creare copie superficiali, combinare array e oggetti, e passare un numero variabile di argomenti a una funzione. È particolarmente utile per manipolare strutture di dati in modo elegante e moderno.</li><li>Quando usarlo: Utilizzalo quando hai bisogno di copiare array o oggetti, concatenare array, aggiungere elementi a un array o unire oggetti. È ideale anche per passare argomenti a una funzione o convertire una struttura iterabile in un array.</li><li>Rilevanza semantica: Indica che un array o un oggetto devono essere "diffusi" o espansi per includere i loro elementi o proprietà in un'altra struttura, rendendo le operazioni di manipolazione dei dati più esplicite e leggibili.</li><li>Principali caratteristiche:<ul><li>Espande elementi di array e proprietà di oggetti.</li><li>Consente di creare copie superficiali di array e oggetti (non profonde).</li><li>Può essere utilizzato con funzioni per passare un numero variabile di argomenti.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni moderne di JavaScript (ES6 e successive).</li><li>Compatibile con i browser moderni, ma potrebbe richiedere un transpiler come Babel per versioni più vecchie.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usalo per clonare array e oggetti quando non è necessaria una copia profonda.</li><li>Utilizzalo per unire array o oggetti in modo conciso.</li><li>Evita di utilizzarlo per oggetti annidati se hai bisogno di una copia profonda; in tal caso, considera l'uso di altre tecniche come `JSON.parse(JSON.stringify(obj))` o librerie esterne.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Copiare un array
    let originalArray = [1, 2, 3];
    let copiedArray = [...originalArray];
    console.log(copiedArray); // [1, 2, 3]
    
    // Concatenare array
    let array1 = [1, 2];
    let array2 = [3, 4];
    let concatenatedArray = [...array1, ...array2];
    console.log(concatenatedArray); // [1, 2, 3, 4]
    
    // Aggiungere elementi a un array
    let arrayWithExtra = [...originalArray, 4, 5];
    console.log(arrayWithExtra); // [1, 2, 3, 4, 5]
    
    // Clonare un oggetto
    let originalObject = { a: 1, b: 2 };
    let copiedObject = { ...originalObject };
    console.log(copiedObject); // { a: 1, b: 2 }
    
    // Unire oggetti
    let obj1 = { a: 1 };
    let obj2 = { b: 2 };
    let mergedObject = { ...obj1, ...obj2 };
    console.log(mergedObject); // { a: 1, b: 2 }
    
    // Usare con funzioni
    function sum(x, y, z) {
        return x + y + z;
    }
    let numbers = [1, 2, 3];
    console.log(sum(...numbers)); // 6
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare metodi come `Array.concat()` o `Object.assign()` per concatenare array o unire oggetti.</li><li>Usare cicli `for` o metodi di iterazione per copiare manualmente gli elementi o le proprietà.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere la copia superficiale con la copia profonda, causando modifiche involontarie agli oggetti annidati.</li><li>Usare l'operatore di diffusione su oggetti non iterabili, come numeri o stringhe.</li><li>Non considerare che la diffusione crea solo copie superficiali degli oggetti, il che può portare a effetti collaterali indesiderati.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore di diffusione è generalmente efficiente per la copia e l'unione di array e oggetti di piccole e medie dimensioni.</li><li>Per oggetti di grandi dimensioni o operazioni di copia profonda, considera l'uso di tecniche più specifiche o librerie.</li></ul></li><li>Conclusioni: L'operatore di diffusione (`...`) è uno strumento versatile e potente in JavaScript per la manipolazione di array e oggetti. Consente di scrivere codice più leggibile e conciso, semplificando operazioni comuni come la copia, la concatenazione e l'unione di dati. Tuttavia, è importante comprendere le limitazioni delle copie superficiali e scegliere l'approccio più adatto per le strutture di dati complesse.</li></ol></details><details><summary>Operatore typeof<span class="tag-description" aria-label="descrizione tag">Restituisce il tipo di dato di un'espressione.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore `typeof` in JavaScript restituisce una stringa che indica il tipo di dato di un'espressione o variabile. Può essere utilizzato per verificare il tipo di variabili primitive e oggetti.</li><li>A cosa serve: Serve a determinare il tipo di una variabile o di un'espressione. È utile per controllare i tipi di dati prima di eseguire operazioni specifiche o per il debug del codice.</li><li>Quando usarlo: Utilizzalo quando vuoi verificare il tipo di una variabile per garantire che il codice funzioni correttamente con dati di tipi diversi. È ideale per eseguire controlli condizionali basati sul tipo.</li><li>Rilevanza semantica: L'operatore `typeof` è semantico poiché restituisce una descrizione del tipo di dato in una stringa, come "number", "string", "boolean", "object", "undefined", "function" o "symbol".</li><li>Principali caratteristiche:<ul><li>Restituisce una stringa che rappresenta il tipo di dato.</li><li>Può essere utilizzato con variabili, valori letterali ed espressioni.</li><li>Restituisce "object" per `null`, il che è considerato un comportamento storico anomalo.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Utilizza `typeof` per verificare se una variabile è definita o per controllare il tipo di dati prima di operare su di essi.</li><li>Evita di usare `typeof` per controllare `null`, poiché restituisce "object". Invece, usa un controllo esplicito (`value === null`).</li><li>Usalo per verificare se una funzione è effettivamente una funzione, confrontando `typeof variable === "function"`.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Verifica del tipo di una variabile
    let name = 'Alice';
    console.log(typeof name); // "string"
    
    // Controllo di una funzione
    function greet() {
        return 'Hello!';
    }
    console.log(typeof greet); // "function"
    
    // Controllo di una variabile non definita
    let age;
    console.log(typeof age); // "undefined"
    
    // Uso con null (anomalia storica)
    let value = null;
    console.log(typeof value); // "object", anche se dovrebbe essere "null"
    
    // Verifica di un numero
    let count = 10;
    console.log(typeof count); // "number"
    
    // Controllo di un booleano
    let isActive = true;
    console.log(typeof isActive); // "boolean"
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare il controllo diretto per verificare valori specifici, ad esempio `Array.isArray()` per verificare se un oggetto è un array.</li><li>Usare `instanceof` per verificare se un oggetto è un'istanza di una determinata classe.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere il risultato di `typeof` per `null`, che restituisce "object".</li><li>Non considerare che `typeof` restituisce "function" per le funzioni, ma anche per classi e metodi.</li><li>Usare `typeof` per controllare array o tipi complessi, dove invece è preferibile `Array.isArray()` o altri metodi specifici.</li></ul></li><li>Impatto sulle performance:<ul><li>L'operatore `typeof` è molto veloce e ha un impatto minimo sulle performance.</li><li>È utile per eseguire controlli di tipo in contesti di debug o per prevenire errori di tipo nel codice.</li></ul></li><li>Conclusioni: L'operatore `typeof` è uno strumento essenziale per determinare il tipo di dato di una variabile o espressione in JavaScript. È utile per i controlli condizionali e per prevenire errori durante l'esecuzione del codice. Tuttavia, è importante comprendere i limiti e comportamenti particolari, come il caso di `null` che restituisce "object".</li></ol></details><details><summary>Operatore instanceof<span class="tag-description" aria-label="descrizione tag">Verifica se un oggetto è un'istanza di una determinata classe o costruttore.</span><div class="tag-group" aria-label="gruppo">3. Operatore</div></summary><ol><li>Cos'è: L'operatore `instanceof` in JavaScript verifica se un oggetto è un'istanza di una determinata classe o è stato creato tramite una funzione costruttore specifica. Restituisce un valore booleano (`true` o `false`).</li><li>A cosa serve: Serve a controllare se un oggetto è un'istanza di una classe specifica, inclusi oggetti creati tramite funzioni costruttore personalizzate o classi native di JavaScript. È utile per eseguire verifiche di tipo avanzate.</li><li>Quando usarlo: Utilizzalo quando hai bisogno di verificare se un oggetto appartiene a una gerarchia di classi o è stato creato tramite un costruttore specifico. È particolarmente utile per gestire comportamenti diversi in base al tipo di oggetto.</li><li>Rilevanza semantica: L'operatore `instanceof` è semantico in quanto indica chiaramente che l'operazione serve a verificare l'appartenenza di un oggetto a una determinata classe o costruttore.</li><li>Principali caratteristiche:<ul><li>Restituisce `true` se l'oggetto è un'istanza del costruttore specificato, altrimenti `false`.</li><li>Funziona anche per oggetti ereditati, verificando la catena di prototipi.</li><li>Non può essere utilizzato per tipi primitivi come stringhe o numeri.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usalo per verificare se un oggetto è un'istanza di una classe specifica prima di eseguire operazioni che richiedono quella classe.</li><li>Non utilizzarlo per verificare tipi primitivi; preferisci `typeof` per questi casi.</li><li>Combinare `instanceof` con altre verifiche, se necessario, per gestire casi complessi o eredità multiple.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Verifica di un'istanza di una classe
    class Person {
        constructor(name) {
            this.name = name;
        }
    }
    let john = new Person('John');
    console.log(john instanceof Person); // true
    
    // Verifica con classi native
    let date = new Date();
    console.log(date instanceof Date); // true
    console.log(date instanceof Object); // true, Date eredita da Object
    
    // Oggetto semplice non istanza di una classe
    let obj = {};
    console.log(obj instanceof Person); // false
    
    // Funzione costruttore
    function Car(make) {
        this.make = make;
    }
    let myCar = new Car('Toyota');
    console.log(myCar instanceof Car); // true
    
    // Verifica su tipi primitivi
    console.log('Hello' instanceof String); // false, le stringhe primitive non sono istanze di String
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare `typeof` per controllare tipi primitivi o valori semplici.</li><li>Usare `Object.prototype.toString.call()` per verificare tipi di oggetti complessi, come array o oggetti built-in.</li></ul></li><li>Potenziali errori comuni:<ul><li>Confondere `instanceof` con `typeof`, che è utilizzato per verificare tipi primitivi.</li><li>Utilizzare `instanceof` con tipi primitivi come stringhe o numeri, che non sono considerati istanze di un costruttore.</li><li>Dimenticare che `instanceof` verifica anche la catena di prototipi, il che può portare a risultati inattesi con classi o oggetti personalizzati.</li></ul></li><li>Impatto sulle performance:<ul><li>`instanceof` è generalmente veloce, ma l'impatto sulle performance può aumentare con gerarchie di prototipi molto profonde.</li><li>È consigliabile utilizzarlo per verifiche di tipo specifiche e non come sostituto di altre verifiche di tipo più appropriate.</li></ul></li><li>Conclusioni: L'operatore `instanceof` è uno strumento potente in JavaScript per verificare se un oggetto è un'istanza di una classe o di un costruttore specifico. Fornisce un modo preciso per gestire controlli di tipo basati sulla gerarchia di prototipi, ma è importante comprenderne i limiti e utilizzarlo correttamente, soprattutto quando si lavora con tipi primitivi o classi personalizzate.</li></ol></details><details><summary>if<span class="tag-description" aria-label="descrizione tag">Esegue un blocco di codice solo se una condizione è vera.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `if` in JavaScript permette di eseguire un blocco di codice solo se una determinata condizione è vera. È utilizzata per creare percorsi condizionali nel flusso di esecuzione del programma.</li><li>A cosa serve: Serve a controllare il flusso del programma, eseguendo determinate operazioni solo quando una condizione specifica è soddisfatta. Consente di gestire logica condizionale, verificando se una variabile o un'espressione rispetta determinati criteri.</li><li>Quando usarlo: Utilizzalo quando vuoi eseguire codice solo se una determinata condizione è vera. È ideale per validazioni, controllo di stato, o esecuzione di codice differente in base a variabili o input.</li><li>Rilevanza semantica: L'istruzione `if` permette di esprimere chiaramente che un blocco di codice deve essere eseguito solo se una condizione specifica è vera, rendendo la logica del programma più comprensibile.</li><li>Principali caratteristiche:<ul><li>Valuta un'espressione booleana per decidere se eseguire il blocco di codice associato.</li><li>Può essere utilizzato insieme a `else` e `else if` per creare percorsi condizionali multipli.</li><li>Supporta condizioni annidate per verificare più criteri complessi.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa l'istruzione `if` per condizioni semplici e lineari; considera altre strutture come `switch` per condizioni complesse con molti casi.</li><li>Evita annidamenti profondi di istruzioni `if` per mantenere il codice leggibile.</li><li>Utilizza l'operatore ternario (`? :`) per condizioni semplici che restituiscono un valore.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Controllo di una condizione
    let age = 18;
    if (age &gt;= 18) {
        console.log('Può votare');
    }
    
    // Uso di if con else
    let score = 75;
    if (score &gt;= 60) {
        console.log('Promosso');
    } else {
        console.log('Bocciato');
    }
    
    // Uso di else if per più condizioni
    let temperature = 30;
    if (temperature &gt; 30) {
        console.log('Fa molto caldo');
    } else if (temperature &lt; 15) {
        console.log('Fa freddo');
    } else {
        console.log('Temperatura piacevole');
    }
    
    // Condizioni annidate
    let isLoggedIn = true;
    let hasAccess = false;
    if (isLoggedIn) {
        if (hasAccess) {
            console.log('Accesso consentito');
        } else {
            console.log('Accesso negato');
        }
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare l'operatore ternario (`? :`) per condizioni semplici che restituiscono un valore.</li><li>Usare l'istruzione `switch` per gestire più condizioni in base al valore di una variabile.</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare di usare parentesi graffe (`{}`) quando necessarie, soprattutto con più istruzioni all'interno di un `if`.</li><li>Non considerare i valori "falsy" o "truthy" in JavaScript, che possono influenzare l'esito di una condizione.</li><li>Annidare troppe istruzioni `if`, rendendo il codice complesso e difficile da leggere.</li></ul></li><li>Impatto sulle performance:<ul><li>Le istruzioni `if` sono efficienti, ma annidamenti profondi o molteplici verifiche possono influenzare la leggibilità più che le performance.</li><li>Usare strutture condizionali appropriate può migliorare la chiarezza del codice senza impatti significativi sulle performance.</li></ul></li><li>Conclusioni: L'istruzione `if` è uno strumento fondamentale per il controllo del flusso in JavaScript. Permette di eseguire codice condizionale in modo chiaro e leggibile, gestendo logiche diverse in base alle condizioni specifiche. È importante utilizzarla con attenzione per evitare complessità eccessive e mantenere il codice comprensibile.</li></ol></details><details><summary>else<span class="tag-description" aria-label="descrizione tag">Esegue un blocco di codice se la condizione dell'if è falsa.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `else` viene utilizzata per eseguire un blocco di codice quando la condizione di un'istruzione `if` è falsa. Rappresenta una condizione di fallback che viene eseguita solo se tutte le altre condizioni precedenti non sono soddisfatte.</li><li>A cosa serve: Serve a gestire situazioni in cui una condizione `if` non è vera, fornendo un percorso alternativo nel flusso del programma. È utile per garantire che un'operazione venga eseguita in tutti i casi, anche quando le condizioni specifiche non sono soddisfatte.</li><li>Quando usarlo: Utilizzalo quando vuoi definire un comportamento di default che viene eseguito se le condizioni specificate non sono soddisfatte.</li><li>Rilevanza semantica: L'istruzione `else` rende chiaro che il codice deve essere eseguito solo se tutte le condizioni precedenti sono false, fornendo un'opzione di fallback.</li><li>Principali caratteristiche:<ul><li>Viene sempre associata a un'istruzione `if`.</li><li>Esegue un blocco di codice solo se la condizione dell'`if` è falsa.</li><li>Non richiede una condizione esplicita, poiché rappresenta l'alternativa.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `else` per gestire percorsi alternativi e fornire un'opzione di fallback.</li><li>Evita di abusare dell'uso di `else` annidati per mantenere il codice leggibile.</li><li>Considera l'uso di `return` o `break` all'interno di un blocco `if` per ridurre la necessità di un `else`.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso semplice di if-else
    let score = 55;
    if (score &gt;= 60) {
        console.log('Promosso');
    } else {
        console.log('Bocciato');
    }
    
    // Uso di else come fallback
    let isLoggedIn = false;
    if (isLoggedIn) {
        console.log('Benvenuto!');
    } else {
        console.log('Accesso negato. Effettua il login.');
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Usare un'istruzione `if` separata per gestire la logica alternativa.</li><li>Utilizzare l'operatore ternario per condizioni semplici che restituiscono un valore.</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare di associare l'`else` a un'istruzione `if`.</li><li>Creare troppi annidamenti, rendendo il codice difficile da leggere.</li></ul></li><li>Impatto sulle performance:<ul><li>L'istruzione `else` ha un impatto minimo sulle performance.</li><li>Può migliorare la leggibilità del codice quando viene usata correttamente.</li></ul></li><li>Conclusioni: L'istruzione `else` è utile per fornire un'alternativa nel flusso di esecuzione del programma. Consente di definire percorsi di fallback che vengono eseguiti se le condizioni `if` non sono soddisfatte, rendendo il codice più robusto e chiaro.</li></ol></details><details><summary>else if<span class="tag-description" aria-label="descrizione tag">Verifica condizioni aggiuntive se le precedenti sono false.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `else if` consente di specificare condizioni aggiuntive che vengono verificate solo se le precedenti sono false. È utilizzata per gestire più condizioni in modo sequenziale.</li><li>A cosa serve: Serve a gestire situazioni in cui esistono più condizioni possibili. Permette di verificare condizioni alternative e eseguire blocchi di codice diversi in base a queste condizioni.</li><li>Quando usarlo: Utilizzalo quando hai bisogno di gestire più di due percorsi condizionali nel flusso del programma.</li><li>Rilevanza semantica: L'istruzione `else if` rende il codice più leggibile, permettendo di esprimere chiaramente che esistono condizioni alternative rispetto alla condizione iniziale.</li><li>Principali caratteristiche:<ul><li>Viene usata dopo un'istruzione `if` e prima di un eventuale `else`.</li><li>Consente di gestire percorsi condizionali multipli.</li><li>Verifica la condizione solo se tutte le condizioni precedenti sono false.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `else if` per condizioni multiple ma cerca di non annidare troppe istruzioni per mantenere la leggibilità.</li><li>Considera l'uso di `switch` se hai molte condizioni che si basano sullo stesso valore.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso di else if per più condizioni
    let grade = 85;
    if (grade &gt;= 90) {
        console.log('Ottimo');
    } else if (grade &gt;= 70) {
        console.log('Buono');
    } else if (grade &gt;= 50) {
        console.log('Sufficiente');
    } else {
        console.log('Insufficiente');
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare un'istruzione `switch` per condizioni basate su un singolo valore.</li><li>Combinare `if` semplici per condizioni che non sono direttamente correlate.</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare di associare correttamente le parentesi graffe, causando errori di sintassi.</li><li>Scrivere troppi `else if`, riducendo la leggibilità del codice.</li></ul></li><li>Impatto sulle performance:<ul><li>L'istruzione `else if` è efficiente, ma le catene lunghe possono influire sulla leggibilità più che sulle performance.</li></ul></li><li>Conclusioni: L'istruzione `else if` è utile per gestire più condizioni in modo ordinato e sequenziale. Permette di verificare condizioni alternative e aggiuntive rispetto a un'istruzione `if`, rendendo il flusso del programma più flessibile.</li></ol></details><details><summary>switch<span class="tag-description" aria-label="descrizione tag">Esegue un blocco di codice in base al valore di un'espressione.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `switch` consente di eseguire blocchi di codice diversi in base al valore di un'espressione. È una struttura condizionale che può gestire molti casi in modo efficiente.</li><li>A cosa serve: Serve a sostituire lunghe catene di `else if` quando si desidera confrontare il valore di una variabile con diversi casi possibili. Rende il codice più leggibile e strutturato.</li><li>Quando usarlo: Utilizzalo quando hai più condizioni basate sullo stesso valore e desideri gestire casi multipli in modo organizzato.</li><li>Rilevanza semantica: L'istruzione `switch` indica chiaramente che il valore di una variabile è confrontato con più casi specifici, eseguendo il codice associato al caso corrispondente.</li><li>Principali caratteristiche:<ul><li>Confronta il valore di un'espressione con vari casi (`case`).</li><li>Può includere un `default` che viene eseguito se nessun caso corrisponde.</li><li>Richiede esplicitamente l'uso di `break` per evitare l'esecuzione dei casi successivi.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `switch` per confrontare lo stesso valore con molteplici casi.</li><li>Ricorda di usare `break` per evitare la "fallthrough" accidentale tra i casi.</li><li>Considera l'uso del blocco `default` per gestire i casi non previsti.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso di switch per controllare il giorno della settimana
    let day = 3;
    switch (day) {
        case 1:
            console.log('Lunedì');
            break;
        case 2:
            console.log('Martedì');
            break;
        case 3:
            console.log('Mercoledì');
            break;
        case 4:
            console.log('Giovedì');
            break;
        case 5:
            console.log('Venerdì');
            break;
        default:
            console.log('Fine settimana');
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare catene di `else if` per condizioni complesse o basate su più variabili.</li><li>Usare un oggetto di mapping per associare valori a funzioni o azioni specifiche.</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare il `break`, causando l'esecuzione di più casi (fallthrough).</li><li>Non utilizzare il blocco `default`, perdendo l'opportunità di gestire valori imprevisti.</li></ul></li><li>Impatto sulle performance:<ul><li>L'istruzione `switch` è generalmente efficiente, specialmente quando si hanno molti casi da verificare.</li><li>Può migliorare la leggibilità del codice rispetto a catene lunghe di `else if`.</li></ul></li><li>Conclusioni: L'istruzione `switch` offre un modo strutturato per gestire molteplici condizioni basate sul valore di una variabile. È ideale per semplificare il codice rispetto alle catene di `else if` e fornisce un'esecuzione condizionale più organizzata e leggibile.</li></ol></details><details><summary>break<span class="tag-description" aria-label="descrizione tag">Interrompe un ciclo o una struttura di controllo del flusso.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `break` in JavaScript viene utilizzata per interrompere immediatamente l'esecuzione di un ciclo (`for`, `while`, `do...while`) o di una struttura di controllo del flusso come un `switch`, uscendo dall'iterazione o dal blocco di codice corrente.</li><li>A cosa serve: Serve a interrompere l'esecuzione di un ciclo o blocco quando una determinata condizione è soddisfatta. È utile per evitare iterazioni aggiuntive non necessarie o uscire anticipatamente da un `switch` case.</li><li>Quando usarlo: Utilizzalo quando vuoi uscire da un ciclo in risposta a una condizione specifica o per interrompere l'esecuzione di un blocco `switch` una volta trovato un caso corrispondente.</li><li>Rilevanza semantica: L'istruzione `break` indica chiaramente che il flusso di esecuzione deve essere interrotto, permettendo di saltare il resto del ciclo o del blocco.</li><li>Principali caratteristiche:<ul><li>Interrompe immediatamente l'esecuzione del ciclo o del blocco corrente.</li><li>Viene comunemente usato nei cicli e nei blocchi `switch` per evitare esecuzioni non necessarie.</li><li>Non può essere utilizzato al di fuori di un ciclo o blocco di controllo.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `break` per uscire da un ciclo quando una condizione è soddisfatta, migliorando le performance.</li><li>Utilizzalo nei blocchi `switch` per evitare il "fallthrough" tra i casi.</li><li>Non usare `break` al di fuori di un contesto valido, come un ciclo o un `switch`.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso di break in un ciclo for
    for (let i = 0; i &lt; 10; i++) {
        if (i === 5) {
            break; // Esce dal ciclo quando i è uguale a 5
        }
        console.log(i);
    }
    
    // Uso di break in un blocco switch
    let day = 3;
    switch (day) {
        case 1:
            console.log('Lunedì');
            break;
        case 2:
            console.log('Martedì');
            break;
        case 3:
            console.log('Mercoledì');
            break; // Esce dopo aver trovato il caso corrispondente
        default:
            console.log('Giorno non valido');
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Usare un flag per controllare l'uscita dal ciclo, anche se l'uso di `break` è più diretto.</li><li>Evitare l'uso di `break` in cicli annidati e preferire l'uso di funzioni per maggiore chiarezza.</li></ul></li><li>Potenziali errori comuni:<ul><li>Usare `break` al di fuori di un ciclo o blocco `switch`, causando un errore di sintassi.</li><li>Non utilizzare `break` nei blocchi `switch`, causando il "fallthrough" indesiderato tra i casi.</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di `break` può migliorare le performance interrompendo i cicli non appena viene soddisfatta una condizione.</li></ul></li><li>Conclusioni: L'istruzione `break` è uno strumento essenziale per controllare il flusso in JavaScript, consentendo di uscire da cicli e blocchi di controllo in modo efficiente. È importante utilizzarla correttamente per evitare comportamenti inattesi.</li></ol></details><details><summary>continue<span class="tag-description" aria-label="descrizione tag">Salta l'iterazione corrente di un ciclo e passa alla successiva.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `continue` in JavaScript viene utilizzata per interrompere l'iterazione corrente di un ciclo (`for`, `while`, `do...while`) e passare immediatamente all'iterazione successiva. Non termina il ciclo, ma salta direttamente al passo successivo.</li><li>A cosa serve: Serve a saltare l'esecuzione di una parte di un ciclo quando una condizione è soddisfatta, evitando il resto delle istruzioni nell'iterazione corrente.</li><li>Quando usarlo: Utilizzalo quando vuoi saltare una determinata iterazione di un ciclo, continuando con le successive. È utile per evitare esecuzioni non necessarie di codice all'interno di un ciclo.</li><li>Rilevanza semantica: L'istruzione `continue` chiarisce che l'iterazione corrente deve essere saltata e il ciclo deve continuare con la successiva, mantenendo il flusso di esecuzione controllato.</li><li>Principali caratteristiche:<ul><li>Salta l'iterazione corrente e passa all'iterazione successiva del ciclo.</li><li>Non interrompe il ciclo come `break`, ma evita solo le istruzioni rimanenti nell'iterazione corrente.</li><li>Può essere utilizzato nei cicli `for`, `while` e `do...while`.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `continue` per saltare specifiche iterazioni in modo chiaro e conciso.</li><li>Evita l'uso eccessivo di `continue`, poiché potrebbe rendere il codice meno leggibile.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso di continue in un ciclo for
    for (let i = 0; i &lt; 10; i++) {
        if (i % 2 === 0) {
            continue; // Salta i numeri pari
        }
        console.log(i); // Stampa solo i numeri dispari
    }
    
    // Uso di continue in un ciclo while
    let j = 0;
    while (j &lt; 5) {
        j++;
        if (j === 3) {
            continue; // Salta quando j è uguale a 3
        }
        console.log(j);
    }
                                </code></pre></div></li><li>Alternative:<ul><li>Utilizzare una condizione `if` inversa per controllare l'esecuzione all'interno del ciclo.</li></ul></li><li>Potenziali errori comuni:<ul><li>Usare `continue` fuori dal contesto di un ciclo, causando un errore di sintassi.</li><li>Rendere il codice meno leggibile con un uso eccessivo di `continue`.</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di `continue` può migliorare le performance saltando le iterazioni non necessarie.</li></ul></li><li>Conclusioni: L'istruzione `continue` è utile per controllare il flusso di esecuzione nei cicli, permettendo di saltare specifiche iterazioni e migliorare la gestione delle condizioni all'interno del ciclo.</li></ol></details><details><summary>return<span class="tag-description" aria-label="descrizione tag">Termina l'esecuzione di una funzione e restituisce un valore.</span><div class="tag-group" aria-label="gruppo">4. Controllo del Flusso</div></summary><ol><li>Cos'è: L'istruzione `return` in JavaScript termina immediatamente l'esecuzione di una funzione e restituisce un valore specificato al chiamante. Se `return` viene utilizzato senza un valore, la funzione restituisce `undefined`.</li><li>A cosa serve: Serve a uscire da una funzione e restituire un valore al chiamante. È essenziale per restituire risultati e valori calcolati da una funzione.</li><li>Quando usarlo: Utilizzalo per interrompere l'esecuzione di una funzione quando hai ottenuto il risultato desiderato o quando una condizione specifica è soddisfatta.</li><li>Rilevanza semantica: L'istruzione `return` indica chiaramente che una funzione ha completato la sua esecuzione e sta restituendo un valore al chiamante.</li><li>Principali caratteristiche:<ul><li>Termina l'esecuzione della funzione corrente.</li><li>Può restituire un valore, che può essere usato dal chiamante.</li><li>Se non viene specificato alcun valore, la funzione restituisce `undefined` per impostazione predefinita.</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript.</li><li>Funziona in tutti i browser moderni e legacy.</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `return` per restituire valori calcolati o risultati da una funzione.</li><li>Evita di utilizzare `return` al di fuori del contesto di una funzione.</li><li>Utilizza `return` in modo esplicito per migliorare la leggibilità e la chiarezza del codice.</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
    // Uso di return per restituire un valore
    function add(a, b) {
        return a + b;
    }
    console.log(add(5, 3)); // 8
    
    // Uso di return per uscire da una funzione
    function checkAge(age) {
        if (age &lt; 18) {
            return 'Minorenne';
        }
        return 'Maggiorenne';
    }
    console.log(checkAge(17)); // 'Minorenne'
    
    // Return senza valore esplicito
    function doNothing() {
        return;
    }
    console.log(doNothing()); // undefined
                                </code></pre></div></li><li>Alternative:<ul><li>Usare variabili globali o esterne per restituire valori, anche se l'uso di `return` è più diretto.</li></ul></li><li>Potenziali errori comuni:<ul><li>Usare `return` fuori dal contesto di una funzione, causando un errore di sintassi.</li><li>Non considerare che una funzione senza `return` esplicito restituisce `undefined` per impostazione predefinita.</li></ul></li><li>Impatto sulle performance:<ul><li>L'uso di `return` migliora la gestione del flusso di esecuzione, poiché termina la funzione non appena viene chiamato.</li></ul></li><li>Conclusioni: L'istruzione `return` è essenziale per restituire valori e controllare il flusso di esecuzione delle funzioni in JavaScript. È importante utilizzarla correttamente per garantire che le funzioni restituiscano i risultati desiderati e interrompano l'esecuzione in modo appropriato.</li></ol></details><details><summary>for<span class="tag-description" aria-label="descrizione tag">Ciclo iterativo per ripetere un blocco di codice un numero definito di volte.</span><div class="tag-group" aria-label="gruppo">5. Cicli</div></summary><ol><li>Cos'è: Il ciclo `for` in JavaScript è una struttura di controllo che permette di eseguire ripetutamente un blocco di codice finché una condizione è vera.</li><li>A cosa serve: Viene utilizzato per iterare su array, numeri o altre strutture dati quando si conosce il numero di ripetizioni o si vuole controllare manualmente l'indice.</li><li>Quando usarlo: Si usa quando è necessario ripetere un'operazione più volte con un contatore o un indice definito, oppure quando si deve iterare su elementi di una collezione con un numero noto di iterazioni.</li><li>Rilevanza semantica: Il ciclo `for` è fondamentale per il controllo del flusso di esecuzione in JavaScript, permettendo di automatizzare operazioni ripetitive in modo leggibile e ordinato.</li><li>Principali caratteristiche:<ul><li>È composto da tre parti: inizializzazione, condizione e incremento/decremento</li><li>Il corpo del ciclo può contenere uno o più comandi racchiusi tra parentesi graffe</li><li>Supporta il controllo tramite `break` (uscita dal ciclo) e `continue` (salta all'iterazione successiva)</li><li>Può essere annidato all'interno di altri cicli per operazioni più complesse</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Funziona senza problemi sia in ambienti client che server-side (Node.js)</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa il ciclo `for` quando conosci il numero di iterazioni</li><li>Evita di modificare l'indice all'interno del corpo del ciclo per non creare comportamenti imprevisti</li><li>Considera alternative come `forEach` o `map` su array per codice più leggibile</li><li>Usa `break` e `continue` solo quando strettamente necessario</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Ciclo for classico
for (let i = 0; i &lt; 5; i++) {
    console.log("Iterazione numero: " + i);
}
// Output:
// Iterazione numero: 0
// Iterazione numero: 1
// Iterazione numero: 2
// Iterazione numero: 3
// Iterazione numero: 4

// Iterazione su array
let colori = ["rosso", "verde", "blu"];
for (let i = 0; i &lt; colori.length; i++) {
    console.log(colori[i]);
}
// Output:
// rosso
// verde
// blu
                </code></pre></div></li><li>Alternative:<ul><li>Cicli `while` o `do...while` per condizioni non basate su contatore</li><li>Metodi nativi degli array come `forEach`, `map` o `filter` per iterazioni più leggibili</li></ul></li><li>Potenziali errori comuni:<ul><li>Dimenticare di incrementare/decrementare l'indice, causando cicli infiniti</li><li>Usare condizioni errate, portando a iterazioni inattese o mancanti</li><li>Modificare l'array durante l'iterazione senza attenzione, creando comportamenti imprevedibili</li></ul></li><li>Impatto sulle performance:<ul><li>Generalmente molto efficiente per iterazioni basate su contatore</li><li>Iterazioni su array con `for` tradizionale possono essere più veloci di `forEach` in grandi dataset</li></ul></li><li>Conclusioni: Il ciclo `for` è uno strumento chiave in JavaScript per automatizzare compiti ripetitivi, gestire sequenze numeriche e iterare su collezioni. Con una corretta comprensione e applicazione, consente di scrivere codice chiaro, efficiente e manutenibile.</li></ol></details><details><summary>while<span class="tag-description" aria-label="descrizione tag">Ciclo iterativo che continua finché la condizione è vera.</span><div class="tag-group" aria-label="gruppo">5. Cicli</div></summary><ol><li>Cos'è: Il ciclo `while` in JavaScript esegue un blocco di codice ripetutamente finché la condizione specificata è vera.</li><li>A cosa serve: Serve a ripetere operazioni quando non si conosce a priori il numero di iterazioni, ma si vuole continuare fino a quando una certa condizione rimane vera.</li><li>Quando usarlo: Si usa quando il numero di ripetizioni dipende da eventi dinamici o dati in ingresso, e non da un contatore predeterminato.</li><li>Rilevanza semantica: Il ciclo `while` è fondamentale per la gestione di iterazioni condizionali, permettendo di creare cicli flessibili basati su condizioni variabili.</li><li>Principali caratteristiche:<ul><li>Controlla la condizione prima di ogni iterazione</li><li>Il corpo del ciclo può contenere uno o più comandi racchiusi tra parentesi graffe</li><li>Supporta `break` e `continue` per gestire il flusso all'interno del ciclo</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li><li>Funziona sia in ambienti client che server-side</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Assicurati che la condizione possa diventare falsa per evitare cicli infiniti</li><li>Evita di modificare variabili esterne in modi complessi dentro il ciclo, può generare bug difficili da trovare</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
let i = 0;
while (i &lt; 5) {
    console.log("Iterazione numero: " + i);
    i++;
}
// Output:
// Iterazione numero: 0
// Iterazione numero: 1
// Iterazione numero: 2
// Iterazione numero: 3
// Iterazione numero: 4
                </code></pre></div></li><li>Alternative:<ul><li>Ciclo `for` quando si conosce il numero di iterazioni</li><li>Ciclo `do...while` quando si vuole eseguire almeno una volta il corpo del ciclo</li></ul></li><li>Potenziali errori comuni:<ul><li>Creare cicli infiniti dimenticando di aggiornare le variabili nella condizione</li><li>Confondere `while` con `do...while` e viceversa</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente se la condizione viene controllata correttamente</li><li>Cicli infiniti o condizioni complesse possono rallentare l'esecuzione</li></ul></li><li>Conclusioni: Il ciclo `while` è utile per iterazioni condizionali flessibili, dove il numero di ripetizioni non è noto in anticipo. Una corretta gestione della condizione evita bug e garantisce un flusso controllato.</li></ol></details><details><summary>do...while<span class="tag-description" aria-label="descrizione tag">Ciclo iterativo che esegue il blocco di codice almeno una volta e poi continua finché la condizione è vera.</span><div class="tag-group" aria-label="gruppo">5. Cicli</div></summary><ol><li>Cos'è: Il ciclo `do...while` in JavaScript è simile a `while`, ma garantisce che il blocco di codice venga eseguito almeno una volta, prima di valutare la condizione.</li><li>A cosa serve: Serve quando si vuole assicurare almeno un'esecuzione del blocco, e poi continuare finché la condizione è vera.</li><li>Quando usarlo: Utile quando l'operazione deve essere eseguita almeno una volta, come chiedere input all'utente o inizializzare variabili.</li><li>Rilevanza semantica: Fornisce un controllo più flessibile rispetto a `while`, consentendo di separare l'esecuzione iniziale dalla verifica della condizione.</li><li>Principali caratteristiche:<ul><li>Il corpo viene eseguito almeno una volta</li><li>Controlla la condizione dopo l'esecuzione del blocco</li><li>Supporta `break` e `continue` per gestire il flusso</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser moderni e legacy</li></ul></li><li>Best practices per il suo utilizzo:<ul><li>Usa `do...while` quando è necessario eseguire almeno una volta il ciclo</li><li>Assicurati che la condizione possa diventare falsa per evitare cicli infiniti</li></ul></li><li>Esempi di codice con casi d'uso:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
let i = 0;
do {
    console.log("Iterazione numero: " + i);
    i++;
} while (i &lt; 5);
// Output:
// Iterazione numero: 0
// Iterazione numero: 1
// Iterazione numero: 2
// Iterazione numero: 3
// Iterazione numero: 4

// Esempio input simulato
let input;
do {
    input = prompt("Inserisci un numero maggiore di 10");
} while (input &lt;= 10);
                </code></pre></div></li><li>Alternative:<ul><li>Ciclo `while` se non è necessaria almeno una esecuzione</li><li>Ciclo `for` per iterazioni basate su contatore</li></ul></li><li>Potenziali errori comuni:<ul><li>Creare cicli infiniti dimenticando di aggiornare le variabili</li><li>Confondere `do...while` con `while` nel comportamento iniziale</li></ul></li><li>Impatto sulle performance:<ul><li>Molto simile a `while`, con overhead minimo</li><li>Cicli infiniti o condizioni complesse possono rallentare l'esecuzione</li></ul></li><li>Conclusioni: `do...while` è utile quando è necessario eseguire almeno una volta un blocco di codice e poi ripetere finché la condizione è vera. Garantisce flessibilità nel flusso e controllo chiaro della logica iterativa.</li></ol></details><details><summary>for...in<span class="tag-description" aria-label="descrizione tag">Ciclo per iterare sulle proprietà enumerabili di un oggetto.</span><div class="tag-group" aria-label="gruppo">5. Cicli</div></summary><ol><li>Cos'è: Il ciclo `for...in` in JavaScript permette di iterare sulle **proprietà enumerabili** di un oggetto (inclusi gli array, anche se non è il suo uso consigliato).</li><li>A cosa serve: Serve per scorrere tutte le chiavi di un oggetto, accedendo sia ai nomi delle proprietà che ai loro valori.</li><li>Quando usarlo: Si usa quando si vuole iterare su tutte le proprietà di un oggetto senza sapere in anticipo i nomi delle chiavi.</li><li>Rilevanza semantica: Utile per leggere e manipolare dinamicamente le proprietà di un oggetto.</li><li>Principali caratteristiche:<ul><li>Itera sulle proprietà enumerabili, comprese quelle ereditate dalla catena dei prototipi</li><li>Restituisce ogni volta il nome della proprietà come stringa</li><li>Non garantisce l'ordine delle chiavi</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser e Node.js</li></ul></li><li>Best practices:<ul><li>Usa `for...in` solo per oggetti, non per array</li><li>Utilizza `Object.hasOwn()` o `Object.hasOwnProperty()` per evitare di ciclare sulle proprietà ereditate</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario", età: 30, città: "Roma" };

for (let chiave in persona) {
    if (Object.hasOwn(persona, chiave)) {
        console.log(chiave + ": " + persona[chiave]);
    }
}
// Output (ordine non garantito):
// nome: Mario
// età: 30
// città: Roma
                </code></pre></div></li><li>Alternative:<ul><li>`Object.keys()` con `forEach`</li><li>Ciclo `for...of` su `Object.entries()`</li></ul></li><li>Potenziali errori:<ul><li>Usare `for...in` su array e confondersi con gli indici numerici</li><li>Dimenticare di filtrare le proprietà ereditate</li></ul></li><li>Impatto sulle performance:<ul><li>Generalmente veloce per oggetti di piccole/medie dimensioni</li><li>Il filtraggio con `hasOwnProperty` o `Object.hasOwn()` può aggiungere un leggero overhead</li></ul></li><li>Conclusioni: `for...in` è ideale per iterare sulle proprietà di un oggetto, ma va usato con cautela sugli array e filtrando le proprietà ereditate.</li></ol></details><details><summary>for...of<span class="tag-description" aria-label="descrizione tag">Ciclo per iterare sui valori di oggetti iterabili.</span><div class="tag-group" aria-label="gruppo">5. Cicli</div></summary><ol><li>Cos'è: Il ciclo `for...of` in JavaScript permette di iterare **direttamente sui valori** di un oggetto iterabile (array, stringhe, mappe, insiemi, ecc.).</li><li>A cosa serve: Serve per scorrere in modo semplice i valori di collezioni iterabili senza dover gestire indici o chiavi.</li><li>Quando usarlo: Si usa quando si vuole leggere direttamente il valore di ogni elemento di una struttura dati iterabile.</li><li>Rilevanza semantica: Fornisce un modo chiaro e leggibile per accedere ai valori in una sequenza.</li><li>Principali caratteristiche:<ul><li>Itera sui valori, non sulle chiavi</li><li>Funziona solo su oggetti iterabili (array, stringhe, Map, Set, ecc.)</li><li>Non itera sulle proprietà di un oggetto generico</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usa `for...of` quando ti serve accedere ai valori senza preoccuparti di indici</li><li>Per oggetti semplici, preferisci `for...in` o `Object.entries()`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Iterazione su array
const colori = ["rosso", "verde", "blu"];
for (let colore of colori) {
    console.log(colore);
}
// Output:
// rosso
// verde
// blu

// Iterazione su stringa
for (let carattere of "Ciao") {
    console.log(carattere);
}
// Output:
// C
// i
// a
// o
                </code></pre></div></li><li>Alternative:<ul><li>Metodo `forEach()` per array</li><li>`for...in` per le proprietà enumerabili di un oggetto</li></ul></li><li>Potenziali errori:<ul><li>Provare a usarlo su oggetti non iterabili (causa errore)</li><li>Confondere `for...of` con `for...in`</li></ul></li><li>Impatto sulle performance:<ul><li>Molto efficiente e leggibile per strutture dati di dimensioni medio-piccole</li><li>Prestazioni simili ai cicli `for` tradizionali sugli array</li></ul></li><li>Conclusioni: `for...of` è un modo moderno e leggibile per scorrere i valori di oggetti iterabili, rendendo il codice più pulito e semplice da mantenere.</li></ol></details><details><summary>arrow function<span class="tag-description" aria-label="descrizione tag">Sintassi compatta per definire funzioni anonime.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: Un'`arrow function` è una sintassi introdotta in ES6 per scrivere funzioni anonime in modo più conciso rispetto alla sintassi tradizionale.</li><li>A cosa serve: Serve a creare funzioni più brevi, spesso utilizzate come funzioni di callback o per operazioni inline.</li><li>Quando usarla: Si usa quando serve una funzione semplice, soprattutto quando non si vuole modificare il contesto (`this`) della funzione.</li><li>Rilevanza semantica: Rende il codice più leggibile e conciso, specialmente nelle funzioni brevi o passate come argomenti.</li><li>Principali caratteristiche:<ul><li>Sintassi più corta rispetto alle funzioni tradizionali</li><li>Non ha il proprio `this`, eredita quello dal contesto esterno</li><li>Non ha `arguments`, `super` o `new.target` propri</li><li>Non può essere usata come costruttore</li></ul></li><li>Compatibilità:<ul><li>Introdotta in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usala per funzioni brevi o inline</li><li>Evita di usarla quando serve un proprio `this` (es. in metodi di oggetti)</li><li>Non usarla come costruttore</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Arrow function base
const somma = (a, b) =&gt; a + b;
console.log(somma(3, 4)); // Output: 7

// Arrow function con corpo esplicito
const saluta = (nome) =&gt; {
    return `Ciao, ${nome}!`;
};
console.log(saluta("Mario")); // Output: Ciao, Mario!
                </code></pre></div></li><li>Alternative:<ul><li>Funzioni tradizionali con `function`</li></ul></li><li>Potenziali errori:<ul><li>Usarla in contesti dove serve un proprio `this`</li><li>Dimenticare le parentesi tonde quando ci sono più parametri</li></ul></li><li>Impatto sulle performance:<ul><li>Prestazioni simili alle funzioni tradizionali</li><li>Leggermente più veloce da scrivere e leggere per funzioni semplici</li></ul></li><li>Conclusioni: Le `arrow function` sono una sintassi moderna e concisa per definire funzioni, ideali per callback e funzioni brevi, ma vanno usate con attenzione per via delle differenze nel comportamento di `this`.</li></ol></details><details><summary>callback<span class="tag-description" aria-label="descrizione tag">Funzione passata come argomento ad un'altra funzione.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: Una `callback` è una funzione passata come argomento a un'altra funzione e invocata in un momento successivo, di solito quando un'operazione è completata.</li><li>A cosa serve: Serve a eseguire codice dopo un certo evento o azione, come la risposta di una richiesta HTTP o il completamento di un'operazione asincrona.</li><li>Quando usarla: Quando si vuole personalizzare il comportamento di una funzione o reagire a eventi/risultati futuri.</li><li>Rilevanza semantica: Le `callback` sono alla base della programmazione asincrona in JavaScript, specialmente prima dell'introduzione di `Promise` e `async/await`.</li><li>Principali caratteristiche:<ul><li>Possono essere funzioni normali o arrow function</li><li>Permettono di rendere una funzione più generica e riutilizzabile</li><li>Possono essere sincrone o asincrone</li></ul></li><li>Compatibilità:<ul><li>Supportate in tutte le versioni di JavaScript</li><li>Funzionano in tutti gli ambienti JavaScript</li></ul></li><li>Best practices:<ul><li>Usa nomi chiari per le funzioni callback</li><li>Evita il cosiddetto “callback hell” annidando troppe funzioni</li><li>Valuta l’uso di `Promise` o `async/await` per codice più leggibile</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Funzione che accetta una callback
function saluta(nome, callback) {
    console.log(`Ciao, ${nome}!`);
    callback();
}

// Uso di una callback
saluta("Mario", () =&gt; {
    console.log("Benvenuto nel sito!");
});
// Output:
// Ciao, Mario!
// Benvenuto nel sito!
                </code></pre></div></li><li>Alternative:<ul><li>`Promise`</li><li>`async/await`</li></ul></li><li>Potenziali errori:<ul><li>Non chiamare mai la callback, causando blocchi logici</li><li>Chiamarla più volte per errore</li><li>Annidare troppe callback rendendo il codice illeggibile</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto significativo rispetto a funzioni normali</li><li>Troppi annidamenti possono peggiorare la leggibilità e il debug</li></ul></li><li>Conclusioni: Le `callback` sono un concetto fondamentale in JavaScript per gestire codice da eseguire in risposta a eventi o azioni, ma vanno gestite con attenzione per evitare complessità eccessive.</li></ol></details><details><summary>IIFE<span class="tag-description" aria-label="descrizione tag">Funzione eseguita immediatamente dopo la sua definizione.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: Un'`IIFE` (Immediately Invoked Function Expression) è una funzione JavaScript che viene definita ed eseguita immediatamente, senza essere richiamata esplicitamente in un secondo momento.</li><li>A cosa serve: Serve a creare uno scope isolato per variabili e funzioni, evitando di inquinare lo scope globale.</li><li>Quando usarla: Utile quando si vogliono eseguire operazioni subito senza lasciare variabili o funzioni disponibili all'esterno.</li><li>Rilevanza semantica: Molto usata prima dell'introduzione di `let` e `const` per simulare lo scope di blocco, ancora valida in certi casi.</li><li>Principali caratteristiche:<ul><li>Si dichiara come espressione di funzione racchiusa tra parentesi</li><li>Viene eseguita immediatamente grazie a un'altra coppia di parentesi `()`</li><li>Crea uno scope separato</li></ul></li><li>Compatibilità:<ul><li>Supportata in tutte le versioni di JavaScript</li><li>Compatibile con tutti i browser e Node.js</li></ul></li><li>Best practices:<ul><li>Usala per inizializzare dati o configurazioni senza esporre variabili globali</li><li>Evita di abusarne per non rendere il codice meno leggibile</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// IIFE classica
(function() {
    console.log("Questa funzione si esegue subito!");
})();

// IIFE con arrow function
(() =&gt; {
    const messaggio = "Scope isolato";
    console.log(messaggio);
})();
                </code></pre></div></li><li>Alternative:<ul><li>Scope di blocco con `let` o `const`</li><li>Moduli JavaScript (ES Modules)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare le parentesi esterne, trasformandola in una dichiarazione di funzione non eseguibile</li><li>Confondere la sintassi con una normale funzione</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile, eseguita una sola volta</li></ul></li><li>Conclusioni: Le `IIFE` sono utili per creare scope isolati ed eseguire codice immediatamente, evitando variabili globali non necessarie.</li></ol></details><details><summary>closure<span class="tag-description" aria-label="descrizione tag">Funzione che mantiene accesso alle variabili del proprio scope anche dopo la sua esecuzione.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: Una `closure` è una funzione che ricorda e può accedere alle variabili del proprio scope di dichiarazione, anche dopo che lo scope esterno è stato eseguito.</li><li>A cosa serve: Serve per mantenere uno stato privato, creare funzioni personalizzate e gestire dati senza esporli allo scope globale.</li><li>Quando usarla: Quando si vogliono memorizzare informazioni in una funzione e mantenerle disponibili tra diverse esecuzioni.</li><li>Rilevanza semantica: È un concetto fondamentale di JavaScript, sfruttato in programmazione funzionale e in molte librerie.</li><li>Principali caratteristiche:<ul><li>Mantiene in vita lo scope della funzione esterna</li><li>Permette di creare variabili private</li><li>Funziona con funzioni normali e arrow function</li></ul></li><li>Compatibilità:<ul><li>Supportata in tutte le versioni di JavaScript</li><li>Compatibile con tutti gli ambienti JavaScript</li></ul></li><li>Best practices:<ul><li>Usa le closure per incapsulare dati che non devono essere accessibili globalmente</li><li>Evita closure troppo complesse per non appesantire la memoria</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function contatore() {
    let count = 0;
    return function() {
        count++;
        return count;
    };
}

const incrementa = contatore();
console.log(incrementa()); // 1
console.log(incrementa()); // 2
console.log(incrementa()); // 3
                </code></pre></div></li><li>Alternative:<ul><li>Variabili globali (sconsigliato)</li><li>Oggetti con metodi e proprietà private (classi con campi privati)</li></ul></li><li>Potenziali errori:<ul><li>Creare closure non necessarie che occupano memoria</li><li>Dimenticare che le variabili catturate possono essere modificate</li></ul></li><li>Impatto sulle performance:<ul><li>Leggero consumo di memoria in più per mantenere lo scope in vita</li><li>Trascurabile in contesti normali</li></ul></li><li>Conclusioni: Le `closure` sono uno strumento potente per gestire variabili private e stati persistenti all’interno di funzioni, ma vanno usate con consapevolezza.</li></ol></details><details><summary>parametri di default<span class="tag-description" aria-label="descrizione tag">Valori predefiniti assegnati ai parametri di una funzione.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: I `parametri di default` sono valori predefiniti che una funzione utilizza se un parametro non viene fornito o è `undefined` al momento della chiamata.</li><li>A cosa serve: Serve a rendere le funzioni più flessibili e robuste, evitando errori dovuti a parametri mancanti.</li><li>Quando usarli: Quando un parametro può avere un valore di default sensato in caso non venga passato dall’utente.</li><li>Rilevanza semantica: Semplificano il codice, eliminando la necessità di controlli manuali per valori `undefined`.</li><li>Principali caratteristiche:<ul><li>Definiti direttamente nella dichiarazione della funzione</li><li>Funzionano con funzioni normali e arrow function</li><li>Il valore di default è usato solo se il parametro è `undefined`</li></ul></li><li>Compatibilità:<ul><li>Introdotti in ES6 (2015)</li><li>Compatibili con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usa valori di default solo quando ha senso logico</li><li>Evita valori complessi come default se non strettamente necessari</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function saluta(nome = "Ospite") {
    console.log(`Ciao, ${nome}!`);
}

saluta();        // Output: Ciao, Ospite!
saluta("Mario"); // Output: Ciao, Mario!
                </code></pre></div></li><li>Alternative:<ul><li>Controllo manuale con `if` e assegnazione</li><li>Operatore logico `||` per valori falsy (meno preciso)</li></ul></li><li>Potenziali errori:<ul><li>Confondere `undefined` con altri valori falsy come `null` o `0` (il default non si applica)</li><li>Mettere un parametro obbligatorio dopo uno con default, creando ambiguità</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile, gestito nativamente dal motore JS</li></ul></li><li>Conclusioni: I `parametri di default` sono un modo semplice ed efficace per gestire parametri mancanti, migliorando la leggibilità e la robustezza delle funzioni.</li></ol></details><details><summary>rest parameters<span class="tag-description" aria-label="descrizione tag">Raccoglie un numero variabile di argomenti in un array.</span><div class="tag-group" aria-label="gruppo">6. Funzioni</div></summary><ol><li>Cos'è: I `rest parameters` permettono a una funzione di accettare un numero indefinito di argomenti, raccogliendoli in un array.</li><li>A cosa serve: Serve a gestire funzioni che devono accettare un numero variabile di valori, senza dover definire parametri singoli uno per uno.</li><li>Quando usarli: Quando non si conosce in anticipo quanti argomenti saranno passati alla funzione.</li><li>Rilevanza semantica: Rende il codice più flessibile e leggibile rispetto all’uso di `arguments`.</li><li>Principali caratteristiche:<ul><li>Si dichiarano con tre puntini `...` prima del nome del parametro</li><li>Raccolgono tutti gli argomenti extra in un array</li><li>Funzionano solo come ultimo parametro della funzione</li></ul></li><li>Compatibilità:<ul><li>Introdotti in ES6 (2015)</li><li>Compatibili con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usali quando il numero di parametri è variabile</li><li>Evita di abusarne in funzioni che potrebbero essere più chiare con un array esplicito</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function somma(...numeri) {
    return numeri.reduce((totale, num) =&gt; totale + num, 0);
}

console.log(somma(1, 2, 3));       // Output: 6
console.log(somma(4, 5, 6, 7, 8)); // Output: 30
                </code></pre></div></li><li>Alternative:<ul><li>Oggetto `arguments` (meno leggibile e privo di metodi array)</li><li>Passare direttamente un array come parametro</li></ul></li><li>Potenziali errori:<ul><li>Dichiararli in posizione non finale tra i parametri</li><li>Confonderli con lo spread operator (che li usa in modo inverso)</li></ul></li><li>Impatto sulle performance:<ul><li>Prestazioni simili a passare un array tradizionale</li></ul></li><li>Conclusioni: I `rest parameters` rendono le funzioni molto più flessibili quando si lavora con un numero variabile di argomenti e sostituiscono in modo più leggibile l’uso di `arguments`.</li></ol></details><details><summary>this<span class="tag-description" aria-label="descrizione tag">Riferimento al contesto di esecuzione corrente.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: In JavaScript, `this` è una parola chiave che fa riferimento all'oggetto su cui viene eseguita la funzione corrente, e il suo valore dipende da come la funzione viene chiamata.</li><li>A cosa serve: Serve per accedere a proprietà e metodi dell'oggetto corrente all’interno di una funzione o di un metodo.</li><li>Quando usarlo: Quando si lavora con metodi di oggetti o quando si vuole che una funzione sia dinamicamente legata al contesto di chiamata.</li><li>Rilevanza semantica: Fondamentale per comprendere il comportamento degli oggetti e della programmazione orientata agli oggetti in JavaScript.</li><li>Principali caratteristiche:<ul><li>Il valore di `this` dipende dal contesto di esecuzione, non dalla posizione nel codice</li><li>In modalità `strict`, `this` è `undefined` se non è impostato esplicitamente</li><li>Le arrow function ereditano `this` dal contesto esterno</li></ul></li><li>Compatibilità:<ul><li>Disponibile in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usa arrow function per mantenere il `this` esterno</li><li>Evita di fare affidamento implicito su `this` quando possibile, passa invece l’oggetto come argomento</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = {
    nome: "Mario",
    saluta: function() {
        console.log(`Ciao, sono ${this.nome}`);
    }
};

persona.saluta(); // Output: Ciao, sono Mario
                </code></pre></div></li><li>Alternative:<ul><li>Passare esplicitamente l’oggetto come parametro</li><li>Usare variabili di chiusura (`self` o `that`) per memorizzare il contesto</li></ul></li><li>Potenziali errori:<ul><li>Perdere il contesto quando si assegna un metodo a una variabile</li><li>Confondere il comportamento in modalità `strict` e non strict</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto significativo</li></ul></li><li>Conclusioni: Comprendere come funziona `this` è essenziale per lavorare con oggetti e metodi in JavaScript, soprattutto in contesti complessi come eventi e classi.</li></ol></details><details><summary>Object.create()<span class="tag-description" aria-label="descrizione tag">Crea un nuovo oggetto con un prototipo specificato.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.create()` crea un nuovo oggetto, utilizzando un oggetto esistente come prototipo del nuovo oggetto.</li><li>A cosa serve: Serve per creare oggetti che ereditano proprietà e metodi da un altro oggetto.</li><li>Quando usarlo: Quando si vuole impostare manualmente la catena dei prototipi o creare oggetti con ereditarietà personalizzata.</li><li>Rilevanza semantica: Fornisce un modo chiaro e diretto per implementare ereditarietà prototipale in JavaScript.</li><li>Principali caratteristiche:<ul><li>Accetta come primo argomento l’oggetto da usare come prototipo</li><li>Può accettare un secondo argomento con descrittori di proprietà</li><li>Restituisce un nuovo oggetto con il prototipo specificato</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES5</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per ereditarietà semplice tra oggetti</li><li>Evita catene di prototipi troppo profonde</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const animale = {
    respira() {
        console.log("Respiro...");
    }
};

const cane = Object.create(animale);
cane.abbaia = function() {
    console.log("Bau!");
};

cane.respira(); // Output: Respiro...
cane.abbaia();  // Output: Bau!
                </code></pre></div></li><li>Alternative:<ul><li>Definizione di classi con `class` e `extends`</li><li>Costruttori di funzione con prototipi</li></ul></li><li>Potenziali errori:<ul><li>Passare `null` come prototipo e poi aspettarsi proprietà predefinite</li><li>Dimenticare che le proprietà ereditate non sono copie ma riferimenti condivisi</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente per creare oggetti con prototipo predefinito</li></ul></li><li>Conclusioni: `Object.create()` è un metodo semplice e potente per creare oggetti che ereditano direttamente da altri oggetti, utile per strutture ad hoc o ereditarietà personalizzata.</li></ol></details><details><summary>Object.assign()<span class="tag-description" aria-label="descrizione tag">Copia le proprietà enumerabili da uno o più oggetti in un oggetto target.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.assign()` copia tutte le proprietà enumerabili di uno o più oggetti sorgente in un oggetto target e restituisce quest’ultimo.</li><li>A cosa serve: Serve per unire più oggetti in uno, o per clonare oggetti superficiali.</li><li>Quando usarlo: Quando si vuole combinare dati da più oggetti o fare copie di oggetti esistenti senza modificarli direttamente.</li><li>Rilevanza semantica: Utile per la gestione immutabile degli stati e per creare rapidamente oggetti combinati.</li><li>Principali caratteristiche:<ul><li>Accetta un oggetto target e uno o più oggetti sorgente</li><li>Le proprietà con lo stesso nome vengono sovrascritte</li><li>La copia è superficiale, non profonda</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per unioni semplici di oggetti</li><li>Per copie profonde, utilizza altre tecniche come `structuredClone()` o librerie dedicate</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const obj1 = { a: 1, b: 2 };
const obj2 = { b: 3, c: 4 };

const risultato = Object.assign({}, obj1, obj2);
console.log(risultato); // Output: { a: 1, b: 3, c: 4 }
                </code></pre></div></li><li>Alternative:<ul><li>Spread operator `{ ...obj1, ...obj2 }`</li><li>Funzioni di merge di librerie come Lodash</li></ul></li><li>Potenziali errori:<ul><li>Confondere copia superficiale con copia profonda</li><li>Modificare accidentalmente l’oggetto target originale</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente per unioni e copie superficiali</li><li>Evita di usarlo su oggetti molto annidati senza una strategia chiara</li></ul></li><li>Conclusioni: `Object.assign()` è un metodo rapido per unire oggetti o fare copie superficiali, utile soprattutto nella gestione degli stati e nella programmazione funzionale.</li></ol></details><details><summary>Object.keys()<span class="tag-description" aria-label="descrizione tag">Restituisce un array con le chiavi enumerabili di un oggetto.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.keys()` restituisce un array contenente i nomi (stringhe) delle proprietà enumerabili di un oggetto.</li><li>A cosa serve: Serve a ottenere rapidamente tutte le chiavi di un oggetto per iterarle o analizzarle.</li><li>Quando usarlo: Quando si ha bisogno di conoscere o scorrere tutte le chiavi di un oggetto.</li><li>Rilevanza semantica: Utile per trasformare oggetti in strutture più facili da manipolare, ad esempio in array.</li><li>Principali caratteristiche:<ul><li>Restituisce solo le chiavi enumerabili proprie dell'oggetto</li><li>L’ordine delle chiavi corrisponde all’ordine di inserimento</li><li>Restituisce un array vuoto se l'oggetto non ha proprietà</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES5</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo con `forEach`, `map` o `for...of` per iterare sulle chiavi</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario", età: 30, città: "Roma" };
console.log(Object.keys(persona));
// Output: ["nome", "età", "città"]
                </code></pre></div></li><li>Alternative:<ul><li>`for...in` con `Object.hasOwn()`</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi anche le proprietà non enumerabili o ereditate</li></ul></li><li>Impatto sulle performance:<ul><li>Molto efficiente per oggetti di dimensioni medio-piccole</li></ul></li><li>Conclusioni: `Object.keys()` è il metodo più rapido per ottenere un array con tutte le chiavi di un oggetto senza includere quelle ereditate.</li></ol></details><details><summary>Object.values()<span class="tag-description" aria-label="descrizione tag">Restituisce un array con i valori delle proprietà enumerabili di un oggetto.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.values()` restituisce un array contenente i valori delle proprietà enumerabili di un oggetto.</li><li>A cosa serve: Serve a ottenere tutti i valori di un oggetto in un array, utile per iterazioni e trasformazioni.</li><li>Quando usarlo: Quando si vuole lavorare direttamente con i valori di un oggetto senza le chiavi.</li><li>Rilevanza semantica: Complementare a `Object.keys()` per manipolare facilmente i dati.</li><li>Principali caratteristiche:<ul><li>Restituisce i valori nell’ordine corrispondente alle chiavi</li><li>Restituisce un array vuoto se l'oggetto non ha proprietà</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES8 (2017)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per ottenere valori da manipolare con metodi come `map`, `filter` o `reduce`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario", età: 30, città: "Roma" };
console.log(Object.values(persona));
// Output: ["Mario", 30, "Roma"]
                </code></pre></div></li><li>Alternative:<ul><li>Iterazione con `for...in` e accesso diretto alle proprietà</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi di ottenere anche le chiavi</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente e semplice per oggetti di piccole/medie dimensioni</li></ul></li><li>Conclusioni: `Object.values()` è il modo più semplice per estrarre i valori di un oggetto in un array, utile per operazioni dirette sui dati.</li></ol></details><details><summary>Object.entries()<span class="tag-description" aria-label="descrizione tag">Restituisce un array di coppie chiave-valore di un oggetto.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.entries()` restituisce un array contenente coppie `[chiave, valore]` per ogni proprietà enumerabile di un oggetto.</li><li>A cosa serve: Serve a trasformare un oggetto in un array di coppie chiave-valore, utile per iterazioni e conversioni in altre strutture dati.</li><li>Quando usarlo: Quando si vuole iterare contemporaneamente su chiavi e valori in modo semplice.</li><li>Rilevanza semantica: Combina le funzionalità di `Object.keys()` e `Object.values()` in un unico metodo.</li><li>Principali caratteristiche:<ul><li>Restituisce un array di array, ciascuno con due elementi: chiave e valore</li><li>L’ordine è quello di inserimento delle proprietà</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES8 (2017)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo con `for...of` per iterare sulle coppie chiave-valore</li><li>Utile per conversioni con `Map`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario", età: 30, città: "Roma" };
for (let [chiave, valore] of Object.entries(persona)) {
    console.log(`${chiave}: ${valore}`);
}
// Output:
// nome: Mario
// età: 30
// città: Roma
                </code></pre></div></li><li>Alternative:<ul><li>Iterazione con `for...in` e accesso diretto alle proprietà</li><li>`Object.keys()` + accesso manuale ai valori</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di destrutturare le coppie, rendendo il codice meno leggibile</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente per oggetti medio-piccoli</li></ul></li><li>Conclusioni: `Object.entries()` è il metodo più pratico per ottenere sia chiavi che valori di un oggetto in un unico passaggio.</li></ol></details><details><summary>Object.freeze()<span class="tag-description" aria-label="descrizione tag">Rende un oggetto immutabile.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.freeze()` impedisce qualsiasi modifica a un oggetto: non è possibile aggiungere, rimuovere o cambiare proprietà.</li><li>A cosa serve: Serve a proteggere oggetti che non devono essere alterati, garantendo che il loro stato rimanga costante.</li><li>Quando usarlo: Quando si vuole assicurare l'immutabilità di un oggetto dopo la sua creazione.</li><li>Rilevanza semantica: Utile nella programmazione funzionale e nella gestione di stati in applicazioni complesse.</li><li>Principali caratteristiche:<ul><li>Le proprietà non possono essere modificate, aggiunte o rimosse</li><li>Le proprietà con valori oggetto non vengono congelate in profondità</li><li>Restituisce lo stesso oggetto passato come argomento</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES5</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per costanti e configurazioni che non devono cambiare</li><li>Se serve una protezione profonda, combina con funzioni di deep freeze</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const config = { tema: "scuro", lingua: "it" };
Object.freeze(config);

config.tema = "chiaro"; // Non ha effetto
console.log(config.tema); // Output: scuro
                </code></pre></div></li><li>Alternative:<ul><li>`Object.seal()` per bloccare aggiunte e rimozioni ma permettere modifiche</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che anche gli oggetti annidati vengano congelati automaticamente</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile per oggetti piccoli</li><li>Può essere costoso se usato su oggetti molto grandi</li></ul></li><li>Conclusioni: `Object.freeze()` è un metodo sicuro per rendere immutabile un oggetto, ma attenzione ai valori annidati che restano modificabili.</li></ol></details><details><summary>Object.seal()<span class="tag-description" aria-label="descrizione tag">Blocca l’aggiunta o la rimozione di proprietà di un oggetto.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.seal()` impedisce di aggiungere o rimuovere proprietà da un oggetto, ma permette di modificare i valori delle proprietà esistenti.</li><li>A cosa serve: Serve per proteggere la struttura di un oggetto senza bloccare la possibilità di aggiornare i suoi dati.</li><li>Quando usarlo: Quando la forma dell'oggetto deve rimanere fissa, ma i valori possono variare.</li><li>Rilevanza semantica: Una via di mezzo tra oggetti completamente mutabili e quelli completamente congelati.</li><li>Principali caratteristiche:<ul><li>Non è possibile aggiungere o eliminare proprietà</li><li>È possibile modificare i valori delle proprietà esistenti</li><li>Restituisce lo stesso oggetto passato come argomento</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES5</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo quando vuoi bloccare la struttura dell’oggetto ma mantenere i valori aggiornabili</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario", età: 30 };
Object.seal(persona);

persona.nome = "Luca"; // Modifica consentita
delete persona.età;     // Non ha effetto

console.log(persona); // Output: { nome: "Luca", età: 30 }
                </code></pre></div></li><li>Alternative:<ul><li>`Object.freeze()` per bloccare anche le modifiche ai valori</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che i valori siano immutabili (per quello serve `Object.freeze()`)</li></ul></li><li>Impatto sulle performance:<ul><li>Basso impatto su oggetti piccoli</li></ul></li><li>Conclusioni: `Object.seal()` è utile per mantenere fissa la struttura di un oggetto pur permettendo la modifica dei suoi valori.</li></ol></details><details><summary>Object.hasOwn()<span class="tag-description" aria-label="descrizione tag">Verifica se un oggetto possiede una proprietà come propria.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il metodo `Object.hasOwn()` verifica se un oggetto possiede una determinata proprietà come propria e non ereditata dal prototipo.</li><li>A cosa serve: Serve a distinguere tra proprietà dirette di un oggetto e quelle ereditate dalla catena dei prototipi.</li><li>Quando usarlo: Quando si iterano le proprietà di un oggetto e si vuole filtrare solo quelle definite direttamente su di esso.</li><li>Rilevanza semantica: Alternativa moderna a `hasOwnProperty()`, più sicura e chiara.</li><li>Principali caratteristiche:<ul><li>Restituisce `true` se la proprietà esiste direttamente sull’oggetto</li><li>Restituisce `false` se è ereditata o assente</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES2022</li><li>Compatibile con i browser moderni e Node.js recenti</li></ul></li><li>Best practices:<ul><li>Usalo al posto di `hasOwnProperty()` per codice più pulito</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const persona = { nome: "Mario" };

console.log(Object.hasOwn(persona, "nome")); // true
console.log(Object.hasOwn(persona, "età"));  // false
                </code></pre></div></li><li>Alternative:<ul><li>`hasOwnProperty()` (meno sicuro in caso di override)</li></ul></li><li>Potenziali errori:<ul><li>Usarlo su ambienti JavaScript vecchi senza polyfill</li></ul></li><li>Impatto sulle performance:<ul><li>Molto veloce e sicuro per la verifica delle proprietà</li></ul></li><li>Conclusioni: `Object.hasOwn()` è il metodo consigliato per verificare se un oggetto possiede una proprietà direttamente, evitando le insidie del vecchio `hasOwnProperty()`.</li></ol></details><details><summary>Destructuring<span class="tag-description" aria-label="descrizione tag">Sintassi per estrarre valori da array o proprietà da oggetti in variabili separate.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Il `destructuring` è una sintassi che consente di estrarre valori da array o proprietà da oggetti e assegnarli a variabili in modo conciso.</li><li>A cosa serve: Serve a semplificare l’assegnazione di variabili quando si lavora con array o oggetti complessi.</li><li>Quando usarlo: Quando si vogliono prelevare uno o più valori da un oggetto o array senza doverli accedere manualmente uno per uno.</li><li>Rilevanza semantica: Migliora la leggibilità e riduce la ripetizione di codice.</li><li>Principali caratteristiche:<ul><li>Funziona con oggetti e array</li><li>Supporta valori di default</li><li>Può rinominare le variabili assegnate</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per estrarre solo ciò che serve</li><li>Evita destructuring troppo complessi in un'unica riga</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Da oggetto
const persona = { nome: "Mario", età: 30 };
const { nome, età } = persona;
console.log(nome, età); // Output: Mario 30

// Da array
const colori = ["rosso", "verde", "blu"];
const [primo, secondo] = colori;
console.log(primo, secondo); // Output: rosso verde
                </code></pre></div></li><li>Alternative:<ul><li>Assegnazione tradizionale con punto o indice</li></ul></li><li>Potenziali errori:<ul><li>Tentare di destrutturare `undefined` o `null` (causa errore)</li></ul></li><li>Impatto sulle performance:<ul><li>Praticamente nullo, migliora la leggibilità senza rallentare</li></ul></li><li>Conclusioni: Il `destructuring` è una sintassi potente e concisa per estrarre valori da array e oggetti, utile per codice pulito e leggibile.</li></ol></details><details><summary>Shorthand property names<span class="tag-description" aria-label="descrizione tag">Sintassi abbreviata per creare proprietà di oggetti.</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Le `shorthand property names` sono una sintassi che consente di creare proprietà di oggetti usando direttamente il nome della variabile quando corrisponde al nome della proprietà.</li><li>A cosa serve: Serve a scrivere oggetti in modo più conciso ed evitare ripetizioni inutili.</li><li>Quando usarlo: Quando il nome della proprietà e quello della variabile da assegnare coincidono.</li><li>Rilevanza semantica: Migliora la leggibilità e riduce il codice ridondante.</li><li>Principali caratteristiche:<ul><li>Funziona solo quando nome proprietà e variabile coincidono</li><li>Si applica alla definizione di oggetti letterali</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo per oggetti piccoli e chiari</li><li>Evita di abusarne in oggetti con molte proprietà dove i nomi non sono autoesplicativi</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const nome = "Mario";
const età = 30;

// Sintassi abbreviata
const persona = { nome, età };
console.log(persona); // Output: { nome: "Mario", età: 30 }
                </code></pre></div></li><li>Alternative:<ul><li>Definizione tradizionale con `nome: nome`</li></ul></li><li>Potenziali errori:<ul><li>Usare variabili non dichiarate (causa errore ReferenceError)</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto, è solo sintassi abbreviata</li></ul></li><li>Conclusioni: Le `shorthand property names` rendono più veloce e leggibile la creazione di oggetti quando variabili e proprietà hanno lo stesso nome.</li></ol></details><details><summary>Computed property names<span class="tag-description" aria-label="descrizione tag">Sintassi per definire nomi di proprietà calcolati dinamicamente</span><div class="tag-group" aria-label="gruppo">7. Oggetti</div></summary><ol><li>Cos'è: Le `computed property names` permettono di definire i nomi delle proprietà di un oggetto in modo dinamico, utilizzando un'espressione tra parentesi quadre.</li><li>A cosa serve: Serve a creare proprietà i cui nomi dipendono da variabili o calcoli effettuati al momento della creazione dell’oggetto.</li><li>Quando usarlo: Quando il nome della proprietà non è noto in anticipo e deve essere calcolato a runtime.</li><li>Rilevanza semantica: Utile per generare oggetti in maniera dinamica e personalizzata.</li><li>Principali caratteristiche:<ul><li>Il nome della proprietà viene valutato come espressione</li><li>Funziona con variabili, stringhe, numeri e concatenazioni</li></ul></li><li>Compatibilità:<ul><li>Introdotto in ES6 (2015)</li><li>Compatibile con tutti i browser moderni e Node.js</li></ul></li><li>Best practices:<ul><li>Usalo quando i nomi delle proprietà sono effettivamente dinamici</li><li>Evita espressioni troppo complesse che peggiorano la leggibilità</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const prop = "età";
const persona = {
    nome: "Mario",
    [prop]: 30
};

console.log(persona); // Output: { nome: "Mario", età: 30 }
                </code></pre></div></li><li>Alternative:<ul><li>Assegnazione successiva usando notazione con parentesi quadre</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare le parentesi quadre, creando una proprietà letterale con il nome dell’espressione</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile, il calcolo del nome è fatto solo in fase di creazione</li></ul></li><li>Conclusioni: Le `computed property names` offrono un modo potente e flessibile per creare proprietà di oggetti con nomi determinati a runtime.</li></ol></details><details><summary>push()<span class="tag-description" aria-label="descrizione tag">Aggiunge uno o più elementi alla fine di un array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: Il metodo `push()` aggiunge uno o più elementi alla fine di un array e ne restituisce la nuova lunghezza.</li><li>A cosa serve: Serve per estendere un array aggiungendo elementi alla sua fine.</li><li>Quando usarlo: Quando si vuole aggiungere dati in coda a un array in modo semplice.</li><li>Rilevanza semantica: È uno dei metodi fondamentali per la manipolazione degli array.</li><li>Principali caratteristiche:<ul><li>Modifica l’array originale</li><li>Restituisce la nuova lunghezza dell’array</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo quando vuoi aggiungere elementi in coda senza creare un nuovo array</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3];
numeri.push(4);
console.log(numeri); // Output: [1, 2, 3, 4]
                </code></pre></div></li><li>Alternative:<ul><li>Spread operator per creare un nuovo array: `[...array, elemento]`</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che crei un nuovo array (modifica invece quello esistente)</li></ul></li><li>Impatto sulle performance:<ul><li>Molto efficiente per aggiungere alla fine</li></ul></li><li>Conclusioni: `push()` è il metodo standard per aggiungere elementi alla fine di un array.</li></ol></details><details><summary>pop()<span class="tag-description" aria-label="descrizione tag">Rimuove l’ultimo elemento di un array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: Il metodo `pop()` rimuove l’ultimo elemento da un array e lo restituisce.</li><li>A cosa serve: Serve per togliere rapidamente l’ultimo elemento di un array.</li><li>Quando usarlo: Quando si vuole rimuovere l’elemento finale da una lista ordinata.</li><li>Rilevanza semantica: Complementare a `push()` per la gestione della coda degli elementi.</li><li>Principali caratteristiche:<ul><li>Modifica l’array originale</li><li>Restituisce l’elemento rimosso</li><li>Restituisce `undefined` se l’array è vuoto</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo quando ti serve rimuovere l’ultimo elemento in modo rapido</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3];
const ultimo = numeri.pop();
console.log(ultimo); // Output: 3
console.log(numeri); // Output: [1, 2]
                </code></pre></div></li><li>Alternative:<ul><li>Creare un nuovo array con `slice(0, -1)`</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che non modifichi l’array originale</li></ul></li><li>Impatto sulle performance:<ul><li>Molto veloce per la rimozione dell’ultimo elemento</li></ul></li><li>Conclusioni: `pop()` è il metodo più semplice per rimuovere l’ultimo elemento di un array.</li></ol></details><details><summary>shift()<span class="tag-description" aria-label="descrizione tag">Rimuove il primo elemento di un array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: Il metodo `shift()` rimuove il primo elemento da un array e lo restituisce.</li><li>A cosa serve: Serve per togliere rapidamente l’elemento iniziale di un array.</li><li>Quando usarlo: Quando si vuole lavorare su una lista come fosse una coda (FIFO).</li><li>Rilevanza semantica: Complementare a `pop()` ma agisce sulla testa dell’array.</li><li>Principali caratteristiche:<ul><li>Modifica l’array originale</li><li>Restituisce l’elemento rimosso</li><li>Restituisce `undefined` se l’array è vuoto</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo solo quando necessario: rimuovere il primo elemento è meno efficiente che rimuovere l’ultimo</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3];
const primo = numeri.shift();
console.log(primo); // Output: 1
console.log(numeri); // Output: [2, 3]
                </code></pre></div></li><li>Alternative:<ul><li>Creare un nuovo array con `slice(1)`</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che non modifichi l’array originale</li></ul></li><li>Impatto sulle performance:<ul><li>Leggermente meno efficiente di `pop()` perché deve riposizionare tutti gli elementi</li></ul></li><li>Conclusioni: `shift()` è utile per rimuovere il primo elemento di un array, ma può essere meno efficiente su array molto grandi.</li></ol></details><details><summary>unshift()<span class="tag-description" aria-label="descrizione tag">Aggiunge uno o più elementi all’inizio di un array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: Il metodo `unshift()` aggiunge uno o più elementi all’inizio di un array e restituisce la nuova lunghezza.</li><li>A cosa serve: Serve per inserire elementi in testa a un array.</li><li>Quando usarlo: Quando si lavora su una lista in cui l’ordine d’inserimento è importante e si vuole aggiungere in testa.</li><li>Rilevanza semantica: Complementare a `shift()` per la gestione di code e pile.</li><li>Principali caratteristiche:<ul><li>Modifica l’array originale</li><li>Restituisce la nuova lunghezza</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Evita di abusarne su array molto grandi perché richiede il riposizionamento di tutti gli elementi</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [2, 3];
numeri.unshift(1);
console.log(numeri); // Output: [1, 2, 3]
                </code></pre></div></li><li>Alternative:<ul><li>Spread operator: `[nuovoElemento, ...array]`</li></ul></li><li>Potenziali errori:<ul><li>Usarlo su array molto grandi può rallentare le prestazioni</li></ul></li><li>Impatto sulle performance:<ul><li>Meno efficiente di `push()` per l’aggiunta in testa</li></ul></li><li>Conclusioni: `unshift()` è utile per aggiungere elementi all’inizio di un array, ma può essere meno performante su dataset molto grandi.</li></ol></details><details><summary>slice()<span class="tag-description" aria-label="descrizione tag">Restituisce una copia parziale di un array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: Il metodo `slice()` restituisce una copia superficiale di una porzione di un array in un nuovo array, senza modificare l’originale.</li><li>A cosa serve: Serve per estrarre una parte di un array in base a indici specificati.</li><li>Quando usarlo: Quando serve ottenere una sezione di un array senza alterare l’originale.</li><li>Rilevanza semantica: Metodo standard per la copia parziale di array.</li><li>Principali caratteristiche:<ul><li>Accetta due argomenti: indice iniziale e indice finale (non incluso)</li><li>Se omesso, prende fino alla fine dell’array</li><li>Può accettare indici negativi</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo per creare copie di array senza modificarli</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3, 4, 5];
const parte = numeri.slice(1, 4);
console.log(parte);   // Output: [2, 3, 4]
console.log(numeri);  // Output: [1, 2, 3, 4, 5]
                </code></pre></div></li><li>Alternative:<ul><li>Spread operator per copiare l’intero array: `[...array]`</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che modifichi l’array originale</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente su array di dimensioni moderate</li></ul></li><li>Conclusioni: `slice()` è il metodo più sicuro per estrarre porzioni di un array senza alterarlo.</li></ol></details><details><summary>splice()<span class="tag-description" aria-label="descrizione tag">Aggiunge/rimuove elementi modificando l’array originale.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `splice()` consente di rimuovere, sostituire o inserire elementi in un array **modificando l’array originale**.</li><li>A cosa serve: Serve per operazioni di editing “chirurgico” su un array: taglia, sostituisci, inserisci.</li><li>Quando usarlo: Quando vuoi cambiare l’array in-place (senza crearne uno nuovo).</li><li>Rilevanza semantica: È il coltellino svizzero delle modifiche distruttive sugli array.</li><li>Principali caratteristiche:<ul><li>Firma base: `splice(indiceStart, deleteCount, ...itemsDaInserire)`</li><li>Restituisce un array con gli elementi rimossi</li><li>Se `deleteCount` è 0, non rimuove nulla (solo inserimento)</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo solo quando vuoi davvero modificare l’array originale</li><li>Se ti serve immutabilità, preferisci `slice()` + spread</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const colori = ["rosso", "verde", "blu"];

// Rimuovi 1 elemento da index 1
const rimossi = colori.splice(1, 1);
console.log(rimossi); // ["verde"]
console.log(colori);  // ["rosso", "blu"]

// Inserisci senza rimuovere (deleteCount = 0)
colori.splice(1, 0, "giallo", "viola");
console.log(colori); // ["rosso", "giallo", "viola", "blu"]

// Sostituisci 1 elemento con 2
colori.splice(2, 1, "nero", "bianco");
console.log(colori); // ["rosso", "giallo", "nero", "bianco", "blu"]
                </code></pre></div></li><li>Alternative:<ul><li>Immutabile: `[...a.slice(0,i), ...nuovi, ...a.slice(i+k)]`</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare che modifica l’array originale</li><li>Indici sbagliati → rimozioni/inserimenti imprevisti</li></ul></li><li>Impatto sulle performance:<ul><li>Può essere costoso su array grandi (shift degli elementi)</li></ul></li><li>Conclusioni: `splice()` è potente ma “distruttivo”: ottimo per edit mirati, usalo con consapevolezza.</li></ol></details><details><summary>map()<span class="tag-description" aria-label="descrizione tag">Crea un nuovo array trasformando ogni elemento.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `map()` applica una funzione a **ogni elemento** dell’array e restituisce **un nuovo array** con i risultati.</li><li>A cosa serve: Serve a trasformare dati (es. numeri → numeri raddoppiati, oggetti → solo un campo).</li><li>Quando usarlo: Quando vuoi la stessa lunghezza, ma con elementi trasformati.</li><li>Rilevanza semantica: Metodo funzionale, immutabile e leggibile per le trasformazioni.</li><li>Principali caratteristiche:<ul><li>Non modifica l’array originale</li><li>Callback: `(valore, indice, array)`</li><li>Restituisce sempre un array della stessa lunghezza</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Mantieni la callback pura (senza side-effect)</li><li>Usa arrow function per sintassi compatta</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3];
const raddoppiati = numeri.map(n =&gt; n * 2);
console.log(raddoppiati); // [2, 4, 6]
console.log(numeri);      // [1, 2, 3] (immutato)
                </code></pre></div></li><li>Alternative:<ul><li>Loop `for` (più verboso)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare il `return` nella callback con corpo `{}`</li><li>Usarlo per filtrare (per quello c’è `filter()`)</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente e chiaro per trasformazioni elementari</li></ul></li><li>Conclusioni: `map()` è la via maestra per trasformare array in modo pulito e immutabile.</li></ol></details><details><summary>filter()<span class="tag-description" aria-label="descrizione tag">Crea un nuovo array con gli elementi che passano un test.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `filter()` restituisce un nuovo array con **solo** gli elementi per cui la callback ritorna `true`.</li><li>A cosa serve: A selezionare un sottoinsieme di elementi (es. numeri pari, oggetti attivi).</li><li>Quando usarlo: Quando devi **filtrare** senza trasformare e senza toccare l’originale.</li><li>Rilevanza semantica: Espressivo e immutabile per condizioni di selezione.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)` → `boolean`</li><li>Non modifica l’array originale</li><li>La lunghezza del risultato può essere 0..N</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Callback semplice e leggibile</li><li>Chaining con `map()` o `reduce()` quando serve</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3, 4, 5, 6];
const pari = numeri.filter(n =&gt; n % 2 === 0);
console.log(pari);   // [2, 4, 6]
console.log(numeri); // [1, 2, 3, 4, 5, 6]
                </code></pre></div></li><li>Alternative:<ul><li>Loop con `if` e `push()` (più verboso)</li></ul></li><li>Potenziali errori:<ul><li>Restituire valori non booleani confondendo la logica</li><li>Usarlo per trasformare (per quello c’è `map()`)</li></ul></li><li>Impatto sulle performance:<ul><li>Lineare: visita ogni elemento una volta</li></ul></li><li>Conclusioni: `filter()` è il modo più semplice e pulito per selezionare elementi in base a una condizione.</li></ol></details><details><summary>reduce()<span class="tag-description" aria-label="descrizione tag">Riduce l’array a un singolo valore accumulando risultati.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `reduce()` applica una funzione “accumulatore” agli elementi dell’array per ottenere **un unico risultato** (numero, stringa, oggetto, ecc.).</li><li>A cosa serve: Somme, medie, raggruppamenti, conteggi, trasformazioni complesse in un solo passaggio.</li><li>Quando usarlo: Quando devi “condensare” l’array in un valore finale.</li><li>Rilevanza semantica: È il colosso dei metodi funzionali sugli array.</li><li>Principali caratteristiche:<ul><li>Firma: `reduce(callback, valoreIniziale?)`</li><li>Callback: `(acc, valore, indice, array) → nuovoAcc`</li><li>Consigliato passare sempre `valoreIniziale`</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Scegli un `valoreIniziale` coerente (es. `0`, `""`, `{}`, `[]`)</li><li>Mantieni la callback pura e breve</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// Somma
const numeri = [1, 2, 3, 4];
const somma = numeri.reduce((acc, n) =&gt; acc + n, 0);
console.log(somma); // 10

// Raggruppa per proprietà
const utenti = [
  { nome: "Ana", ruolo: "admin" },
  { nome: "Bea", ruolo: "user" },
  { nome: "Cal", ruolo: "user" }
];
const perRuolo = utenti.reduce((acc, u) =&gt; {
  (acc[u.ruolo] ??= []).push(u.nome);
  return acc;
}, {});
console.log(perRuolo); // { admin: ["Ana"], user: ["Bea", "Cal"] }
                </code></pre></div></li><li>Alternative:<ul><li>`map()` + `filter()` + altri metodi (ma spesso meno efficiente)</li></ul></li><li>Potenziali errori:<ul><li>Omettere il `valoreIniziale` e trovarsi casi limite con array vuoti</li><li>Accumulatore mutato in modo imprevedibile</li></ul></li><li>Impatto sulle performance:<ul><li>Una sola passata sull’array; ottimo per aggregazioni</li></ul></li><li>Conclusioni: `reduce()` è il metodo definitivo per calcoli e aggregazioni: flessibile, potente, ma da usare con una callback chiara.</li></ol></details><details><summary>forEach()<span class="tag-description" aria-label="descrizione tag">Esegue una funzione su ogni elemento dell’array.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `forEach()` esegue una funzione callback su ogni elemento di un array, in ordine, senza restituire un nuovo array.</li><li>A cosa serve: Per eseguire operazioni o effetti collaterali su tutti gli elementi di un array.</li><li>Quando usarlo: Quando vuoi iterare un array per compiere azioni, ma non devi trasformarlo o filtrarlo.</li><li>Rilevanza semantica: Alternativa più leggibile di un ciclo `for` classico per iterazioni semplici.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)`</li><li>Non restituisce nulla (`undefined`)</li><li>Non interrompe l’esecuzione con `break` o `return`</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Usalo per side-effect, non per costruire nuovi array</li><li>Se devi fermarti prima, usa un `for` tradizionale</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const colori = ["rosso", "verde", "blu"];
colori.forEach((colore, i) =&gt; {
  console.log(`${i}: ${colore}`);
});
// Output:
// 0: rosso
// 1: verde
// 2: blu
                </code></pre></div></li><li>Alternative:<ul><li>`map()` se serve restituire un nuovo array</li></ul></li><li>Potenziali errori:<ul><li>Aspettarsi che `forEach()` ritorni un nuovo array</li><li>Tentare di uscire con `return` (non funziona)</li></ul></li><li>Impatto sulle performance:<ul><li>Simile a un `for` classico, ma leggermente più lento</li></ul></li><li>Conclusioni: `forEach()` è comodo per eseguire operazioni su tutti gli elementi di un array senza preoccuparsi dell’indice.</li></ol></details><details><summary>find()<span class="tag-description" aria-label="descrizione tag">Restituisce il primo elemento che soddisfa una condizione.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `find()` restituisce il primo elemento dell’array che soddisfa la condizione definita nella callback, oppure `undefined` se non lo trova.</li><li>A cosa serve: Per cercare un singolo elemento in base a un criterio.</li><li>Quando usarlo: Quando vuoi solo il primo match, non tutti.</li><li>Rilevanza semantica: Metodo espressivo e chiaro per ricerche mirate.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)`</li><li>Restituisce il valore trovato o `undefined`</li><li>Interrompe l’iterazione al primo match</li></ul></li><li>Compatibilità:<ul><li>ES6+</li></ul></li><li>Best practices:<ul><li>Usalo quando ti basta il primo risultato</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const utenti = [
  { nome: "Luca", attivo: false },
  { nome: "Anna", attivo: true },
  { nome: "Marta", attivo: true }
];
const primoAttivo = utenti.find(u =&gt; u.attivo);
console.log(primoAttivo); // { nome: "Anna", attivo: true }
                </code></pre></div></li><li>Alternative:<ul><li>`filter()` se ti servono tutti i match</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare che restituisce solo il primo match</li></ul></li><li>Impatto sulle performance:<ul><li>Si ferma appena trova un elemento valido</li></ul></li><li>Conclusioni: `find()` è perfetto per ottenere un singolo elemento corrispondente a un criterio.</li></ol></details><details><summary>findIndex()<span class="tag-description" aria-label="descrizione tag">Restituisce l’indice del primo elemento che soddisfa una condizione.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `findIndex()` restituisce l’indice del primo elemento che soddisfa la condizione, oppure `-1` se nessun elemento è idoneo.</li><li>A cosa serve: Per sapere dove si trova un elemento nell’array.</li><li>Quando usarlo: Quando ti serve l’indice, non il valore.</li><li>Rilevanza semantica: Complementare a `find()` per lavorare sugli indici.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)`</li><li>Restituisce il primo indice trovato o `-1`</li></ul></li><li>Compatibilità:<ul><li>ES6+</li></ul></li><li>Best practices:<ul><li>Usalo quando poi modificherai o accederai all’elemento per indice</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [5, 12, 8, 130, 44];
const indice = numeri.findIndex(n =&gt; n &gt; 100);
console.log(indice); // 3
                </code></pre></div></li><li>Alternative:<ul><li>`indexOf()` se cerchi un valore esatto</li></ul></li><li>Potenziali errori:<ul><li>Confonderlo con `find()` (questo restituisce un numero, non l’elemento)</li></ul></li><li>Impatto sulle performance:<ul><li>Si ferma al primo match</li></ul></li><li>Conclusioni: `findIndex()` è ideale per individuare la posizione di un elemento che soddisfa una condizione.</li></ol></details><details><summary>some()<span class="tag-description" aria-label="descrizione tag">Verifica se almeno un elemento soddisfa una condizione.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `some()` restituisce `true` se almeno un elemento dell’array soddisfa la condizione nella callback, altrimenti `false`.</li><li>A cosa serve: Per controllare se esiste almeno un elemento che rispetta un criterio.</li><li>Quando usarlo: Quando la presenza di un match è sufficiente.</li><li>Rilevanza semantica: Espresso e leggibile per verifiche booleane.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)`</li><li>Restituisce `true` o `false`</li><li>Si ferma al primo match</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Usalo per condizioni di “esistenza”</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [1, 2, 3, 4, 5];
console.log(numeri.some(n =&gt; n &gt; 4)); // true
                </code></pre></div></li><li>Alternative:<ul><li>Loop con `if` e `break`</li></ul></li><li>Potenziali errori:<ul><li>Confonderlo con `every()` (logica opposta)</li></ul></li><li>Impatto sulle performance:<ul><li>Si ferma al primo elemento valido</li></ul></li><li>Conclusioni: `some()` è il metodo ideale per verificare se almeno un elemento dell’array soddisfa una condizione.</li></ol></details><details><summary>every()<span class="tag-description" aria-label="descrizione tag">Verifica se tutti gli elementi soddisfano una condizione.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `every()` restituisce `true` se tutti gli elementi dell’array soddisfano la condizione nella callback, altrimenti `false`.</li><li>A cosa serve: Per verificare che un array rispetti completamente un requisito.</li><li>Quando usarlo: Quando serve una condizione globale “tutti devono essere...”.</li><li>Rilevanza semantica: Complementare a `some()` ma più restrittivo.</li><li>Principali caratteristiche:<ul><li>Callback: `(valore, indice, array)`</li><li>Restituisce `true` o `false`</li><li>Si ferma al primo elemento che non soddisfa la condizione</li></ul></li><li>Compatibilità:<ul><li>ES5+</li></ul></li><li>Best practices:<ul><li>Usalo per validazioni complete</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const numeri = [2, 4, 6];
console.log(numeri.every(n =&gt; n % 2 === 0)); // true
                </code></pre></div></li><li>Alternative:<ul><li>Loop con `if` e `break`</li></ul></li><li>Potenziali errori:<ul><li>Confonderlo con `some()`</li></ul></li><li>Impatto sulle performance:<ul><li>Si ferma appena trova un elemento non valido</li></ul></li><li>Conclusioni: `every()` è ottimo per verificare se un array rispetta completamente una regola.</li></ol></details><details><summary>includes()<span class="tag-description" aria-label="descrizione tag">Verifica se un array contiene un certo elemento.</span><div class="tag-group" aria-label="gruppo">8. Array</div></summary><ol><li>Cos'è: `includes()` restituisce `true` se l’array contiene un elemento specifico, altrimenti `false`.</li><li>A cosa serve: Per controllare la presenza di un valore in un array in modo semplice e leggibile.</li><li>Quando usarlo: Quando vuoi verificare rapidamente la presenza di un elemento.</li><li>Rilevanza semantica: Alternativa moderna a `indexOf()` per verifiche di appartenenza.</li><li>Principali caratteristiche:<ul><li>Firma: `includes(valore, fromIndex = 0)`</li><li>Confronto con `===` (strict equality)</li></ul></li><li>Compatibilità:<ul><li>ES7+</li></ul></li><li>Best practices:<ul><li>Preferiscilo a `indexOf()` per leggibilità</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const frutti = ["mela", "banana", "pera"];
console.log(frutti.includes("banana")); // true
console.log(frutti.includes("kiwi"));   // false
                </code></pre></div></li><li>Alternative:<ul><li>`indexOf()` (restituisce -1 se non trovato)</li></ul></li><li>Potenziali errori:<ul><li>Confonderlo con `some()` (questo controlla esistenza diretta, non condizione)</li></ul></li><li>Impatto sulle performance:<ul><li>Controlla ogni elemento fino a match o fine array</li></ul></li><li>Conclusioni: `includes()` è il metodo più leggibile per verificare la presenza di un elemento in un array.</li></ol></details><details><summary>try...catch<span class="tag-description" aria-label="descrizione tag">Gestisce errori durante l'esecuzione del codice.</span><div class="tag-group" aria-label="gruppo">9. Errori</div></summary><ol><li>Cos'è: La struttura `try...catch` permette di eseguire un blocco di codice (`try`) e catturare eventuali errori generati (`catch`) senza interrompere l’esecuzione del programma.</li><li>A cosa serve: Serve per gestire in modo sicuro errori previsti o imprevisti durante l'esecuzione.</li><li>Quando usarlo: Quando del codice potrebbe generare eccezioni (es. parsing JSON, chiamate API, accesso a file).</li><li>Rilevanza semantica: È il meccanismo principale di gestione delle eccezioni in JavaScript.</li><li>Principali caratteristiche:<ul><li>`try` contiene il codice potenzialmente pericoloso</li><li>`catch` riceve un oggetto errore con informazioni sul problema</li><li>Previene il crash dell’applicazione</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usa `try...catch` per errori che puoi prevedere e gestire</li><li>Non abusarne per il flusso logico</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
try {
  let dati = JSON.parse('{"nome": "Luca"}');
  console.log(dati.nome);
} catch (errore) {
  console.error("Errore nel parsing:", errore.message);
}
                </code></pre></div></li><li>Alternative:<ul><li>Gestione errori con `if` per validazioni semplici</li></ul></li><li>Potenziali errori:<ul><li>Catturare errori troppo generici e non gestirli</li><li>Lasciare il `catch` vuoto</li></ul></li><li>Impatto sulle performance:<ul><li>Leggero overhead se l’errore viene generato</li></ul></li><li>Conclusioni: `try...catch` è essenziale per intercettare e gestire errori evitando blocchi dell’esecuzione.</li></ol></details><details><summary>throw<span class="tag-description" aria-label="descrizione tag">Genera un'eccezione in JavaScript.</span><div class="tag-group" aria-label="gruppo">9. Errori</div></summary><ol><li>Cos'è: L’istruzione `throw` consente di generare manualmente un’eccezione, interrompendo l’esecuzione corrente e passando il controllo al blocco `catch` più vicino.</li><li>A cosa serve: Serve per segnalare un errore o una condizione anomala all’interno del codice.</li><li>Quando usarlo: Quando una funzione o un’operazione incontra un input o stato non valido.</li><li>Rilevanza semantica: È il meccanismo base per far emergere errori personalizzati.</li><li>Principali caratteristiche:<ul><li>Può lanciare valori di qualsiasi tipo (stringhe, numeri, oggetti, istanze di `Error`)</li><li>Di norma si lancia un oggetto `Error` o derivato</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Lancia oggetti `Error` per coerenza</li><li>Fornisci messaggi chiari e utili al debug</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function dividi(a, b) {
  if (b === 0) {
    throw new Error("Divisione per zero non consentita");
  }
  return a / b;
}

try {
  console.log(dividi(10, 0));
} catch (err) {
  console.error("Errore:", err.message);
}
                </code></pre></div></li><li>Alternative:<ul><li>Restituire valori speciali come `null` o `false` (meno esplicito)</li></ul></li><li>Potenziali errori:<ul><li>Lanciare valori non informativi</li></ul></li><li>Impatto sulle performance:<ul><li>Interrompe il flusso, quindi va usato solo per errori reali</li></ul></li><li>Conclusioni: `throw` è il modo standard per segnalare un errore in JavaScript e dovrebbe essere usato in combinazione con `try...catch`.</li></ol></details><details><summary>finally<span class="tag-description" aria-label="descrizione tag">Esegue sempre un blocco di codice dopo try/catch.</span><div class="tag-group" aria-label="gruppo">9. Errori</div></summary><ol><li>Cos'è: Il blocco `finally` viene eseguito dopo `try` e `catch`, indipendentemente dal fatto che si sia verificato un errore o meno.</li><li>A cosa serve: Per eseguire codice di pulizia o chiusura (es. chiudere connessioni, liberare risorse).</li><li>Quando usarlo: Quando devi garantire che un’operazione venga eseguita sempre, anche in caso di errore.</li><li>Rilevanza semantica: Completa la gestione degli errori permettendo cleanup finali.</li><li>Principali caratteristiche:<ul><li>Viene eseguito dopo `try`/`catch`</li><li>Ignora eventuali `return` nel blocco `try` o `catch`</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo per cleanup, non per logica principale</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
try {
  console.log("Apro connessione...");
  throw new Error("Errore di rete");
} catch (e) {
  console.error(e.message);
} finally {
  console.log("Chiudo connessione");
}
                </code></pre></div></li><li>Alternative:<ul><li>Codice di cleanup subito dopo `try...catch` (ma meno chiaro)</li></ul></li><li>Potenziali errori:<ul><li>Scrivere logica principale dentro `finally`</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto significativo</li></ul></li><li>Conclusioni: `finally` garantisce che il codice venga sempre eseguito, ed è perfetto per operazioni di chiusura e pulizia.</li></ol></details><details><summary>Error<span class="tag-description" aria-label="descrizione tag">Oggetto base per rappresentare errori in JavaScript.</span><div class="tag-group" aria-label="gruppo">9. Errori</div></summary><ol><li>Cos'è: `Error` è il costruttore base per creare oggetti errore in JavaScript, con proprietà come `message` e `name`.</li><li>A cosa serve: A rappresentare errori in modo standardizzato e fornire informazioni utili al debug.</li><li>Quando usarlo: Quando lanci errori personalizzati con `throw`.</li><li>Rilevanza semantica: È il modello base per tutti i tipi di errore (`TypeError`, `ReferenceError`, ecc.).</li><li>Principali caratteristiche:<ul><li>Proprietà comuni: `message`, `name`, `stack`</li><li>Può essere esteso per creare errori personalizzati</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutte le versioni di JavaScript</li></ul></li><li>Best practices:<ul><li>Usa sempre `Error` o sue sottoclassi per gli errori</li><li>Fornisci messaggi chiari e utili</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
try {
  throw new Error("Qualcosa è andato storto");
} catch (e) {
  console.error(e.name);    // "Error"
  console.error(e.message); // "Qualcosa è andato storto"
}
                </code></pre></div></li><li>Alternative:<ul><li>Sottoclassi come `TypeError`, `RangeError`, `SyntaxError`</li></ul></li><li>Potenziali errori:<ul><li>Lanciare stringhe invece di oggetti `Error`</li></ul></li><li>Impatto sulle performance:<ul><li>Nessuno, ma la creazione di stack trace può avere un minimo overhead</li></ul></li><li>Conclusioni: `Error` è la base per gestire errori in JavaScript in modo chiaro e standard.</li></ol></details><details><summary>setTimeout()<span class="tag-description" aria-label="descrizione tag">Esegue una funzione dopo un certo intervallo di tempo.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: `setTimeout()` esegue una funzione o un blocco di codice dopo un ritardo specificato in millisecondi.</li><li>A cosa serve: Per pianificare l'esecuzione di codice in futuro, ad esempio ritardare un'animazione o un messaggio.</li><li>Quando usarlo: Quando vuoi posticipare un’azione senza bloccare il resto del programma.</li><li>Rilevanza semantica: È una delle funzioni temporali base in JavaScript.</li><li>Principali caratteristiche:<ul><li>Firma: `setTimeout(funzione, ritardo, arg1, arg2, ...)`</li><li>Restituisce un ID timer per poterlo annullare con `clearTimeout()`</li><li>Il tempo non è garantito al millisecondo</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutti i browser e in Node.js</li></ul></li><li>Best practices:<ul><li>Memorizza l’ID se hai bisogno di cancellare il timer</li><li>Evita ritardi troppo brevi per operazioni costose</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
setTimeout(() =&gt; {
  console.log("Eseguito dopo 2 secondi");
}, 2000);
                </code></pre></div></li><li>Alternative:<ul><li>`setInterval()` per esecuzioni ripetute</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare che il codice continua a eseguirsi nel frattempo</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile per usi normali</li></ul></li><li>Conclusioni: `setTimeout()` è ideale per eseguire codice una sola volta dopo un ritardo definito.</li></ol></details><details><summary>setInterval()<span class="tag-description" aria-label="descrizione tag">Esegue una funzione ripetutamente a intervalli regolari.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: `setInterval()` esegue una funzione o un blocco di codice a intervalli regolari, specificati in millisecondi.</li><li>A cosa serve: Per compiti che si ripetono, come aggiornare un orologio o effettuare controlli periodici.</li><li>Quando usarlo: Quando vuoi ripetere un’azione più volte a intervalli fissi.</li><li>Rilevanza semantica: È la controparte di `setTimeout()` per esecuzioni ricorrenti.</li><li>Principali caratteristiche:<ul><li>Firma: `setInterval(funzione, intervallo, arg1, arg2, ...)`</li><li>Restituisce un ID intervallo per poterlo annullare con `clearInterval()`</li><li>Gli intervalli possono accumulare ritardi se il codice interno è lento</li></ul></li><li>Compatibilità:<ul><li>Supportato in tutti i browser e in Node.js</li></ul></li><li>Best practices:<ul><li>Usa `clearInterval()` quando non serve più</li><li>Evita intervalli troppo brevi per codice pesante</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const id = setInterval(() =&gt; {
  console.log("Ogni 1 secondo");
}, 1000);

// Interrompi dopo 5 secondi
setTimeout(() =&gt; clearInterval(id), 5000);
                </code></pre></div></li><li>Alternative:<ul><li>Ricorsione con `setTimeout()` per più controllo</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di interrompere intervalli non più necessari</li></ul></li><li>Impatto sulle performance:<ul><li>Intervalli inutilizzati possono consumare CPU</li></ul></li><li>Conclusioni: `setInterval()` è perfetto per operazioni ripetitive e programmate a intervalli fissi.</li></ol></details><details><summary>Promise<span class="tag-description" aria-label="descrizione tag">Oggetto che rappresenta il risultato futuro di un'operazione asincrona.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: Una `Promise` è un oggetto che rappresenta un valore che potrebbe essere disponibile ora, in futuro, o mai, come risultato di un'operazione asincrona.</li><li>A cosa serve: Per gestire codice asincrono in modo più ordinato rispetto alle callback annidate.</li><li>Quando usarla: Quando lavori con operazioni che richiedono tempo (API, file, timer) e vuoi gestire successi e fallimenti in modo chiaro.</li><li>Rilevanza semantica: È la base di molte API asincrone moderne in JavaScript.</li><li>Principali caratteristiche:<ul><li>Stati: `pending`, `fulfilled`, `rejected`</li><li>Metodi: `then()`, `catch()`, `finally()`</li><li>Supporta chaining (concatenazione di operazioni)</li></ul></li><li>Compatibilità:<ul><li>ES6+</li></ul></li><li>Best practices:<ul><li>Gestisci sempre gli errori con `catch()`</li><li>Usa `async/await` per maggiore leggibilità</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const promessa = new Promise((resolve, reject) =&gt; {
  setTimeout(() =&gt; {
    resolve("Operazione completata");
  }, 1000);
});

promessa
  .then(risultato =&gt; console.log(risultato))
  .catch(err =&gt; console.error("Errore:", err));
                </code></pre></div></li><li>Alternative:<ul><li>Callback tradizionali (meno leggibili)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di gestire il caso `rejected`</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto significativo, ma ogni promessa aggiunge un microtask alla coda</li></ul></li><li>Conclusioni: Le `Promise` rendono la gestione asincrona più prevedibile e leggibile, soprattutto abbinate ad `async/await`.</li></ol></details><details><summary>async<span class="tag-description" aria-label="descrizione tag">Dichiara una funzione che restituisce sempre una Promise.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: `async` è una keyword che, messa davanti a una funzione, la rende asincrona e fa sì che restituisca sempre una `Promise`.</li><li>A cosa serve: A scrivere codice asincrono in modo più leggibile, senza dover usare `then()` manualmente.</li><li>Quando usarlo: Quando vuoi usare `await` all'interno di una funzione o quando una funzione deve restituire una `Promise`.</li><li>Rilevanza semantica: Facilita l'uso delle `Promise` rendendo il codice simile a quello sincrono.</li><li>Principali caratteristiche:<ul><li>Restituisce sempre una `Promise`</li><li>Gestisce automaticamente i valori di ritorno e le eccezioni</li></ul></li><li>Compatibilità:<ul><li>ES2017+</li></ul></li><li>Best practices:<ul><li>Usalo con `await` per maggiore chiarezza</li><li>Gestisci gli errori con `try...catch`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
async function saluta() {
  return "Ciao!";
}

saluta().then(console.log); // Output: Ciao!
                </code></pre></div></li><li>Alternative:<ul><li>Promise con `then()` e `catch()`</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di usare `await` su chiamate asincrone</li></ul></li><li>Impatto sulle performance:<ul><li>Trascurabile, ma crea sempre una Promise anche se il risultato è immediato</li></ul></li><li>Conclusioni: `async` semplifica l’uso delle Promise e rende il codice asincrono più leggibile.</li></ol></details><details><summary>await<span class="tag-description" aria-label="descrizione tag">Attende il completamento di una Promise all'interno di una funzione async.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: `await` è una keyword che sospende l'esecuzione di una funzione `async` finché una `Promise` non è risolta o rigettata.</li><li>A cosa serve: Per scrivere codice asincrono in stile sincrono, migliorando leggibilità e manutenzione.</li><li>Quando usarlo: Dentro funzioni `async` quando devi aspettare il risultato di una `Promise`.</li><li>Rilevanza semantica: È il complemento naturale di `async` per il controllo del flusso asincrono.</li><li>Principali caratteristiche:<ul><li>Funziona solo dentro funzioni dichiarate `async`</li><li>Restituisce il valore risolto della Promise</li><li>Genera un errore se la Promise viene rigettata</li></ul></li><li>Compatibilità:<ul><li>ES2017+</li></ul></li><li>Best practices:<ul><li>Usalo con `try...catch` per gestire errori</li><li>Evita di usarlo in loop intensivi per non rallentare il codice</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
async function esempio() {
  try {
    const risultato = await Promise.resolve("Fatto!");
    console.log(risultato);
  } catch (err) {
    console.error("Errore:", err);
  }
}

esempio();
                </code></pre></div></li><li>Alternative:<ul><li>Uso diretto di `then()` e `catch()`</li></ul></li><li>Potenziali errori:<ul><li>Usarlo fuori da una funzione `async`</li></ul></li><li>Impatto sulle performance:<ul><li>Attende in modo bloccante per quella funzione, ma non blocca il thread principale</li></ul></li><li>Conclusioni: `await` rende il codice asincrono più chiaro e simile a quello sincrono.</li></ol></details><details><summary>fetch()<span class="tag-description" aria-label="descrizione tag">Effettua richieste HTTP e restituisce una Promise.</span><div class="tag-group" aria-label="gruppo">10. Asincronia</div></summary><ol><li>Cos'è: `fetch()` è una funzione nativa che permette di effettuare richieste HTTP e restituisce una `Promise` che si risolve con un oggetto `Response`.</li><li>A cosa serve: Per recuperare dati da server o API web.</li><li>Quando usarlo: Quando devi leggere o inviare dati via rete in JavaScript.</li><li>Rilevanza semantica: È l’API moderna standard per le richieste HTTP in browser e Node.js (con compatibilità).</li><li>Principali caratteristiche:<ul><li>Firma: `fetch(url, opzioni)`</li><li>Restituisce una Promise</li><li>Supporta metodi HTTP (`GET`, `POST`, `PUT`, `DELETE`, ...)</li></ul></li><li>Compatibilità:<ul><li>Browser moderni</li><li>Node.js 18+ nativo (o con librerie come node-fetch)</li></ul></li><li>Best practices:<ul><li>Usa `await` per maggiore leggibilità</li><li>Gestisci sempre gli errori di rete e parsing</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
async function prendiDati() {
  try {
    const risposta = await fetch("https://jsonplaceholder.typicode.com/posts/1");
    const dati = await risposta.json();
    console.log(dati);
  } catch (errore) {
    console.error("Errore nella richiesta:", errore);
  }
}

prendiDati();
                </code></pre></div></li><li>Alternative:<ul><li>XMLHttpRequest (vecchio)</li><li>Librerie come Axios</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di chiamare `.json()` o `.text()` per leggere il body</li><li>Non gestire errori di rete</li></ul></li><li>Impatto sulle performance:<ul><li>Leggero overhead di rete; il resto dipende dal server</li></ul></li><li>Conclusioni: `fetch()` è la soluzione moderna per richieste HTTP in JavaScript, semplice e potente.</li></ol></details><details><summary>addEventListener()<span class="tag-description" aria-label="descrizione tag">Assegna un listener per un evento specifico a un elemento.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: `addEventListener()` è un metodo degli elementi DOM che permette di ascoltare eventi specifici e di eseguire una funzione quando questi avvengono.</li><li>A cosa serve: Per associare codice a eventi come `click`, `keydown`, `submit` e molti altri.</li><li>Quando usarlo: Quando vuoi reagire a un’azione dell’utente o a un evento generato dal browser.</li><li>Rilevanza semantica: È lo standard moderno per la gestione degli eventi nel DOM.</li><li>Principali caratteristiche:<ul><li>Firma: `element.addEventListener(tipo, callback, opzioni)`</li><li>Supporta più listener per lo stesso evento</li><li>Funziona anche con eventi personalizzati</li></ul></li><li>Compatibilità:<ul><li>Compatibile con tutti i browser moderni</li><li>IE9+ (versioni precedenti usano `attachEvent`)</li></ul></li><li>Best practices:<ul><li>Usa funzioni nominate per facilitarne la rimozione</li><li>Evita di annidare troppi listener per motivi di performance</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const bottone = document.querySelector("#mioBottone");

function saluta() {
  console.log("Ciao!");
}

bottone.addEventListener("click", saluta);
                </code></pre></div></li><li>Alternative:<ul><li>Attributo HTML `onclick` (sconsigliato)</li><li>Proprietà `element.onclick` (limita a un solo handler)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di passare la stessa funzione a `removeEventListener()`</li><li>Usare arrow function se poi devi rimuovere il listener (non rimuovibile senza riferimento)</li></ul></li><li>Impatto sulle performance:<ul><li>Listener multipli su molti elementi possono pesare sulle performance</li></ul></li><li>Conclusioni: `addEventListener()` è il modo migliore e più flessibile per ascoltare eventi nel DOM.</li></ol></details><details><summary>removeEventListener()<span class="tag-description" aria-label="descrizione tag">Rimuove un listener precedentemente assegnato.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: `removeEventListener()` è un metodo che permette di rimuovere un evento precedentemente associato con `addEventListener()`.</li><li>A cosa serve: Per evitare che una funzione venga eseguita dopo che non serve più.</li><li>Quando usarlo: Quando un listener è temporaneo o può causare problemi se lasciato attivo.</li><li>Rilevanza semantica: Completa la gestione degli eventi, evitando comportamenti indesiderati.</li><li>Principali caratteristiche:<ul><li>Firma: `element.removeEventListener(tipo, callback, opzioni)`</li><li>Deve ricevere gli stessi parametri usati in `addEventListener()`</li><li>Non rimuove eventi aggiunti con `onclick`</li></ul></li><li>Compatibilità:<ul><li>Compatibile con tutti i browser moderni</li><li>IE9+ supportato</li></ul></li><li>Best practices:<ul><li>Conserva il riferimento della funzione listener</li><li>Rimuovi listener inutilizzati per liberare memoria</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function saluta() {
  console.log("Ciao!");
}

const bottone = document.querySelector("#mioBottone");

bottone.addEventListener("click", saluta);

// Rimuove il listener dopo 5 secondi
setTimeout(() =&gt; {
  bottone.removeEventListener("click", saluta);
}, 5000);
                </code></pre></div></li><li>Alternative:<ul><li>Impostare `element.onclick = null` (solo per eventi assegnati così)</li></ul></li><li>Potenziali errori:<ul><li>Non usare lo stesso riferimento della funzione usata in `addEventListener()`</li><li>Parametri diversi impediscono la rimozione</li></ul></li><li>Impatto sulle performance:<ul><li>Rimuovere listener inutili migliora le performance e riduce la memoria usata</li></ul></li><li>Conclusioni: `removeEventListener()` è fondamentale per una gestione efficiente e pulita degli eventi.</li></ol></details><details><summary>click<span class="tag-description" aria-label="descrizione tag">Evento di attivazione tramite puntatore o tastiera.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: `click` è un evento che si attiva quando un elemento viene “cliccato”: pressione e rilascio del tasto primario del mouse, tocco su dispositivi touch, oppure attivazione via tastiera su elementi interattivi (es. `Enter`/`Space` su `button`).</li><li>A cosa serve: Per reagire alle interazioni più comuni dell’utente (apri modali, invia azioni, cambia stato UI).</li><li>Quando usarlo: Quando vuoi eseguire un’azione in risposta a un’“attivazione” generica dell’utente.</li><li>Rilevanza semantica: È l’evento più diffuso per l’interazione generica. Su controlli nativi mantiene un buon livello di accessibilità.</li><li>Principali caratteristiche:<ul><li>Si innesca su mouse, touch e tastiera (su elementi attivabili)</li><li>Propaga in bubbling</li><li>Può essere prevenuto con `event.preventDefault()` (es. su link)</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Preferisci elementi semantici (`button`, `a`) invece di `div` cliccabili</li><li>Evita doppie gestioni (es. sia `click` che `touchstart` senza necessità)</li><li>Per link che non navigano, usa `button`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;button id="openModal"&amp;gt;Apri&amp;lt;/button&amp;gt;
const btn = document.querySelector("#openModal");
btn.addEventListener("click", (event) =&amp;gt; {
  console.log("Attivato!", event.type);
});
        </code></pre></div></li><li>Alternative:<ul><li>`pointerup`/`pointerdown` per maggiore controllo multi-input</li></ul></li><li>Potenziali errori:<ul><li>Gestire `click` su elementi non focalizzabili (accessibilità scarsa)</li><li>Dimenticare `preventDefault()` su `a` quando non vuoi navigare</li></ul></li><li>Impatto sulle performance:<ul><li>Minimo; attenzione solo a molti listener su molti nodi</li></ul></li><li>Conclusioni: `click` è la scelta standard per attivazioni rapide e accessibili.</li></ol></details><details><summary>keydown<span class="tag-description" aria-label="descrizione tag">Evento alla pressione di un tasto (prima del rilascio).</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: `keydown` si attiva quando un tasto viene premuto (prima del rilascio).</li><li>A cosa serve: Per scorciatoie da tastiera, navigazione, chiusura con `Esc`, etc.</li><li>Quando usarlo: Quando vuoi reagire immediatamente alla pressione di un tasto.</li><li>Rilevanza semantica: Fondamentale per accessibilità e UX da tastiera.</li><li>Principali caratteristiche:<ul><li>Proprietà chiave: `event.key`, `event.code`, `event.ctrlKey`/`shiftKey`/`altKey`/`metaKey`</li><li>`keypress` è deprecato; preferisci `keydown`/`keyup`</li><li>Propaga (bubbling)</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser moderni</li></ul></li><li>Best practices:<ul><li>Controlla `event.key` (leggibile: `"Escape"`, `"Enter"`, `"ArrowDown"`)</li><li>Evita `keyCode` (deprecato)</li><li>Chiama `preventDefault()` solo se necessario</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
document.addEventListener("keydown", (e) =&amp;gt; {
  if (e.key === "Escape") {
    console.log("Chiudi modale");
    e.preventDefault();
  }
  if (e.key === "s" &amp;amp;&amp;amp; (e.ctrlKey || e.metaKey)) {
    console.log("Salvataggio rapido");
    e.preventDefault();
  }
});
        </code></pre></div></li><li>Alternative:<ul><li>`keyup` per reagire al rilascio</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare il focus (l’evento non arriva dove immagini)</li><li>Usare `keyCode` (obsoleto e poco chiaro)</li></ul></li><li>Impatto sulle performance:<ul><li>Nullo; attenzione a logica pesante eseguita ad ogni tasto</li></ul></li><li>Conclusioni: Con `keydown` implementi scorciatoie e controlli da tastiera in modo pulito.</li></ol></details><details><summary>submit<span class="tag-description" aria-label="descrizione tag">Evento di invio di un form.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: `submit` si attiva quando un `form` viene inviato (tasto di invio o `Enter` in un input).</li><li>A cosa serve: Per validare, prevenire il redirect e inviare dati via fetch/AJAX.</li><li>Quando usarlo: Quando gestisci form in modo client-side o SPA.</li><li>Rilevanza semantica: Centrale per i flussi di input utente; mantiene accessibilità se usi elementi nativi.</li><li>Principali caratteristiche:<ul><li>Si attiva sul `form` (anche clic su `button[type="submit"]`)</li><li>Usa `event.preventDefault()` per bloccare l’invio tradizionale</li><li>Comodo con `FormData` per serializzare i campi</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Valida lato client e lato server</li><li>Disabilita il bottone durante l’invio per evitare doppie submissions</li><li>Gestisci gli errori di rete/validazione con messaggi chiari</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;form id="contact"&amp;gt;...&amp;lt;/form&amp;gt;
const form = document.querySelector("#contact");

form.addEventListener("submit", async (e) =&amp;gt; {
  e.preventDefault();
  const dati = new FormData(form);
  try {
    const res = await fetch("/api/contatti", { method: "POST", body: dati });
    if (!res.ok) throw new Error("Errore di invio");
    console.log("Inviato!");
  } catch (err) {
    console.error(err);
  }
});
        </code></pre></div></li><li>Alternative:<ul><li>Gestione `click` sul bottone (meno robusto: ignora `Enter`)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare `preventDefault()` quando usi fetch</li><li>Non impostare `name` ai campi (FormData vuoto)</li></ul></li><li>Impatto sulle performance:<ul><li>I costi sono lato rete; lato client trascurabili</li></ul></li><li>Conclusioni: `submit` è il gancio giusto per gestire form in modo accessibile e controllato.</li></ol></details><details><summary>Event object<span class="tag-description" aria-label="descrizione tag">L’oggetto passato ai listener con info e controlli sull’evento.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: L’`Event object` (spesso `event` o `e`) è il parametro che il browser passa ai listener, contenente dati e metodi dell’evento.</li><li>A cosa serve: Per capire cosa è successo (`type`, `target`, tasto premuto, coordinate, ecc.) e controllare il flusso (`preventDefault()`, `stopPropagation()`).</li><li>Quando usarlo: Praticamente sempre, appena devi leggere dettagli o modificare il comportamento di default.</li><li>Rilevanza semantica: Nodo centrale della gestione eventi; interfacce specializzate estendono `Event` (es. `KeyboardEvent`, `MouseEvent`, `PointerEvent`, `SubmitEvent`).</li><li>Principali caratteristiche:<ul><li>Proprietà comuni: `type`, `target`, `currentTarget`, `timeStamp`, `defaultPrevented`</li><li>Metodi: `preventDefault()`, `stopPropagation()`, `stopImmediatePropagation()`</li><li>Extra per eventi specifici (es. `key`, `clientX`, `pointerType`)</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser; alcune proprietà variano per tipo di evento</li></ul></li><li>Best practices:<ul><li>Preferisci `event.currentTarget` quando operi sull’elemento del listener</li><li>Non abusare di `stopPropagation()`; spesso la delegazione è migliore</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
document.addEventListener("click", (event) =&amp;gt; {
  console.log(event.type);           // "click"
  console.log(event.target);         // nodo reale cliccato
  console.log(event.currentTarget);  // dove è agganciato il listener (document)
  if (event.defaultPrevented) {
    console.log("Default già prevenuto");
  }
});
        </code></pre></div></li><li>Alternative:<ul><li>Variabili esterne (ma perdi informazioni specifiche e timing)</li></ul></li><li>Potenziali errori:<ul><li>Confondere `target` con `currentTarget`</li><li>Assumere proprietà non presenti per quel tipo di evento</li></ul></li><li>Impatto sulle performance:<ul><li>Istanze leggere; l’impatto è nella logica del tuo handler</li></ul></li><li>Conclusioni: L’oggetto evento è il tuo “biglietto d’ingresso” a tutto ciò che riguarda l’interazione.</li></ol></details><details><summary>Event bubbling<span class="tag-description" aria-label="descrizione tag">Propagazione dell’evento dal nodo figlio verso gli antenati.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: Il `bubbling` è la fase in cui un evento, dopo aver raggiunto il target, risale la gerarchia DOM fino al `document`.</li><li>A cosa serve: Permette di intercettare eventi a un livello superiore (utile per analitiche, delegazione, comportamenti globali).</li><li>Quando usarlo: Quando vuoi reagire a eventi dei figli senza aggiungere listener a ogni singolo nodo.</li><li>Rilevanza semantica: Concetto chiave del modello eventi del DOM insieme alla cattura.</li><li>Principali caratteristiche:<ul><li>Fasi: cattura → target → bubbling</li><li>`event.stopPropagation()` ferma la risalita</li><li>La maggior parte degli eventi DOM bubblano</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Evita di fermare la propagazione se non necessario</li><li>Usa selettori specifici in delegazione per evitare falsi positivi</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;div id="parent"&amp;gt;&amp;lt;button id="child"&amp;gt;Clicca&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;
const parent = document.querySelector("#parent");
const child = document.querySelector("#child");

parent.addEventListener("click", () =&amp;gt; console.log("Parent (bubbling)"));
child.addEventListener("click", () =&amp;gt; console.log("Child (target)"));
// Output tipico cliccando il bottone: "Child (target)" poi "Parent (bubbling)"
        </code></pre></div></li><li>Alternative:<ul><li>Cattura (`{ capture: true }`) se vuoi intercettare in discesa</li></ul></li><li>Potenziali errori:<ul><li>Usare `stopPropagation()` rompendo listener a monte</li><li>Non considerare che eventi sintetici possono comportarsi diversamente</li></ul></li><li>Impatto sulle performance:<ul><li>Positivo se riduci il numero di listener sfruttando un genitore</li></ul></li><li>Conclusioni: Il bubbling è la “risalita” che ti permette di ascoltare eventi in un solo punto.</li></ol></details><details><summary>Event delegation<span class="tag-description" aria-label="descrizione tag">Gestire molti eventi figli con un solo listener sul genitore.</span><div class="tag-group" aria-label="gruppo">11. Eventi</div></summary><ol><li>Cos'è: La `delegation` consiste nell’attaccare un singolo listener su un antenato e distinguere i target veri all’interno del callback.</li><li>A cosa serve: Per gestire liste dinamiche, molti elementi, contenuti generati dopo il load.</li><li>Quando usarlo: Quando il numero di nodi è grande o cambia nel tempo.</li><li>Rilevanza semantica: Pattern essenziale per UI dinamiche e performanti.</li><li>Principali caratteristiche:<ul><li>Sfrutta il bubbling</li><li>Usa `event.target`/`closest()` per individuare l’elemento rilevante</li><li>Riduce il numero di listener e la memoria usata</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser (metodo `closest()` supportato dai moderni)</li></ul></li><li>Best practices:<ul><li>Filtra con `matches()` o `closest()`</li><li>Non delegare su `document` se puoi limitare lo scope</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;ul id="todo"&amp;gt;...&amp;lt;/ul&amp;gt;
// Delego il click sui bottoni .remove dentro la lista
const list = document.querySelector("#todo");

list.addEventListener("click", (e) =&amp;gt; {
  const btn = e.target.closest("button.remove");
  if (!btn) return; // click non rilevante
  const item = btn.closest("li");
  item?.remove();
});
        </code></pre></div></li><li>Alternative:<ul><li>Un listener per ogni figlio (più semplice ma meno scalabile)</li></ul></li><li>Potenziali errori:<ul><li>Selettori troppo generici che catturano click indesiderati</li><li>Delegare troppo in alto aumentando il lavoro ad ogni evento</li></ul></li><li>Impatto sulle performance:<ul><li>Ottimo su liste grandi/dinamiche: meno listener, meno memoria</li></ul></li><li>Conclusioni: La delegazione rende le UI reattive e leggere, soprattutto su contenuti dinamici.</li></ol></details><details><summary>getElementById()<span class="tag-description" aria-label="descrizione tag">Seleziona un elemento tramite il suo id univoco.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `getElementById()` è un metodo del `document` che restituisce l’elemento con l’attributo `id` corrispondente.</li><li>A cosa serve: A ottenere rapidamente un singolo nodo noto e univoco nel DOM.</li><li>Quando usarlo: Quando conosci l’`id` e vuoi la via più veloce e chiara per recuperare quell’elemento.</li><li>Rilevanza semantica: Selezione diretta e univoca; facilita codice chiaro e intenzionale.</li><li>Principali caratteristiche:<ul><li>Firma: `document.getElementById(id)`</li><li>Restituisce un elemento o `null`</li><li>Ricerca case-sensitive</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Usa `id` veramente unici nel documento</li><li>Preferiscilo quando l’`id` esiste: è veloce e leggibile</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;div id="hero"&amp;gt;Ciao&amp;lt;/div&amp;gt;
const hero = document.getElementById("hero");
if (hero) {
  hero.textContent = "Benvenuto!";
}
        </code></pre></div></li><li>Alternative:<ul><li>`querySelector("#id")` (più flessibile, leggermente meno diretto)</li></ul></li><li>Potenziali errori:<ul><li>Id duplicati nel documento (comportamento ambiguo)</li><li>Assumere che non possa restituire `null`</li></ul></li><li>Impatto sulle performance:<ul><li>Molto efficiente; tra le selezioni più rapide</li></ul></li><li>Conclusioni: Semplice, chiaro e veloce quando lavori con `id` univoci.</li></ol></details><details><summary>querySelector()<span class="tag-description" aria-label="descrizione tag">Seleziona il primo elemento che corrisponde a un selettore CSS.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `querySelector()` restituisce il primo elemento nel DOM che corrisponde al selettore CSS fornito.</li><li>A cosa serve: A selezionare elementi in modo flessibile usando qualsiasi selettore CSS valido.</li><li>Quando usarlo: Quando ti basta il primo match o vuoi una sintassi CSS coerente.</li><li>Rilevanza semantica: Uniforma la selezione DOM al linguaggio dei selettori del CSS.</li><li>Principali caratteristiche:<ul><li>Firma: `root.querySelector(selettore)` dove `root` può essere `document` o un nodo</li><li>Accetta selettori complessi (`.class`, `#id`, `div > a[href^="/"]`)</li><li>Restituisce un elemento o `null`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni e IE8+ (parziale)</li></ul></li><li>Best practices:<ul><li>Limita lo scope: usa `container.querySelector(...)` quando possibile</li><li>Controlla sempre il `null` prima di usare il risultato</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;ul id="menu"&amp;gt;&amp;lt;li class="active"&amp;gt;Home&amp;lt;/li&amp;gt;...&amp;lt;/ul&amp;gt;
const activeItem = document.querySelector("#menu li.active");
activeItem?.classList.remove("active");
        </code></pre></div></li><li>Alternative:<ul><li>`getElementById()` per id univoci; `querySelectorAll()` per più elementi</li></ul></li><li>Potenziali errori:<ul><li>Selettori troppo generici che catturano nodi sbagliati</li><li>Dare per scontato che trovi sempre qualcosa</li></ul></li><li>Impatto sulle performance:<ul><li>Efficiente; selettori molto complessi possono costare di più</li></ul></li><li>Conclusioni: Il coltellino svizzero per selezioni singole, leggibile e potente.</li></ol></details><details><summary>querySelectorAll()<span class="tag-description" aria-label="descrizione tag">Seleziona tutti gli elementi che corrispondono a un selettore CSS (NodeList).</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `querySelectorAll()` restituisce una `NodeList` statica di tutti gli elementi che corrispondono al selettore.</li><li>A cosa serve: A ottenere collezioni di nodi su cui iterare (mappe, toggle classi, ecc.).</li><li>Quando usarlo: Quando devi agire su più elementi in una volta.</li><li>Rilevanza semantica: Selezione CSS coerente anche per liste multiple.</li><li>Principali caratteristiche:<ul><li>Firma: `root.querySelectorAll(selettore)`</li><li>Ritorna `NodeList` statica (non si aggiorna automaticamente)</li><li>Iterabile con `for...of`, convertibile in Array con `[...nodelist]`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni e IE9+</li></ul></li><li>Best practices:<ul><li>Usa selettori specifici per ridurre l’insieme</li><li>Evita lavori pesanti dentro il loop; estrai funzioni</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;button class="filter"&amp;gt;...&amp;lt;/button&amp;gt; (x N)
const buttons = document.querySelectorAll("button.filter");
for (const btn of buttons) {
  btn.addEventListener("click", () =&amp;gt; btn.classList.toggle("active"));
}
        </code></pre></div></li><li>Alternative:<ul><li>`getElementsByClassName()`/`getElementsByTagName()` (HTMLCollection live)</li></ul></li><li>Potenziali errori:<ul><li>Credere che la lista sia “live” (non lo è)</li><li>Usare metodi Array direttamente senza convertirla</li></ul></li><li>Impatto sulle performance:<ul><li>Dipende dalla dimensione del set; preferisci scope ristretto</li></ul></li><li>Conclusioni: Ottimo per modifiche di massa con sintassi CSS pulita.</li></ol></details><details><summary>innerHTML<span class="tag-description" aria-label="descrizione tag">Legge o imposta il markup HTML interno di un elemento.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `innerHTML` è una proprietà che ritorna o imposta l’HTML interno di un nodo come stringa.</li><li>A cosa serve: A aggiornare rapidamente porzioni di UI generando markup via stringhe.</li><li>Quando usarlo: Quando devi inserire blocchi di HTML completi e controlli la fonte dei dati.</li><li>Rilevanza semantica: Molto comodo ma attenzione alla sicurezza (XSS) e alla perdita di listener.</li><li>Principali caratteristiche:<ul><li>Assegna stringhe HTML che vengono parse e sostituiscono i figli</li><li>Lettura restituisce il markup corrente</li><li>Rimuove e ricrea i nodi figli (listener compresi)</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Sanifica/escapa i dati non fidati</li><li>Preferisci API DOM (`createElement`, `textContent`) quando possibile</li><li>Evita aggiornamenti troppo frequenti su grandi blocchi</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;div id="out"&amp;gt;&amp;lt;/div&amp;gt;
const out = document.querySelector("#out");
out.innerHTML = `&amp;lt;h2&amp;gt;Titolo&amp;lt;/h2&amp;gt;&amp;lt;p&amp;gt;Contenuto&amp;lt;/p&amp;gt;`;
        </code></pre></div></li><li>Alternative:<ul><li>`textContent` per testo puro</li><li>Costruzione DOM con `createElement` + `append`</li></ul></li><li>Potenziali errori:<ul><li>Inserire HTML non fidato (XSS)</li><li>Perdere listener e stato interno dei nodi</li></ul></li><li>Impatto sulle performance:<ul><li>Reflow/repaint potenzialmente costosi su blocchi grandi</li></ul></li><li>Conclusioni: Potente e comodo, ma usalo con giudizio e in sicurezza.</li></ol></details><details><summary>textContent<span class="tag-description" aria-label="descrizione tag">Legge o imposta il testo (non HTML) di un elemento.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `textContent` è una proprietà che gestisce il contenuto testuale puro di un nodo.</li><li>A cosa serve: A impostare/ottenere testo sicuro senza interpretare HTML.</li><li>Quando usarlo: Quando devi mostrare dati utente o testo dinamico non formattato.</li><li>Rilevanza semantica: Previene XSS e mantiene il contenuto come testo letterale.</li><li>Principali caratteristiche:<ul><li>Non parse l’HTML (lo mostra come testo)</li><li>Più veloce e sicuro di `innerHTML` per solo testo</li><li>Include il testo dei nodi discendenti</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser moderni</li></ul></li><li>Best practices:<ul><li>Preferiscilo per dati esterni non fidati</li><li>Usa `innerHTML` solo quando serve davvero markup</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;p id="msg"&amp;gt;&amp;lt;/p&amp;gt;
document.getElementById("msg").textContent = "Ciao &amp;lt;strong&amp;gt;mondo&amp;lt;/strong&amp;gt;!";
// Renderizza letteralmente i tag, non li interpreta
        </code></pre></div></li><li>Alternative:<ul><li>`innerText` (rispetta CSS, più lento; usalo raramente)</li></ul></li><li>Potenziali errori:<ul><li>Confondere `textContent` con `innerHTML` aspettandosi formattazione</li></ul></li><li>Impatto sulle performance:<ul><li>Ottimo: aggiornamenti testuali sono economici</li></ul></li><li>Conclusioni: La scelta sicura e veloce per testo puro.</li></ol></details><details><summary>createElement()<span class="tag-description" aria-label="descrizione tag">Crea un nuovo nodo elemento.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `createElement()` crea un nuovo elemento DOM del tipo specificato.</li><li>A cosa serve: A costruire interfacce dinamicamente senza passare da stringhe HTML.</li><li>Quando usarlo: Quando vuoi controllo fine e sicurezza nella generazione dei nodi.</li><li>Rilevanza semantica: Favorisce struttura DOM corretta e previene injection.</li><li>Principali caratteristiche:<ul><li>Firma: `document.createElement(tagName, opzioni)`</li><li>Non è nel DOM finché non lo appendi</li><li>Supporta elementi personalizzati (Web Components)</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Imposta attributi, classi e `textContent` prima di appendere</li><li>Usa `DocumentFragment` per inserimenti multipli</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const li = document.createElement("li");
li.className = "todo-item";
li.textContent = "Studiare DOM";
document.querySelector("#todo").appendChild(li);
        </code></pre></div></li><li>Alternative:<ul><li>`innerHTML` per blocchi semplici (con attenzione alla sicurezza)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di inserire il nodo nel DOM (non si vede nulla)</li></ul></li><li>Impatto sulle performance:<ul><li>Molto buono, specialmente con `DocumentFragment` o batching</li></ul></li><li>Conclusioni: Base solida per creare UI dinamiche e sicure.</li></ol></details><details><summary>appendChild()<span class="tag-description" aria-label="descrizione tag">Inserisce un nodo come ultimo figlio di un altro nodo.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `appendChild()` aggiunge un nodo esistente o nuovo alla fine dei figli di un nodo padre.</li><li>A cosa serve: A costruire/aggiornare la struttura DOM in modo esplicito.</li><li>Quando usarlo: Quando devi inserire un singolo nodo in coda ai figli.</li><li>Rilevanza semantica: Operazione fondamentale di manipolazione DOM.</li><li>Principali caratteristiche:<ul><li>Firma: `parent.appendChild(child)`</li><li>Se `child` era già nel DOM, viene spostato</li><li>Restituisce il nodo aggiunto</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Per inserire più nodi, usa `DocumentFragment`</li><li>In alternativa moderna: `parent.append(node | string)`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const list = document.querySelector("#todo");
const item = document.createElement("li");
item.textContent = "Fare pratica";
list.appendChild(item);
        </code></pre></div></li><li>Alternative:<ul><li>`append()` (accetta più nodi/stringhe)</li><li>`insertBefore()` per posizioni specifiche</li></ul></li><li>Potenziali errori:<ul><li>Provare ad appendere `null` o nodi di tipo non valido</li></ul></li><li>Impatto sulle performance:<ul><li>Economico; riduci i reflow raggruppando gli inserimenti</li></ul></li><li>Conclusioni: Semplice e affidabile per aggiungere contenuti in fondo.</li></ol></details><details><summary>removeChild()<span class="tag-description" aria-label="descrizione tag">Rimuove un nodo figlio da un nodo padre.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `removeChild()` elimina un nodo figlio specifico dal suo genitore.</li><li>A cosa serve: A rimuovere elementi dalla pagina e liberare risorse collegate.</li><li>Quando usarlo: Quando conosci il riferimento al figlio da togliere.</li><li>Rilevanza semantica: Fondamentale per aggiornamenti e cleanup del DOM.</li><li>Principali caratteristiche:<ul><li>Firma: `parent.removeChild(child)`</li><li>Restituisce il nodo rimosso (non più nel DOM)</li><li>Eventi/listener sul nodo vengono persi a meno di re-attach</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Verifica che `child` appartenga davvero a `parent`</li><li>In alternativa moderna: `child.remove()`</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
const list = document.querySelector("#todo");
const first = list.querySelector("li");
if (first) {
  list.removeChild(first);
}
        </code></pre></div></li><li>Alternative:<ul><li>`Node.prototype.remove()` più conciso</li></ul></li><li>Potenziali errori:<ul><li>Chiamarlo con un nodo che non è figlio diretto (errore)</li></ul></li><li>Impatto sulle performance:<ul><li>Leggero; rimuovere grandi sottoalberi può costare</li></ul></li><li>Conclusioni: Metodo classico e preciso per rimuovere nodi.</li></ol></details><details><summary>setAttribute()<span class="tag-description" aria-label="descrizione tag">Imposta o aggiorna un attributo su un elemento.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `setAttribute()` definisce o modifica il valore di un attributo HTML su un elemento.</li><li>A cosa serve: A gestire attributi generici come `src`, `href`, `aria-*`, `data-*`, ecc.</li><li>Quando usarlo: Quando l’attributo non ha una proprietà DOM diretta, o vuoi coerenza esplicita.</li><li>Rilevanza semantica: Mantiene sincronizzati DOM e markup; utile per accessibilità (ARIA).</li><li>Principali caratteristiche:<ul><li>Firma: `element.setAttribute(nome, valore)`</li><li>Crea l’attributo se non esiste</li><li>Funziona bene con `data-*` e `aria-*`</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser</li></ul></li><li>Best practices:<ul><li>Per attributi booleani usa proprietà (`el.disabled = true`) quando possibile</li><li>Per `data-*` valuta `element.dataset` (più ergonomico)</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;img id="pic"&amp;gt;
const img = document.getElementById("pic");
img.setAttribute("alt", "Foto profilo");
img.setAttribute("src", "/img/me.jpg");
        </code></pre></div></li><li>Alternative:<ul><li>Proprietà DOM: `img.src = "..."`, `link.href = "..."`</li><li>`dataset` per `data-*`</li></ul></li><li>Potenziali errori:<ul><li>Confondere nome attributo e proprietà (es. `class` vs `className`)</li></ul></li><li>Impatto sulle performance:<ul><li>Minimo; batch di aggiornamenti riducono reflow</li></ul></li><li>Conclusioni: Strumento universale per gli attributi, chiaro e prevedibile.</li></ol></details><details><summary>classList<span class="tag-description" aria-label="descrizione tag">API per gestire le classi CSS di un elemento.</span><div class="tag-group" aria-label="gruppo">12. DOM</div></summary><ol><li>Cos'è: `classList` è un’API dell’elemento che fornisce metodi per aggiungere, rimuovere, alternare e verificare classi CSS.</li><li>A cosa serve: A manipolare le classi in modo semplice senza stringhe manuali.</li><li>Quando usarlo: Quasi sempre quando cambi classi dinamicamente.</li><li>Rilevanza semantica: Mantiene il CSS come sorgente di verità per lo stile/stato UI.</li><li>Principali caratteristiche:<ul><li>Metodi: `add`, `remove`, `toggle`, `contains`, `replace`</li><li>Supporta più classi in un’unica chiamata</li><li>Restituisce boolean da `toggle("x", force)`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni (IE10+ con limitazioni)</li></ul></li><li>Best practices:<ul><li>Usa classi come stati (es. `.is-open`, `.is-active`)</li><li>Evita stringhe su `className` salvo necessità globali</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// HTML: &amp;lt;div id="panel" class="panel"&amp;gt;&amp;lt;/div&amp;gt;
const panel = document.getElementById("panel");
panel.classList.add("is-open");
panel.classList.toggle("highlight");
if (panel.classList.contains("is-open")) {
  panel.classList.replace("is-open", "is-visible");
}
        </code></pre></div></li><li>Alternative:<ul><li>`element.className = "...";` (sostituisce l’intera stringa)</li></ul></li><li>Potenziali errori:<ul><li>Toggle senza “force” e logiche che diventano imprevedibili</li></ul></li><li>Impatto sulle performance:<ul><li>Ottimo; cambi di classe sono economici e diffusi</li></ul></li><li>Conclusioni: L’API giusta per gestire stati CSS in modo pulito e scalabile.</li></ol></details><details><summary>import<span class="tag-description" aria-label="descrizione tag">Include funzioni/variabili/classi da altri moduli.</span><div class="tag-group" aria-label="gruppo">13. Moduli</div></summary><ol><li>Cos'è: `import` è la sintassi degli ES Modules per usare codice esportato da un altro file (modulo).</li><li>A cosa serve: A dividere il codice in file riutilizzabili, mantenendo dipendenze chiare.</li><li>Quando usarlo: Quando vuoi organizzare il progetto per feature, evitare variabili globali e abilitare il tree-shaking.</li><li>Rilevanza semantica: Standard moderno per modularizzare JavaScript in browser e Node.js.</li><li>Principali caratteristiche:<ul><li>Importa default e/o named exports</li><li>Supporta alias (`as`)</li><li>Import dinamico: `import("path")` ritorna una `Promise`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni con `&lt;script type="module"&gt;`</li><li>Node.js con `"type": "module"` o estensione `.mjs`</li></ul></li><li>Best practices:<ul><li>Usa percorsi espliciti (`"./utils.js"`) nel browser</li><li>Raggruppa import dallo stesso modulo in un’unica riga</li><li>Usa import dinamico per caricare parti “pesanti” on-demand</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// utils.js
export function somma(a, b) { return a + b; }
export const PI = 3.14159;
export default class Logger { log(x) { console.log(x); } }

// main.js
import Logger, { somma, PI as pi } from "./utils.js";
const log = new Logger();
log.log(somma(2, 3), pi);

// import dinamico (code-splitting)
document.getElementById("btn").addEventListener("click", async () =&amp;gt; {
  const mod = await import("./heavy-widget.js");
  mod.mountWidget();
});
        </code></pre></div></li><li>Alternative:<ul><li>CommonJS (`require`) in ambienti legacy</li><li>Bundler che risolve “bare specifiers” (Vite, Webpack)</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare `&lt;script type="module"&gt;` nel browser (niente import)</li><li>Percorsi senza `./` o estensione quando il server non li risolve</li><li>Confondere default e named import</li></ul></li><li>Impatto sulle performance:<ul><li>Migliora caching e caricamento grazie a chunk e import dinamici</li><li>Troppi moduli minuscoli = molte richieste (usa bundling in produzione)</li></ul></li><li>Conclusioni: `import` rende il codice modulare, testabile e ottimizzabile (tree-shaking + split).</li></ol></details><details><summary>export<span class="tag-description" aria-label="descrizione tag">Rende elementi del modulo disponibili ad altri file.</span><div class="tag-group" aria-label="gruppo">13. Moduli</div></summary><ol><li>Cos'è: `export` espone funzioni, costanti, classi o valori dal modulo corrente.</li><li>A cosa serve: A condividere API tra file mantenendo un encapsulamento naturale.</li><li>Quando usarlo: Quando vuoi riutilizzare codice o isolare responsabilità in più file.</li><li>Rilevanza semantica: Cardine degli ES Modules assieme a `import`.</li><li>Principali caratteristiche:<ul><li>Due forme: `export` nominato e `export default`</li><li>Puoi re-esportare: `export { x } from "./mod.js"`</li><li>Puoi esportare al volo: `export function foo(){}`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni (`type="module"`)</li><li>Node.js con ESM abilitato</li></ul></li><li>Best practices:<ul><li>Esporta solo ciò che fa parte dell’API pubblica</li><li>Preferisci named exports per librerie; default per “singola cosa”</li><li>Raggruppa gli export in fondo o crea un `index.js` re-export</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// math.js
export const TAU = Math.PI * 2;
export function clamp(n, min, max) { return Math.min(Math.max(n, min), max); }
export default function media(...nums) {
  return nums.reduce((a,n) =&amp;gt; a + n, 0) / nums.length;
}

// alt-reexport.js
export { clamp as limit } from "./math.js";
export * as math from "./math.js";
        </code></pre></div></li><li>Alternative:<ul><li>CommonJS: `module.exports` / `exports.foo`</li></ul></li><li>Potenziali errori:<ul><li>Mescolare più `export default` (consentito uno solo per file)</li><li>Esportare simboli non definiti o con nomi sbagliati</li></ul></li><li>Impatto sulle performance:<ul><li>Consente tree-shaking (rimuove export non usati) con bundler</li></ul></li><li>Conclusioni: `export` definisce l’API del file; mantienila piccola, chiara e documentata.</li></ol></details><details><summary>default export<span class="tag-description" aria-label="descrizione tag">Esporta il “valore principale” del modulo.</span><div class="tag-group" aria-label="gruppo">13. Moduli</div></summary><ol><li>Cos'è: Il `default export` è l’esportazione di default di un modulo: ce n’è al massimo una per file.</li><li>A cosa serve: A indicare un’uscita “principale” (es. una classe, una funzione factory, un componente).</li><li>Quando usarlo: Quando il modulo ruota attorno a una singola entità.</li><li>Rilevanza semantica: Comunica l’intento: “questo è ciò che probabilmente vuoi importare”.</li><li>Principali caratteristiche:<ul><li>Importazione libera nel nome: `import QualsiasiNome from "./mod.js"`</li><li>Puoi combinarlo con named exports nello stesso file</li><li>Puoi esportare inline: `export default function(){}`</li></ul></li><li>Compatibilità:<ul><li>Browser moderni e Node.js con ESM</li></ul></li><li>Best practices:<ul><li>Usalo con parsimonia: molti default sparsi confondono</li><li>Nelle librerie spesso sono preferibili solo named exports</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// modal.js
export default class Modal {
  open(){ /* ... */ }
  close(){ /* ... */ }
}
export function createModal(){ return new Modal(); }

// app.js
import Modal, { createModal } from "./modal.js";
const m = new Modal();
const m2 = createModal();
        </code></pre></div></li><li>Alternative:<ul><li>Solo named exports per API più esplicite</li></ul></li><li>Potenziali errori:<ul><li>Credere di poter avere più `default` nello stesso file</li><li>Importare come named: `import { Modal }` (sbagliato se era default)</li></ul></li><li>Impatto sulle performance:<ul><li>Nessuna differenza intrinseca rispetto ai named; conta l’uso</li></ul></li><li>Conclusioni: Ottimo per moduli “monotematici”, ma non abusarne nei progetti grandi.</li></ol></details><details><summary>named export<span class="tag-description" aria-label="descrizione tag">Esporta uno o più simboli nominati.</span><div class="tag-group" aria-label="gruppo">13. Moduli</div></summary><ol><li>Cos'è: I `named export` espongono più simboli con nome (funzioni, costanti, classi) dallo stesso modulo.</li><li>A cosa serve: A fornire un set di utilità importabili selettivamente.</li><li>Quando usarlo: Quando il modulo contiene più funzioni correlate o una piccola libreria.</li><li>Rilevanza semantica: API più esplicite: chi importa decide cosa usare, favorendo tree-shaking.</li><li>Principali caratteristiche:<ul><li>Import esplicito per nome: `import { parse, format } from "./date.js"`</li><li>Supporta alias: `import { parse as p } ...`</li><li>Puoi esportare dichiarando o raggruppando in fondo</li></ul></li><li>Compatibilità:<ul><li>Browser moderni e Node.js con ESM</li></ul></li><li>Best practices:<ul><li>Mantieni i nomi coerenti e descrittivi</li><li>Evita export “tutto e il lavandino”; esporta solo ciò che serve</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
// date.js
export function parse(str){ /* ... */ }
export function format(date){ /* ... */ }
export const ONE_DAY = 86400000;

// usage.js
import { parse, format, ONE_DAY as DAY } from "./date.js";
const d = parse("2025-08-15");
console.log(format(d), DAY);
        </code></pre></div></li><li>Alternative:<ul><li>`export default` se esiste un’unica entità principale</li></ul></li><li>Potenziali errori:<ul><li>Importare un nome inesistente (errore in build/runtime)</li><li>Rinominare in export ma dimenticare l’alias in import</li></ul></li><li>Impatto sulle performance:<ul><li>Favorisce il tree-shaking: bundle più piccoli</li></ul></li><li>Conclusioni: Preferisci i named per API chiare, componibili e facilmente ottimizzabili.</li></ol></details><details><summary>Strict mode<span class="tag-description" aria-label="descrizione tag">Modalità che abilita regole più restrittive in JavaScript.</span><div class="tag-group" aria-label="gruppo">14. Altri concetti</div></summary><ol><li>Cos'è: Lo `Strict mode` è una modalità che rende JavaScript più rigoroso, attivando controlli e limitazioni che aiutano a evitare errori comuni.</li><li>A cosa serve: A prevenire comportamenti impliciti e ambigui, migliorando la sicurezza e la compatibilità futura del codice.</li><li>Quando usarlo: Sempre nei file o funzioni moderne; molti strumenti lo attivano automaticamente.</li><li>Rilevanza semantica: Segnala che il codice segue regole più sicure e moderne.</li><li>Principali caratteristiche:<ul><li>Si attiva con `"use strict";` all’inizio di file o funzione</li><li>Blocca variabili globali implicite</li><li>Impedisce di eliminare variabili e funzioni</li><li>Previene nomi duplicati nei parametri</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser moderni e ambienti JavaScript</li></ul></li><li>Best practices:<ul><li>Usalo sempre per codice nuovo</li><li>Ricorda che i moduli ESM sono “strict” di default</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
"use strict";
x = 10; // Errore: x non dichiarata
        </code></pre></div></li><li>Alternative:<ul><li>Nessuna diretta; è una feature integrata</li></ul></li><li>Potenziali errori:<ul><li>Dimenticare di dichiarare le variabili</li></ul></li><li>Impatto sulle performance:<ul><li>Può leggermente migliorare le ottimizzazioni del motore JS</li></ul></li><li>Conclusioni: Lo strict mode è come una cintura di sicurezza: meglio averla sempre allacciata.</li></ol></details><details><summary>Hoisting<span class="tag-description" aria-label="descrizione tag">Comportamento che sposta dichiarazioni in cima allo scope.</span><div class="tag-group" aria-label="gruppo">14. Altri concetti</div></summary><ol><li>Cos'è: L’`Hoisting` è il comportamento per cui le dichiarazioni (non le assegnazioni) vengono “spostate” in cima allo scope durante la fase di compilazione.</li><li>A cosa serve: A permettere di usare variabili o funzioni dichiarate più in basso nel codice (ma con differenze tra `var`, `let`, `const`).</li><li>Quando usarlo: Non va “usato”, ma conosciuto per capire perché certe cose funzionano o generano errori.</li><li>Rilevanza semantica: Fondamentale per comprendere il comportamento dello scope in JS.</li><li>Principali caratteristiche:<ul><li>Le `function declaration` sono hoistate con il corpo</li><li>`var` viene hoistata ma inizializzata a `undefined`</li><li>`let` e `const` sono hoistate ma restano in TDZ fino alla dichiarazione</li></ul></li><li>Compatibilità:<ul><li>Comportamento standard in tutti i motori JS</li></ul></li><li>Best practices:<ul><li>Dichiara sempre variabili e funzioni prima di usarle</li><li>Evita di fare affidamento sull’hoisting per chiarezza</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
saluta(); // Funziona
function saluta() { console.log("Ciao"); }

console.log(x); // undefined (hoisting var)
var x = 5;
        </code></pre></div></li><li>Alternative:<ul><li>Scrivere codice in ordine logico</li></ul></li><li>Potenziali errori:<ul><li>Usare `let` o `const` prima della dichiarazione → TDZ Error</li></ul></li><li>Impatto sulle performance:<ul><li>Nessun impatto diretto; è parte del parsing JS</li></ul></li><li>Conclusioni: L’hoisting è utile da capire, ma non da sfruttare per “risparmiare righe”.</li></ol></details><details><summary>Temporal Dead Zone (TDZ)<span class="tag-description" aria-label="descrizione tag">Periodo tra hoisting e inizializzazione in cui la variabile non è accessibile.</span><div class="tag-group" aria-label="gruppo">14. Altri concetti</div></summary><ol><li>Cos'è: La `TDZ` è l’intervallo tra l’inizio dello scope e la dichiarazione effettiva di una variabile `let` o `const` in cui accedervi genera errore.</li><li>A cosa serve: A prevenire l’uso di variabili non inizializzate, rendendo il codice più sicuro.</li><li>Quando usarlo: Non è una feature da usare, ma un comportamento da conoscere per evitare ReferenceError.</li><li>Rilevanza semantica: Garantisce che `let` e `const` siano inizializzate prima dell’uso.</li><li>Principali caratteristiche:<ul><li>Si applica solo a `let` e `const`</li><li>Finisce al momento della dichiarazione</li><li>Vale anche per parametri `default` che usano variabili non ancora inizializzate</li></ul></li><li>Compatibilità:<ul><li>Tutti i browser moderni</li></ul></li><li>Best practices:<ul><li>Dichiara e inizializza variabili subito, all’inizio dello scope</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
console.log(a); // ReferenceError
let a = 3;
        </code></pre></div></li><li>Alternative:<ul><li>Usare `var` (ma con effetti collaterali di hoisting)</li></ul></li><li>Potenziali errori:<ul><li>Usare una variabile in TDZ senza rendersene conto</li></ul></li><li>Impatto sulle performance:<ul><li>Nessuno; è solo un controllo in fase di esecuzione</li></ul></li><li>Conclusioni: La TDZ ti obbliga a usare le variabili in modo ordinato e sicuro.</li></ol></details><details><summary>Garbage collection<span class="tag-description" aria-label="descrizione tag">Processo automatico che libera memoria non più usata.</span><div class="tag-group" aria-label="gruppo">14. Altri concetti</div></summary><ol><li>Cos'è: Il `Garbage collection` è il meccanismo del motore JavaScript che rimuove dalla memoria gli oggetti non più raggiungibili.</li><li>A cosa serve: A prevenire sprechi di memoria e rallentamenti dovuti a variabili inutilizzate.</li><li>Quando usarlo: Sempre: è automatico e non richiede codice esplicito.</li><li>Rilevanza semantica: Fondamentale per la gestione della memoria in linguaggi “managed” come JS.</li><li>Principali caratteristiche:<ul><li>Algoritmo comune: “mark-and-sweep”</li><li>Non si può forzare direttamente in JS puro</li><li>Funziona rilevando oggetti non più referenziati</li></ul></li><li>Compatibilità:<ul><li>Tutti i motori JavaScript (V8, SpiderMonkey, Chakra, ecc.)</li></ul></li><li>Best practices:<ul><li>Annulla i riferimenti a oggetti grandi quando non servono</li><li>Evita variabili globali non necessarie</li><li>Chiudi timer/event listener quando non servono più</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
let bigData = { huge: "..." };
bigData = null; // Ora l’oggetto è liberabile dal GC
        </code></pre></div></li><li>Alternative:<ul><li>In JS puro, nessuna; in WebAssembly o addon nativi può esserci manuale</li></ul></li><li>Potenziali errori:<ul><li>Creare memory leak mantenendo riferimenti non voluti</li></ul></li><li>Impatto sulle performance:<ul><li>Generalmente invisibile; pause brevi nei GC ciclici</li></ul></li><li>Conclusioni: Il GC ti evita la fatica di liberare memoria, ma richiede codice ordinato per funzionare bene.</li></ol></details><details><summary>Prototype chain<span class="tag-description" aria-label="descrizione tag">Meccanismo di ereditarietà tra oggetti in JavaScript.</span><div class="tag-group" aria-label="gruppo">14. Altri concetti</div></summary><ol><li>Cos'è: La `Prototype chain` è la catena di prototipi usata da JavaScript per cercare proprietà/metodi non presenti direttamente in un oggetto.</li><li>A cosa serve: A implementare ereditarietà e condivisione di metodi tra oggetti.</li><li>Quando usarlo: Sempre: ogni oggetto in JS (tranne `Object.create(null)`) ha un prototipo.</li><li>Rilevanza semantica: È il cuore del modello a prototipi di JavaScript.</li><li>Principali caratteristiche:<ul><li>Si accede al prototipo con `Object.getPrototypeOf(obj)`</li><li>`obj.__proto__` è deprecato (usa i metodi ufficiali)</li><li>La catena finisce con `Object.prototype` o `null`</li></ul></li><li>Compatibilità:<ul><li>Tutti gli ambienti JS</li></ul></li><li>Best practices:<ul><li>Preferisci `class` o `Object.create()` per definire la catena</li><li>Evita modifiche dirette a `Object.prototype` (rischio globale)</li></ul></li><li>Esempi di codice:<div class="code-container"><button class="copy-btn" onclick="copyCode(this)"><i class="fa-copy fas"></i> Copia</button><pre><code>
function Animale(nome) {
  this.nome = nome;
}
Animale.prototype.parla = function() {
  console.log(this.nome + " fa un verso");
};

const cane = new Animale("Fido");
cane.parla(); // "Fido fa un verso"
console.log(Object.getPrototypeOf(cane) === Animale.prototype); // true
        </code></pre></div></li><li>Alternative:<ul><li>Classi ES6 (syntax sugar sopra i prototipi)</li></ul></li><li>Potenziali errori:<ul><li>Confondere proprietà dell’istanza con quelle nel prototipo</li></ul></li><li>Impatto sulle performance:<ul><li>Lookup lungo la catena è leggermente più lento, ma di solito trascurabile</li></ul></li><li>Conclusioni: La prototype chain è il “DNA” degli oggetti JS: impararla sblocca comprensione profonda del linguaggio.</li></ol></details></section></main></div></body></html>